


























This is a collection of notes and scratchings on Larry's efforts in
the Whirlwind project. It started as a doc dump for the tester, but
has expanded into assembler and other areas.
----------------------------------------------------------------------

Testing system
==============

LAS 1/1/25: Note this now represents the latest attempt at testing,
which largely discards the first idea, using yaml, etc. So those notes
are gone and are available via a previous git version. Some of the
rationale for the change is below in a note to Guy dated Nov 2024.

The main thing new is that we're script-based, and use basic scripting
to run tests and do diffs. It's based on bolier-plate scripting which
is copied an modified to make a new test. The convenience and
flexibility of such script developement outweighs the "badness" of the
redundancy, and if needed we can develop mass-editing tools to help us
if an across-the-board change is needed.

We also get free of having to provide tests only in a special "test"
area. Though we'll have one of those, tests can be anywhere in the dev
tree.

Tests are denoted by the existence of a script in a dir called
runtest.sh. This conains the info needed to run the test, filter and
compare files, announce passage or failure, and accept a test once
blessed.

To serve as a test, we need test references, so another assumption is
the existence of a TestRefs dir, probably, but not required to be,
co-resident in the dir with runtest.sh, and by convention called
TestRefs, but not required.

Each runtest.sh must have a --Accept option, which copies a set of log
or output files to the test refs area.

Each runtest.sh also has a standard cd to its own location (i.e., the
dir of arg $0), to allow it to be run more easily from an external
program. In particular, ro run all tests,

   cd <whirlwind-simulator-top-level-dir>
   find . -name runtest.sh -print -exec {} \;

While I have considered making the wwtester.py code be a more
comprehensive test tool, as I did at first, I don't see the need, and
I'll archive this program in some way. Some of the techniques for
subprocess management and other items may be useful for something. But
overall my goal is to use scripts as much as possible for driving the
tests.

----------------------------------------------------------------------






Log formatting and conventions
	Seqno across all logs
	info, warning, error (etc?)
	Option (default?) for warning and error to go to stderr too.
		For asm, disasm, should be default, -q suppresses
		For sim, quiet would be default, and verbose brings out warning and error

!!! In wwsim.py:
# There can be a source file that contains subroutines that might be called by exec statements specific
#   to the particular project under simulation.  If the file exists in the current working dir, import it.
if os.path.exists("project_exec.py"):
    sys.path.append('.')
    from project_exec import *
    print("imported project_exec.py")

  Must be in wd!






wwasm
disasm
	Default: errors, warnings, fatals, and info all go to asm/disasm log
			 errors, warnings, and fatals also printed to stderr
	-v errors, warnings, fatals, and info also printed to stderr
	-q Only errors and fatals are also printed to stderr
	asm/disam log files are only suppressed via the log-suppression options
	Other logs which may be created underneath are files only (no stdout
		or stderr), and may be suppressed via the log-suppression options

wwsim
	Default: errors, warnings, fatals, and info all go to wwsim log
			 errors, warnings, and fatals  also printed to stderr
			 Output from .print and exec(wwlog) goes to wwsim log and stderr
	-v
	-q Only errors and fatals go to stderr
	Other logs which may be created underneath are files only (no stdout
		or stderr), and may be suppressed via the log-suppression options

StdArgs:

--Verbose -v ? Only makes sense if default is to print Info
	Propose: Default is to show info, -q turns it off.

	Should verbose be available as a flag for any general printing? 

--Quiet -q Suppresses Info severity

--LogDir  Directory into which to store logs. Default is current wd.

--NoStdErr Normally warnings, errors, and fatals are written to stderr
		   in addition to being logged. With this option only the log
		   is written.



Log Names, <base>.<logname>.log, e.g., bounce.wwsim.log:
	wwasm
	disasm
	radar
	wwexec
	gen
	wwio





wwsim  [-flowgraph]
wwasm
wwdisasm
	wwutd
	wwdiff






python wwasm.py xxx.py
python wwsim.py -x -y xxx.acore -z -t
python wwtester --filter xxx.wwsim.log "ww_draw_point" xxx.wwsim.filtered.log
python wwtester --verify xxx.wwsim.filtered.log Code-Samples/xxx/xxx.wwsim.filtered.reference.log




reference.log
     At top is the filter used to create and test against it
	 XML or JSON or some crap?
		reference.log.json

test.info.json
	Whole script, basically
	Perhaps some way to generate, but at first can just hand-edit

self-contained in code-samples dir


Or python?

./Py/Assembler/wwasm.py:    parser.add_argument("inputfile", help="file name of ww asm source file")
./Py/Assembler/wwasm.py:    parser.add_argument("--Verbose", '-v',  help="print progress messages", action="store_true")
./Py/Assembler/wwasm.py:    parser.add_argument("--Debug", '-d', help="Print lotsa debug info", action="store_true")
./Py/Assembler/wwasm.py:    parser.add_argument("--Legacy_Numbers", help="guy-legacy - Assume numeric strings are Octal", action="store_true")
./Py/Assembler/wwasm.py:    parser.add_argument("-D", "--DecimalAddresses", help="Display traec information in decimal (default is octal)",
./Py/Assembler/wwasm.py:    parser.add_argument("--ISA_1950", help="Use the 1950 version of the instruction set",
./Py/Assembler/wwasm.py:    parser.add_argument('--outputfilebase', '-o', type=str, help='base name for output file')

./Py/Disassembler/wwdisasm.py:    parser.add_argument("inputfile", help="file name of ww input core file")
./Py/Disassembler/wwdisasm.py:    parser.add_argument('--outputfile', '-o', type=str, help="output file name ('-'=stdout)")
./Py/Disassembler/wwdisasm.py:    parser.add_argument('--use_default_tsr', '-u',
./Py/Disassembler/wwdisasm.py:    parser.add_argument("--DefZeroOne", '-z', help="Define core[0,1] as 0 and 1", action="store_true")
./Py/Disassembler/wwdisasm.py:    parser.add_argument("--Debug", '-d', help="Print lotsa debug info", action="store_true")

./Py/Sim/wwsim.py:    parser.add_argument("corefile", help="file name of simulation core file")
./Py/Sim/wwsim.py:    parser.add_argument("-t", "--TracePC", help="Trace PC for each instruction", action="store_true")
./Py/Sim/wwsim.py:    parser.add_argument("-a", "--TraceALU", help="Trace ALU for each instruction", action="store_true")
./Py/Sim/wwsim.py:    parser.add_argument("-f", "--FlowGraph", help="Collect data to make a flow graph. Default output file <corefile-base-name>.flow.gv", action="store_true")
./Py/Sim/wwsim.py:    parser.add_argument("-fo", "--FlowGraphOutFile", help="Specify flow graph output file. Implies -f", type=str)
./Py/Sim/wwsim.py:    parser.add_argument("-j", "--JumpTo", type=str, help="Sim Start Address in octal")
./Py/Sim/wwsim.py:    parser.add_argument("-q", "--Quiet" , help="Suppress run-time message", action="store_true")
./Py/Sim/wwsim.py:    parser.add_argument("-D", "--DecimalAddresses", help="Display trace information in decimal (default is octal)",
./Py/Sim/wwsim.py:    parser.add_argument("-c", "--CycleLimit", help="Specify how many instructions to run (zero->'forever')", type=int)
./Py/Sim/wwsim.py:    parser.add_argument("--CycleDelayTime", help="Specify how many msec delay to insert after each instruction", type=int)
./Py/Sim/wwsim.py:    parser.add_argument("-r", "--Radar", help="Incorporate Radar Data Source", action="store_true")
./Py/Sim/wwsim.py:    parser.add_argument("--AutoClick", help="Execute pre-programmed mouse clicks during simulation", action="store_true")
./Py/Sim/wwsim.py:    parser.add_argument("--AnalogScope", help="Display graphical output on an analog CRT", action="store_true")
./Py/Sim/wwsim.py:    parser.add_argument("--NoXWin", help="Don't open any x-windows", action="store_true")
./Py/Sim/wwsim.py:    parser.add_argument("--NoToggleSwitchWarning", help="Suppress warning if WW code writes a read-only toggle switch",
./Py/Sim/wwsim.py:    parser.add_argument("--LongTraceFormat", help="print all the cpu registers in TracePC",
./Py/Sim/wwsim.py:    parser.add_argument("--TraceCoreLocation", help="Trace references to Core Memory Location <n> octal", type=str)
./Py/Sim/wwsim.py:    parser.add_argument("--PETRAfile", type=str,
./Py/Sim/wwsim.py:    parser.add_argument("--PETRBfile", type=str,
./Py/Sim/wwsim.py:    parser.add_argument("--NoAlarmStop", help="Don't stop on alarms", action="store_true")
./Py/Sim/wwsim.py:    parser.add_argument("-n", "--NoCloseOnStop", help="Don't close the display on halt", action="store_true")
./Py/Sim/wwsim.py:    parser.add_argument("--NoZeroOneTSR",
./Py/Sim/wwsim.py:    parser.add_argument("--SynchronousVideo",
./Py/Sim/wwsim.py:    parser.add_argument("--CrtFadeDelay",
./Py/Sim/wwsim.py:    parser.add_argument("--DumpCoreToFile",
./Py/Sim/wwsim.py:    parser.add_argument("--RestoreCoreFromFile",
./Py/Sim/wwsim.py:    parser.add_argument("--DrumStateFile",
./Py/Sim/wwsim.py:    parser.add_argument("--MuseumMode",
./Py/Sim/wwsim.py:    parser.add_argument("--MidnightRestart",
./Py/Sim/wwsim.py:    parser.add_argument("--LogDir",
./Py/Sim/wwsim.py:    parser.add_argument("--NoStdErr",

./Py/Sim/wwtester.py:    parser.add_argument ("testBaseName", help="base name of test")
./Py/Sim/wwtester.py:    parser.add_argument ("--srcDir", help="Dir of source ww code, reference logs, etc.", type=str)
./Py/Sim/wwtester.py:    parser.add_argument ("--dstDir", help="Dir where to deposit logs and other files from the test run.", type=str)

./Py/Tape-Decode/wwutd.py:    parser.add_argument("tape_file", help="file name of tape image in .tap or .7ch format")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("--Ch7Format", help="interpret the file as .7ch paper tape", action="store_true")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("--TapFormat", help="interpret the file as .tap magnetic tape", action="store_true")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-F", "--FlexoForce", help="treat the file as Flex Characters", action="store_true")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-o", "--OutputFile", type=str, help="Base name for output core file(s)")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-q", "--Quiet", help="Suppress run-time message", action="store_true")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-T", "--DebugTAP", help="TAP record debug info", action="store_true")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-5", "--Debug556", help="WW 556 block debug info", action="store_true")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-7", "--Debug7ch", help="WW paper tape code debug info", action="store_true")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-C", "--DebugCore", help="WW corefile debug info", action="store_true")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-X", "--DebugXsum", help="556 checksum debug", action="store_true")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-d", "--DumpOctalBlocks", help="Dump out unknown octal tape blocks", action="store_true")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("--No556Header", help="Don't decode the 556 state machine; just assemble 556 words from bytes",
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-P", "--NoReadPastEOF", help="Stop reading at mag-tape double-tape-mark", action="store_true")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-B", "--BlockErrorStop", help="Stop reading at TAP Block Error", action="store_true")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-g", "--GlobalHistogram", help="Compute a baseline opcode histogram across all files",
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-m", "--MinFileSize", type=int, help="Ignore objects smaller than MinFileSize words")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-a", "--ASCIIonly", help="Suppress unprintable characters in FC conversion",

./Py/Tools/wwdiff.py:    parser.add_argument("diff_file_a", help="first .core file")
./Py/Tools/wwdiff.py:    parser.add_argument("diff_file_b", help="second .core file")
./Py/Tools/wwdiff.py:    parser.add_argument("-q", "--Quiet", help="Suppress run-time message", action="store_true")
./Py/Tools/wwdiff.py:    parser.add_argument("-5", "--Debug556", help="WW 556 block debug info", action="store_true")


--Quiet

--Debug
--Verbose


--LogDir
--NoStdErr

--OutputFile
--InputFile


logFilters = [LogFilter ("wwsim", "Warning|Error"),
              LogFilter ("wwasm", "Error:")]


LogMsgType = Enum ("LogMsgType", ["Log", "Debug", "Debug7ch", "Debug556",
                                  "DebugLoader", "DebugTap"])

LogMsgSeverity = Enum ("LogMsgType", ["Error", "Info", "Warning", "Fatal"])



- TesInfo.yaml => TestSpec.yaml
- Tokenizer tighten for testspec args
- Clear or rm dest log files before run -- caution!









whirlwind/
	Code-Samples/
	LICENSE/
	MacOS-Binary/
	Py/
	README.md/
	Win-Binary/
	Tests/
		Bounce/
			TestSpec.yaml
			bounce.ww
			TestRefs/
			TestResults/
		Arith/
			TestSpec.yaml
			arith-test.ww
			TestRefs/
			TestResults/

Options:
	Don't remove results dir; explicitly delete each result file
		Issue: can be hard to know what all the files are
	Rename results dir x.old after deleting whole dir x.old, then create new results dir
		Can check that contents of x.old looks "whirlwindy," ie contains ww-ish files. If not, ask for confirmation

			
os.rename (src, dst) -- rename file or dir

Syntax: os.remove(path, *, dir_fd = None) 
Parameter: path: A path-like object representing a file path. A path-like object is either a string or bytes object representing a path. 
dir_fd (optional): A file descriptor referring to a directory. The default value of this parameter is None. If the specified path is absolute then dir_fd is ignored.

Syntax: os.rmdir(path, *, dir_fd = None) 
Parameter: 
path: A path-like object representing a file path. A path-like object is either a string or bytes object representing a path. 
dir_fd (optional): A file descriptor referring to a directory. The default value of this parameter is None. If the specified path is absolute then dir_fd is ignored. 


Nov 2024 Alternative ideas

Here is the status of some of the things we went over the other day. 

Tokenizer
=========

The syntax errors in format strings now cause fatal errors, as we discussed.

Logging
=======

Yes, I see issues with the logging, and in particular it seems correct
that .print should just print verbatim on stdout, like python print.

Also, the test philosophy should be less intrusive. I see I've been
trying to impose too many changes on the system proper. There are log
design issues such as using python print for tracing rather than
logging to a file. However the test system should ideally impose few
constraints on the program to be tested and should try to capture
existing output. So that's where I'd like to head with the test
system. Right now it doesn't capture stdout or stderr, but I'll add
that capability. We can then scan this output with the test filters.

To the test system, stdout and stderr thus become "logs" themselves.

The logging system we have now is pretty flexible and allows the
creation of various kinds of special-purpose logs. For instance you
might want a trace log or other analysis log. But this means the calls
to "print" would have to be changed. But it does not seem productive
to try to change so many things at once, and a test system should test
a system as-is if possible.

But I believe where we go off course a bit is in trying to have logs
to files that also do "console" output, i.e., to stdout or stderr.
The console output should be primary; it's the semantics of that
output that needs handling, such as error, warning, etc. And capture
of that for testing should be done external to the program.

So I propose:

1. Eliminate the current logs created per-program. Instead the main
   program "logs" will just be stdout and stderr. We'll use the same
   log calls to get there, so we get "warning", "error", etc. But
   these will no longer go to a file. We'll capture them to a file in
   the test system, but that's external to the program.

   BTW right now log calls for Error, Warning, or Fatal get printed to
   stderr. Log calls for Info get printed on stdout. This would remain
   so in the new proposal.

2. The logging system (via LogFactory) can be used to create
   special-purpose logs that go to particular files, e.g., one or more
   trace logs. These would just be to files, and for whatever purpose
   is deemed necessary. It's just another way to get an output file,
   and there is capability for bells and whistles if desired, such as
   a seqno on each message.

3. .print should just print unadorned output to the console

4. In the last round I added the fcn wwlog so that it may be called
   from ww via .exec, e.g. .exec wwlog ("message..."). This causes an
   Info-tagged message to be logged. I changed a set of .ww programs
   to call wwlog instead of print. This can remain but in the new
   proposal but it won't go to a file, and I won't push to change the
   code.

Procedure Call and Recursion
============================

I did a little hacking with ww after our talk about recursion. 

The attached program proc-call.ww shows a main prog and a routine
called "subr", which calls itself after decrementing a global
"level". It returns when level hits zero. The print below shows a run
with level initially set to 5. Running it without -q will show some
more detail.

The stack is 10 words, and grows upward. I didn't know how to denote a
block of words, hence stack0, stack1, etc. The push does a
pre-increment, so I start the stack pointer stackp one below
stack0. For a "real" stack we probably want to grow downwards. Anyway
it's odd there is an add-one (ao) to a loc but not sub-one.

You can see there are procedure entry and exit blocks marked in the
code, and in between code for the proc body. In this case some items
are printed and the level var is decremented and tested.

If we do any kind of compilation we'll need a procedure protocol like
this, plus additional protocol for arg passing. The overhead is fairly
high. Although what I have can probably be optimized a bit more, it
does not look possible to make it much more compact.

But anyway it's the basis of recursion and if some arg-passing format
is devised can be used to do say recursive mini-max.

Here is a dump of a run:

$ 
$ python c:/Users/lstabile/whirlwind/InstructionSimulator/Py/Assembler/wwasm.py proc-call.ww -o proc-call
c:\Users\lstabile\whirlwind\InstructionSimulator\Py\Assembler\wwasm.py:105: DeprecationWarning: Bitwise inversion '~' on bool is deprecated. This returns the bitwise inversion of the underlying int object and is usually not what you expect from negating a bool. Use the 'not' operator for boolean negation or ~int(x) if you really want the bitwise inversion of the underlying int.
  in_quotes = ~in_quotes
Listing output to file proc-call.lst
Corefile output to file proc-call.acore
$ python c:/Users/lstabile/whirlwind/InstructionSimulator/Py/Sim/wwsim.py -q proc-call.acore 
start at 0o100
***1 0o202 0o101 0o0 0o101 0o5
***1 0o203 0o101 0o115 0o115 0o4
***1 0o204 0o101 0o115 0o115 0o3
***1 0o205 0o101 0o115 0o115 0o2
***1 0o206 0o101 0o115 0o115 0o1
***2
Halt Instruction!  (Code=0) at pc=0101
Alarm 'Program Halt' (5) at PC=0o101 (0d65)
Ran 100 cycles; Used mem=48MB
$ 




Assembler grammar
-----------------

The tokenizer and parser in wwasmparser.py follow this grammar fairly well, but there are probably a few spots where it doesn't line up. The code version wins unless it's shown to be some kind of error. Something not captured well here is some special casing needed for .exec.

Note that the grammar tries to capture the nuances of nunmber denotation, but in the code we use dot (".") as an operator and distinguish the number types in eval. This frees us from having to add lexical knowledge of those number forms.

Informal grammar of single line, showing what's optional:
<line> = [@ <oct> [. <dec>] : <oct> <sp>] [<label> : <sp>] [<op> <sp> <operand>[, ..., <operand>] [<sp>]] [<comment>] [<auto-comment>]

More formal version, with optionality omitted:
<line> = <prefix-addr> <sep> <label> <sep> <instruction> <sep> <comment> <auto-comment>

Clauses for the the components:

<prefix-addr> = <oct> . <dec> : <oct>
<label>       = <identifier> :
<instruction> = <op> <whitespace>+ <expr>
<op>          = <ww-op>|<pseudo-op>
<ww-op>       = ta|ao|...
<pseudo-op>   = .word|.org|...
<operand>     = <comma-expr>
<expr>        = <comma-expr>
<oct>         = <digit-seq>		Digits 0-7 allowed
<dec>         = <digit-seq>		Digits 0-9 alowed
<number>      = <oct-num> | <dec-num>
<oct-num>     = 0o<oct> | {0|1}.{0-7}^5
<dec-num>     = {+|-}{0|1}.<dec> | <dec>

Tokens (lexical level):

<sep>                        = <separator> = <whitespace>+ | <operator>
<operator>                   = + | - | * | / | @ |  @@ | : | . | ; | , | 0o
<identifier>                 = <extended-alpha-char><extended-alphanumeric-char>*
<digit-seq>                  = {0-9}+
<comment>                    = ; <any-char-but-not-@@>>*
<auto-comment>               = @@  <any-char>*
<extended-alpha-char>        = <alpha> | _
<extended-alphanumeric-char> = <extended-alpha-char> | <numeric-char>
<string>                     = " <any-char>* "

Expressions:

<comma-expr>          = <additive-expr> | <additive-expr> , <comma-expr>
<additive-expr>       = <multiplicative-expr> | <multiplicative-expr> {+ | -}  <additive-expr>
<multiplicative-expr> = <bit-or-expr>  | <bit-or-expr> {* | /}  <multiplicative-expr>
<bit-or-expr>         = <bit-and-expr> | <bit-and-expr> '|' <bit-or-expr>
<bit-and-expr>        = <dotted-expr> | <dotted-expr> & <bit-and-expr>
<dotted-expr>         = <unary-expr> |  <unary-expr> . <dotted-expr>
<unary-expr>          = <atomic-expr> | {+ | - | 0o} <unary-expr>
<atomic-expr>         =  <identifier> | <digit-seq>  |  <string> | ( <expr> )


A (hacked) piece of a C yacc grammar used as a guide for
expressions. Highest-level entry point is additive_expression.  Based
on https://www.lysator.liu.se/c/ANSI-C-grammar-y.html

primary_expression
	: <identifier>
	| <digit-seq>
	| <string>
	| '(' primary_expression ')'
	;

unary_expression
	: primary_expression
	| unary_operator unary_expression
	;

unary_operator
	: '+'
	| '-'
	| '0o'
	;

dotted_expression
	: unary_expression
	| dotted_expression '.' unary_expression
	;

multiplicative_expression
	: dotted_expression
	| multiplicative_expression '*' dotted_expression
	;

additive_expression
	: multiplicative_expression
	| additive_expression '+' multiplicative_expression
	| additive_expression '-' multiplicative_expression
	;

Note +0.11111 not the same as 0.11111, e.g.:

+0.11111 + -0.234 + 0o123

0.11111 + +0.123 + 0o123

Based on a comment in wwasm.py, we'll have identifiers case-sensitive

Identifiers will be used generally as variables bound to addresses,
but literal values are ok too if the asm adopts syntax to deal with
them.

# sample line:
# @0061.49:140001     w0061: mr   0001      ; multiply and roundoff @@WrittenBy a0045 a0101 ReadBy a0101



Eval
====

Arith binary ops:

binarydot (unary-{+,-}, (literal-{0,1}), literal-digit-seq)		Decimal fraction
binarydot (literal-{0,1}, literal-5-oct-digit-seq)				Octal integer
unary-0o (literal-oct-digit-seq)								Octal integer
literal-digit-seq												Decimal inreger


 0.12345
+0.12345

12/23/24 todo assembler and further
	* auto-comment
	* comment space, alignment -- provide options?
	* write listing
	* Button up file handling
		- Except: Default output for core as stdout?
	- Parens in expr print
			Actually needed! crt-test.ww has (a-b)/3. (was a-b/3 and old asm did not follow std precedence.
	* Related to last comment looks like bug in old asm forming one's-comp negative numbers. See crt-test.acore versus crt-test.n.ncore
	* Quotes in strings
	* .exec doesn't list properly -- strings in this case don't want quotes
	- flexo translation
		Not sure I have it all right
	- "See .dbwgt for more discussion"
	* Assure all wwasm args are handled in some way
		Yes, with some debate ahead
	* Verbosity and Debuggery
		Doesn't seem to be a need for either in new asm right now, but the flags are available in AsmProgram
	* Bail on "too many" errors
		Let everything run, suppress output files on any errors
	x Hacked wwasm.py to accept comma in .dbwgt
		Backed-out; not needed
	* Case-sensitive? Right now new asm is not at all
		We want case-insens ops and case-sens labels and vars
	- Check range on nextcoreaddress since can overflow 2K as in all1.ww. Right now croaks.
	* Mod and test disasm
	* asm: no-prefx-addr option, to get a pretty-printed source file
		Changed to --MinimalListing
	* --Legacy_Numbers: should go away? Rightnow .org has a mix in the
          code; it's clear some .org numbers are meant to be octal,
          even though they have no 0o prefix. Really should conform to
          std rules and the code with unadorned octal should change.

		  Default octal in Mad-Game? Looks like only for non-address
		  operands (e.g., si). All addresses use symbolic
		  labels. Modified mad-game by copying to .n version and using
		  explicit designators for all octal numbers. Got same results
		  as asm.

		  So right now I favor a bit of extra editing versus reading
		  options.

		  [Yes we agreed it should go]

    * annotate io dev: no reason it shouldn't be default, no option, with auto-comment?
		Done, but it broke idempotency! Fixed that.
	* .wwfile really wants quoted strings -- i.e., expect a var
		All Code-Samples modified thus in .n.ww versions
	- Can probably be more elegant in AsmLabelTab by subclassing dict.
	* Why does core file have 7-oct width?
		Guy thinks because he first wanted to encode the memory bank.
	- Note crt-test has runtest.n.sh, but the drawing output has not
		  been validated against fixes Guy will be supplying.
	* I'l take on a task of updating the asm manual.
		Should be good for now
	- Get rid of yaml files
	* Assure all TestResults* dirs out of git -- ok git in web diff says deleted?
	- Do we need to handle anything special for "overflow" numbers?
      E.g., +1.001. Is there a need to handle this in some way in the
      asm lang?
	- .isa needs prescan? Doc 2.8.3
	- "Preset Params are meant (I think) for doing address assignments
      and calculations, so the values associated with a PP are
      restricted to 0-2047."  This is in asm doc; I currently don't have this restriction.
	- --Logdir -- still active?
	* Clarify C std vis-a-via octal and other number syntax.
		Python does 0o, but C does not
	* Issues with inheritance and *args? See listingString()
		Looks ok -- needed to learn more about *args vs **kwargs
	- Two .print insts in a row cause a comma-expected syntax bug (in sim)
	- Unterminated string seems to crash asm tokenizer
	- C-ish
	- How does float dv work? Can't find anything that matches this
	  algorithm. The fixed-point-30 lib does not implement dv.
		Appears to be Taylor series of 1/(a+b), two terms.
	* Shifts in lz
	* Rename new asm to be current; appropriate rename old prog and stuff if desired.
	  		 1/31/25 -- renamed away from .n
	* Range check float input
	- Found a log bug where the stdout logs were continually making
      LogClass instances. Due to not using class var right -- needs
      wrapper, unlike in C++.
	* Tracebranch in sim -- need way to turn off
		Turn on quiet id -d
	* Suppressed undefined-value error -- too noisy.
	* Debugger: added provisions for "real" debugger by adding a
      SymToAddr table to the sim; it already has an addr-to-sym table,
      SymTab. Also moved wwasmparser.py to Common.
	* Debugger investigation shows the .print tokenizer produces a fatal error. Can we change?
		Changed to error
	* Print floats with scientific notation or the eqv of C's "g" format.
		Python has "g".  Now printing 30,15 floats with 10 digits and 24,6 floats with 8 digits
	- Hoist cpu class so we can share with dbg
	- Show .print etc in dbg. Right now just shows ww insts
	- Get rid of need for dummy parsed line in dbg
	- Dbg doesn't handle signals
	- bounce test (and the one in code-samples) has a .org 1. This
	  doesn't seem right. Fixed the test but not the code-sample.
	- Asm syntax errors need work. Need better check for unbal'ed
	  parens, and identifying specific clause types in errors,
	  e.g. xyz* gives comma-op syntax error, which is misleading.
	* Trap float overflow in conversion and return inf.
	- Dbg bug in printing AC and prob other regs -- wrong signs. Trying printing neg number.
	- Dbg bug in rs if do rs before running.
	- Dbg possible enhs: watch-for-write (addr); allow a mem loc to be set
	- Send Knuth info we have for any insights




	- Get "everything" into git: tape images, images on code, etc.
		Did sizing run see below marked 1/1/25
	- LAS: work on L&Z? Maybe just use new translator and asm?
	- LAS: disasm, C-ish compiler, ...? Where are we wrt to "musesum-ness"
		- One goal is historical research and perhaps a paper on the
		  code we've found and resurrected.
		- Another may be museum exhibits -- esp. hardware currently under dev.



1/12/25
Procedure call and other compilation notes
==========================================

- Stack starts at highest addr and grows down

- Args are pushed on the stack

- When entering a proc, a frame is pushed. Original stackp - n is the
  nth arg (one-based). stackp + n (zero-based) is local var.

- Consistency of td vs ta

- Idiom: Establish an instruction like  ca <initial-addr>, then just ao
  to that instruction to bump a table loc.

- Did rel-addr lib, stack-frame-rel-addr-lib.ww. Complicated! Probably
  better is to save all writeable words on stack and restore on exit.

- Could do k = *p++, where p is a ca instruction. 

2/2/25
Finding dv error in float-lib, note to Guy:

I studied the instruction set and other doc more deeply and so far I
conclude that the behavior described where BR is always positive is in
fact correct. When I think about the difficulty of building hardware
at the time it makes some sense to me. One's complement provides a way
to do addition and subtraction on a common representation of both
positive and negative numbers, but mult and div are still harder with
signed arithmetic. Hence for those operations the hardware converts to
mag form and back again. The B reg is the extender for operations that
spill over a word, and does not need to have the complement logic
built in; this may seem trivial now but then it was an expense.  I
recall, but vaguely now, similar issues when I did signal processing
hw in school, in the SSI/MSI TTL days.
 
Anyway at this point I've turned off the flags that cause negation of
BR, so vibrating-string works ok. I haven't looked at the L&Z issues
yet, but rather dove back into the float lib, to see if these
revelations cast any light on the troubles there. In doing tests and
looking at traces and sim code, I have not found any sim errors in sf,
shifts, add, and so forth. I tested dv on normal ww fractions and it
looks ok.
 
So I then dug into tracing the float-lib dv, and made I think a little
headway, but nothing really solid yet. Where it says:
 
                           ;       Form (2**-2/x**2)' (Use Euclid's algorithm)
 
which starts at r41, there seems to be an error in the note, and it
should say (2**-2/x2)', i.e., it's not something squared. There is
also an error in another note, for the code starting at 37, where it
should be just x2 and not x2**2.
 
The Euclid part is due to using dv to get bits which are then used to
get floor and remainder, for the lower bits of the reciprocal. Just
what the exact calc is here I'm still trying to figure out. The "su
17r" at 44 is really suspicious. 17r contains "ca 0", which is
executed but never written, just read for its value, which is
-32767. Issues arise when the low bits in the original floating
divisor are zero.  We do 0 - -32767 = 32767, then add one to that, and
kaboom. This is a common case; the test I used which crashes is
float1/float2. It may be doing some kind of rounding.
 
By playing with this and adding less than 32767, more tests like sqrt2
run.  One problem is that aspects of the code are position-dependent,
in that calc of dispatch addresses and such depend on fixed offsets of
certain words. So one has to be careful inserting code.
 
I'm pretty sure the overall formula for finding the reciprocal follows
the Taylor series for 1/(a + b), which expands via Alpha as:
 
1/(a+b) = 1/a - b/a^2 + b^2/a^3 - b^3/a^4 + ...
 
It uses the first two terms, which accounts for the x-squared, but it
really threw me off that the notes seem incorrect.
 
Anyway I haven't found the problem yet but making progress.
 
 - Larry

----------------------------------------------------------------------
1/1/25
The mounted shared whirlwind google drive:
pwd
/cygdrive/g/.shortcut-targets-by-id/1-7fYz-kOky_lqe_lvHZ0YBBHz-ikIffj/Whirlwind
du -s -k -h *
42M	Catalogues-and-Indices
73M	Code-Samples-Local
311K	Dave-Walden-WW-Report-R221.pdf
258M	GitHub
18M	HNF-Git
93M	Hardware
1.0K	How-to-Make-a-Release.txt
9.5M	Images
219K	JavaSim
232M	Mag-Tapes
70M	Paper-Tapes
2.4M	Papertape-Decitek-Reader-Punch
923K	Partners
1.1G	Photos
277M	Py-Local
1.5G	Scanned-Docs
56M	SimH
9.1G	Static-Document-Files
2.1M	Whirlwind-Python-Guy-Oct01-18.zipx
14K	Whirlwind-Q-tmp-Oct12-17.docx
366M	guy
1.0K	rsync-to-pi.sh
1.0K	rsync-to-pi.sh~

M-2539-2 Comprehensive System manual
====================================

Section														Pdf page
-------														--------

introduction													5

part i. intro to programming and coding							10

chapter i the cs computer -- simplified version					11
chapter ii transfer of control -- counting						19
chapter iii cycle counters -- modification of addresses			27
chapter iv floating addresses									35
chapter v input and output										43
chapter vi errors and post-mortems								60
chapter vii subroutines											65
				preset parameters								74
chapter viii review												79

part ii. advanced coding techniques								90

chapter ix some more fundamentials								91
chapter x number systems										96
chapter x1 the whirlwind [i] computer							107
chapter xii auxiliary storage and in-out equipment				132
chapter xiii programmed arithmetic								148
chapter xiv the conversion program								167
				ditto											194
chapter xv the utility control program							202
chapter xvi automatic input-output requests [output]			224
chapter xvii generalized post-mortems							241


2/6/25
Conditional exec
================

It was not my intent to be dismissive of the conditional-exec ideas,
and separate from the debugger idea we can consider some sort of
conditional printing. I don't support allowing more Python in the asm
language. We could easily do .printif:

	.printif Debug, "X = %d", X

where Debug can be a .pp symbol or somethig set of the cmd line. We
could similarly do .execif:

	.execif Debug, blah()

Doing a general .if is also possible, e.g.:

	.if Debug, .print "X = %d", X
or
	.if Debug, .exec blah()

These latter forms break the current syntax, but not fatally and I
could probably fit them in.

2/26/25
Debugger Doc
============

The debugger is invoked as follows:

python wwsim.py --Debugger x.acore
python wwsim.py -d x.acore

To my surprise, the -d option wasn't taken!

Invoking -d automatically turns on "very quiet" mode, i.e., no info is
printed like branch-forward, branch-backward, etc. I found this output
too noisy when using the debugger.

The help output is:

p   <expr> [, format]   where format = o: octal, d: decimal, fr: fraction, fl: 24,6 float, fm: 30,15 float, i: instruction
        print an address and its contents, or just the value if a register is specfied
pb  <addr>, <nwords> [, format]
        print a block of <nwords> starting at <addr>
r   run program from current pc
s   step program one instruction
rs  restart program
b   <addr>1,...,<addr>N
        define a breakpoint for each given address. Prints breakpoint id and corresponding address
bd  <bkptid>1,...,<bkptid>N
        delete breakpoint defined by each given id
bl  list breakpoints
h   Print help
quit    Exit debugger and simulator

The help output should be largely self-explanatory. Following is a
transcript of a debugging run. I added the line numbers in this
write-up, with some notes following.b

 1   $ python $sim -d las-float-lib.acore
 2   start at 0o40
 3    pc:0o0040:          SP 0o0041(notes)         AC=0o000000,           BR=0o0,    Core@0o0041(notes)=0o075524
 4   dbg 40> b ax
 5   0 0o1524(ax)
 6   dbg 40> b loop
 7   1 0o45(loop)
 8   dbg 40> bl
 9   0 0o1524(ax)
10   1 0o45(loop)
11   dbg 40> r
12    pc:0o1524(ax):      TA 0o2007(exec_inst)     AC=0o000000,           BR=0o0,    Core@0o2007(exec_inst)=0o100000(-0o77777)
13    dbg 1524> r
14    pc:0o0045(loop):    CA 0o0141(loopcnt)       AC=0o000001,           BR=0o0,    Core@0o0141(loopcnt)=0o000031
15   dbg 45> p mra,fm
16   0o1526(mra) = 220
17   dbg 45> r
18    pc:0o1524(ax):      TA 0o2007(exec_inst)     AC=0o000030,           BR=0o0,    Core@0o2007(exec_inst)=0o101524(-0o76253)
19   dbg 1524> r
20   xxxxxxxxxxxx 24 233.08189
21    pc:0o0045(loop):    CA 0o0141(loopcnt)       AC=0o000001,           BR=0o0,    Core@0o0141(loopcnt)=0o000030
22   dbg 45> p mra,fm
23   0o1526(mra) = 233.0818939
24   dbg 45> p t,fl
25   0o123(t) = 233.08189
26   dbg 45> pb mra,3
27   0o1526(mra):
28     0o1526 = 0o72212
29     0o1527 = 0o36700
30     0o1530 = 0o10
31   dbg 45> pb mra,3,d
32   0d854(mra):
33     0d854 = 29834
34     0d855 = 15808
35     0d856 = 8
36   dbg 45> r
37    pc:0o1524(ax):      TA 0o2007(exec_inst)     AC=0o000027,           BR=0o0,    Core@0o2007(exec_inst)=0o101524(-0o76253)
38   dbg 1524> p AR
39   AR = 52
40   dbg 1524> pb AR,4,i
41   0o52(AR):
42     0o52 = CA 0o123(t)
43     0o53 = MR 0o137(semitone)
44     0o54 = TS 0o123(t)
45     0o55 = SP 0o1524(ax)
46   dbg 1524> r
47   xxxxxxxxxxxx 23 246.94168
48    pc:0o0045(loop):    CA 0o0141(loopcnt)       AC=0o000001,           BR=0o0,    Core@0o0141(loopcnt)=0o000027
49   dbg 45> bl
50   0 0o1524(ax)
51   1 0o45(loop)
52   dbg 45> bd 0,1
53   dbg 45> r
54   xxxxxxxxxxxx 22 261.62561
55   xxxxxxxxxxxx 21 277.18268
56   xxxxxxxxxxxx 20 293.66483
57   xxxxxxxxxxxx 19 311.12704
58   xxxxxxxxxxxx 18 329.62762
59   xxxxxxxxxxxx 17 349.22833
60   xxxxxxxxxxxx 16 369.99454
61   xxxxxxxxxxxx 15 391.99557
62   xxxxxxxxxxxx 14 415.30487
63   xxxxxxxxxxxx 13 440.00021
64   xxxxxxxxxxxx 12 466.164
65   xxxxxxxxxxxx 11 493.88358
66   xxxxxxxxxxxx 10 523.25146
67   xxxxxxxxxxxx 9 554.36566
68   xxxxxxxxxxxx 8 587.32996
69   xxxxxxxxxxxx 7 622.25446
70   xxxxxxxxxxxx 6 659.25568
71   xxxxxxxxxxxx 5 698.45709
72   xxxxxxxxxxxx 4 739.98956
73   xxxxxxxxxxxx 3 783.99164
74   xxxxxxxxxxxx 2 830.61023
75   xxxxxxxxxxxx 1 880.00092
76   Halt Instruction!  (Code=0) at pc=0114
77   Alarm 'Program Halt' (5) at PC=0o114 (0d76)
78   Total cycles = 4252, last PC=0o115, wall_clock_time=121 sec, avg time per cycle = 28614.4 usec
79   
80   Ran 4252 cycles; Used mem=47MB
81   start at 0o40
82    pc:0o0040:          SP 0o0041(notes)         AC=0o000000,           BR=0o0,    Core@0o0041(notes)=0o075524
83   dbg 40> quit
84   $


Notes on the transcript:

Line 12: First breakpoint hit, at ax. The instruction line is shown
	before execution. The registers and memory values shown are the
	current values at that point. Note that .print and .exec are not
	shown, and are not executed until the next step or run. Changing
	this is a possible enhancement, i.e., making .exec and .print
	appear as "real" instructions to the debugger.

Line 22: Print the mra as a 30,15 float.

Line 26: Print the mra as an octal block of 3 words.

Line 31: Same only decimal.

Line 38: Registers can be printed via their built-in names AC, AR, BR,
	and SAM (lower case also allowed). I don't yet account for name
	conflicts.

Line 40: Print a block as instructions. Useful to see what code has
	been modified. In this case we're seeing the "virtual
	instructions" to be picked up by the float lib.

Line 49: List the breakpoints. The next command then deletes them, then
	we run the program to completion.

Issues/Notes:

- rs doesn't actually restart, just goes to the beginning, and you
  then have to type r. There may be other issues with it
  too. Generally, I tried to be minimally invasive in the sim's
  control loop, and there might be a few cracks.

- Printing registers has bugs, like negative numbers are wrong when
  printed in decimal.

- .print and .exec will not appear, nor are they executed, at a
  breakpoint. You need to step or run from there to get that
  executed. This is something we can potentially fix, i.e., these would
  be treated as executable statements by the debugger.

- I could potentially combine p and pb into one command, by checking
  the fields and ascertaining whether they're numbers or format
  strings.

- In the sim code, I added a few "helper functions" to pass to the
  debugger, to get info from the sim. We should abstract out at least
  the Cpu class so I don't need all those functions, so that is on the
  to-do list. Note though that these additional functions don't
  interfere with the sim, so I still consider the changes I needed to
  be mininal. But at least python implements closures, so these
  functions work!

- From an implementation standpoint, this is a separate module, with
  an interface class for the sim to initiate control. We are thus be
  able to avoid lots of symbol contamination in the sim itself.
