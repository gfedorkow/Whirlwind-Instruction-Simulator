


This is a collection of notes and scratchings on Larry's efforts in
the Whirlwind project. It started as a doc dump for the tester, but
has expanded into assembler and other areas.
----------------------------------------------------------------------

Testing system
==============

LAS 1/1/25: Note this now represents the latest attempt at testing,
which largely discards the first idea, using yaml, etc. So those notes
are gone and are available via a previous git version. Some of the
rationale for the change is below in a note to Guy dated Nov 2024.

The main thing new is that we're script-based, and use basic scripting
to run tests and do diffs. It's based on boiler-plate scripting which
is copied and modified to make a new test. The convenience and
flexibility of such script development outweighs the "badness" of the
redundancy, and if needed we can develop mass-editing tools to help us
if an across-the-board change is needed.

We also get free of having to provide tests only in a special "test"
area. Though we'll have one of those, tests can be anywhere in the dev
tree.

Tests are denoted by the existence of a script in a dir called
runtest.sh. This conains the info needed to run the test, filter and
compare files, announce passage or failure, and accept a test once
blessed.

To serve as a test, we need test references, so another assumption is
the existence of a TestRefs dir, probably, but not required to be,
co-resident in the dir with runtest.sh, and by convention called
TestRefs, but not required.

Each runtest.sh must have a --Accept option, which copies a set of log
or output files to the test refs area.

Each runtest.sh also has a standard cd to its own location (i.e., the
dir of arg $0), to allow it to be run more easily from an external
program. In particular, to run all tests,

   cd <whirlwind-simulator-top-level-dir>
   find . -name runtest.sh -print -exec {} \;

While I have considered making the wwtester.py code be a more
comprehensive test tool, as I did at first, I don't see the need, and
I'll archive this program in some way. Some of the techniques for
subprocess management and other items may be useful for something. But
overall my goal is to use scripts as much as possible for driving the
tests.

----------------------------------------------------------------------






Log formatting and conventions
	Seqno across all logs
	info, warning, error (etc?)
	Option (default?) for warning and error to go to stderr too.
		For asm, disasm, should be default, -q suppresses
		For sim, quiet would be default, and verbose brings out warning and error

!!! In wwsim.py:
# There can be a source file that contains subroutines that might be called by exec statements specific
#   to the particular project under simulation.  If the file exists in the current working dir, import it.
if os.path.exists("project_exec.py"):
    sys.path.append('.')
    from project_exec import *
    print("imported project_exec.py")

  Must be in wd!






wwasm
disasm
	Default: errors, warnings, fatals, and info all go to asm/disasm log
			 errors, warnings, and fatals also printed to stderr
	-v errors, warnings, fatals, and info also printed to stderr
	-q Only errors and fatals are also printed to stderr
	asm/disam log files are only suppressed via the log-suppression options
	Other logs which may be created underneath are files only (no stdout
		or stderr), and may be suppressed via the log-suppression options

wwsim
	Default: errors, warnings, fatals, and info all go to wwsim log
			 errors, warnings, and fatals  also printed to stderr
			 Output from .print and exec(wwlog) goes to wwsim log and stderr
	-v
	-q Only errors and fatals go to stderr
	Other logs which may be created underneath are files only (no stdout
		or stderr), and may be suppressed via the log-suppression options

StdArgs:

--Verbose -v ? Only makes sense if default is to print Info
	Propose: Default is to show info, -q turns it off.

	Should verbose be available as a flag for any general printing? 

--Quiet -q Suppresses Info severity

--LogDir  Directory into which to store logs. Default is current wd.

--NoStdErr Normally warnings, errors, and fatals are written to stderr
		   in addition to being logged. With this option only the log
		   is written.



Log Names, <base>.<logname>.log, e.g., bounce.wwsim.log:
	wwasm
	disasm
	radar
	wwexec
	gen
	wwio





wwsim  [-flowgraph]
wwasm
wwdisasm
	wwutd
	wwdiff






python wwasm.py xxx.py
python wwsim.py -x -y xxx.acore -z -t
python wwtester --filter xxx.wwsim.log "ww_draw_point" xxx.wwsim.filtered.log
python wwtester --verify xxx.wwsim.filtered.log Code-Samples/xxx/xxx.wwsim.filtered.reference.log




reference.log
     At top is the filter used to create and test against it
	 XML or JSON or some crap?
		reference.log.json

test.info.json
	Whole script, basically
	Perhaps some way to generate, but at first can just hand-edit

self-contained in code-samples dir


Or python?

./Py/Assembler/wwasm.py:    parser.add_argument("inputfile", help="file name of ww asm source file")
./Py/Assembler/wwasm.py:    parser.add_argument("--Verbose", '-v',  help="print progress messages", action="store_true")
./Py/Assembler/wwasm.py:    parser.add_argument("--Debug", '-d', help="Print lotsa debug info", action="store_true")
./Py/Assembler/wwasm.py:    parser.add_argument("--Legacy_Numbers", help="guy-legacy - Assume numeric strings are Octal", action="store_true")
./Py/Assembler/wwasm.py:    parser.add_argument("-D", "--DecimalAddresses", help="Display traec information in decimal (default is octal)",
./Py/Assembler/wwasm.py:    parser.add_argument("--ISA_1950", help="Use the 1950 version of the instruction set",
./Py/Assembler/wwasm.py:    parser.add_argument('--outputfilebase', '-o', type=str, help='base name for output file')

./Py/Disassembler/wwdisasm.py:    parser.add_argument("inputfile", help="file name of ww input core file")
./Py/Disassembler/wwdisasm.py:    parser.add_argument('--outputfile', '-o', type=str, help="output file name ('-'=stdout)")
./Py/Disassembler/wwdisasm.py:    parser.add_argument('--use_default_tsr', '-u',
./Py/Disassembler/wwdisasm.py:    parser.add_argument("--DefZeroOne", '-z', help="Define core[0,1] as 0 and 1", action="store_true")
./Py/Disassembler/wwdisasm.py:    parser.add_argument("--Debug", '-d', help="Print lotsa debug info", action="store_true")

./Py/Sim/wwsim.py:    parser.add_argument("corefile", help="file name of simulation core file")
./Py/Sim/wwsim.py:    parser.add_argument("-t", "--TracePC", help="Trace PC for each instruction", action="store_true")
./Py/Sim/wwsim.py:    parser.add_argument("-a", "--TraceALU", help="Trace ALU for each instruction", action="store_true")
./Py/Sim/wwsim.py:    parser.add_argument("-f", "--FlowGraph", help="Collect data to make a flow graph. Default output file <corefile-base-name>.flow.gv", action="store_true")
./Py/Sim/wwsim.py:    parser.add_argument("-fo", "--FlowGraphOutFile", help="Specify flow graph output file. Implies -f", type=str)
./Py/Sim/wwsim.py:    parser.add_argument("-j", "--JumpTo", type=str, help="Sim Start Address in octal")
./Py/Sim/wwsim.py:    parser.add_argument("-q", "--Quiet" , help="Suppress run-time message", action="store_true")
./Py/Sim/wwsim.py:    parser.add_argument("-D", "--DecimalAddresses", help="Display trace information in decimal (default is octal)",
./Py/Sim/wwsim.py:    parser.add_argument("-c", "--CycleLimit", help="Specify how many instructions to run (zero->'forever')", type=int)
./Py/Sim/wwsim.py:    parser.add_argument("--CycleDelayTime", help="Specify how many msec delay to insert after each instruction", type=int)
./Py/Sim/wwsim.py:    parser.add_argument("-r", "--Radar", help="Incorporate Radar Data Source", action="store_true")
./Py/Sim/wwsim.py:    parser.add_argument("--AutoClick", help="Execute pre-programmed mouse clicks during simulation", action="store_true")
./Py/Sim/wwsim.py:    parser.add_argument("--AnalogScope", help="Display graphical output on an analog CRT", action="store_true")
./Py/Sim/wwsim.py:    parser.add_argument("--NoXWin", help="Don't open any x-windows", action="store_true")
./Py/Sim/wwsim.py:    parser.add_argument("--NoToggleSwitchWarning", help="Suppress warning if WW code writes a read-only toggle switch",
./Py/Sim/wwsim.py:    parser.add_argument("--LongTraceFormat", help="print all the cpu registers in TracePC",
./Py/Sim/wwsim.py:    parser.add_argument("--TraceCoreLocation", help="Trace references to Core Memory Location <n> octal", type=str)
./Py/Sim/wwsim.py:    parser.add_argument("--PETRAfile", type=str,
./Py/Sim/wwsim.py:    parser.add_argument("--PETRBfile", type=str,
./Py/Sim/wwsim.py:    parser.add_argument("--NoAlarmStop", help="Don't stop on alarms", action="store_true")
./Py/Sim/wwsim.py:    parser.add_argument("-n", "--NoCloseOnStop", help="Don't close the display on halt", action="store_true")
./Py/Sim/wwsim.py:    parser.add_argument("--NoZeroOneTSR",
./Py/Sim/wwsim.py:    parser.add_argument("--SynchronousVideo",
./Py/Sim/wwsim.py:    parser.add_argument("--CrtFadeDelay",
./Py/Sim/wwsim.py:    parser.add_argument("--DumpCoreToFile",
./Py/Sim/wwsim.py:    parser.add_argument("--RestoreCoreFromFile",
./Py/Sim/wwsim.py:    parser.add_argument("--DrumStateFile",
./Py/Sim/wwsim.py:    parser.add_argument("--MuseumMode",
./Py/Sim/wwsim.py:    parser.add_argument("--MidnightRestart",
./Py/Sim/wwsim.py:    parser.add_argument("--LogDir",
./Py/Sim/wwsim.py:    parser.add_argument("--NoStdErr",

./Py/Sim/wwtester.py:    parser.add_argument ("testBaseName", help="base name of test")
./Py/Sim/wwtester.py:    parser.add_argument ("--srcDir", help="Dir of source ww code, reference logs, etc.", type=str)
./Py/Sim/wwtester.py:    parser.add_argument ("--dstDir", help="Dir where to deposit logs and other files from the test run.", type=str)

./Py/Tape-Decode/wwutd.py:    parser.add_argument("tape_file", help="file name of tape image in .tap or .7ch format")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("--Ch7Format", help="interpret the file as .7ch paper tape", action="store_true")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("--TapFormat", help="interpret the file as .tap magnetic tape", action="store_true")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-F", "--FlexoForce", help="treat the file as Flex Characters", action="store_true")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-o", "--OutputFile", type=str, help="Base name for output core file(s)")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-q", "--Quiet", help="Suppress run-time message", action="store_true")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-T", "--DebugTAP", help="TAP record debug info", action="store_true")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-5", "--Debug556", help="WW 556 block debug info", action="store_true")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-7", "--Debug7ch", help="WW paper tape code debug info", action="store_true")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-C", "--DebugCore", help="WW corefile debug info", action="store_true")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-X", "--DebugXsum", help="556 checksum debug", action="store_true")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-d", "--DumpOctalBlocks", help="Dump out unknown octal tape blocks", action="store_true")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("--No556Header", help="Don't decode the 556 state machine; just assemble 556 words from bytes",
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-P", "--NoReadPastEOF", help="Stop reading at mag-tape double-tape-mark", action="store_true")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-B", "--BlockErrorStop", help="Stop reading at TAP Block Error", action="store_true")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-g", "--GlobalHistogram", help="Compute a baseline opcode histogram across all files",
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-m", "--MinFileSize", type=int, help="Ignore objects smaller than MinFileSize words")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-a", "--ASCIIonly", help="Suppress unprintable characters in FC conversion",

./Py/Tools/wwdiff.py:    parser.add_argument("diff_file_a", help="first .core file")
./Py/Tools/wwdiff.py:    parser.add_argument("diff_file_b", help="second .core file")
./Py/Tools/wwdiff.py:    parser.add_argument("-q", "--Quiet", help="Suppress run-time message", action="store_true")
./Py/Tools/wwdiff.py:    parser.add_argument("-5", "--Debug556", help="WW 556 block debug info", action="store_true")


--Quiet

--Debug
--Verbose


--LogDir
--NoStdErr

--OutputFile
--InputFile


logFilters = [LogFilter ("wwsim", "Warning|Error"),
              LogFilter ("wwasm", "Error:")]


LogMsgType = Enum ("LogMsgType", ["Log", "Debug", "Debug7ch", "Debug556",
                                  "DebugLoader", "DebugTap"])

LogMsgSeverity = Enum ("LogMsgType", ["Error", "Info", "Warning", "Fatal"])



- TesInfo.yaml => TestSpec.yaml
- Tokenizer tighten for testspec args
- Clear or rm dest log files before run -- caution!









whirlwind/
	Code-Samples/
	LICENSE/
	MacOS-Binary/
	Py/
	README.md/
	Win-Binary/
	Tests/
		Bounce/
			TestSpec.yaml
			bounce.ww
			TestRefs/
			TestResults/
		Arith/
			TestSpec.yaml
			arith-test.ww
			TestRefs/
			TestResults/

Options:
	Don't remove results dir; explicitly delete each result file
		Issue: can be hard to know what all the files are
	Rename results dir x.old after deleting whole dir x.old, then create new results dir
		Can check that contents of x.old looks "whirlwindy," ie contains ww-ish files. If not, ask for confirmation

			
os.rename (src, dst) -- rename file or dir

Syntax: os.remove(path, *, dir_fd = None) 
Parameter: path: A path-like object representing a file path. A path-like object is either a string or bytes object representing a path. 
dir_fd (optional): A file descriptor referring to a directory. The default value of this parameter is None. If the specified path is absolute then dir_fd is ignored.

Syntax: os.rmdir(path, *, dir_fd = None) 
Parameter: 
path: A path-like object representing a file path. A path-like object is either a string or bytes object representing a path. 
dir_fd (optional): A file descriptor referring to a directory. The default value of this parameter is None. If the specified path is absolute then dir_fd is ignored. 


Nov 2024 Alternative ideas

Here is the status of some of the things we went over the other day. 

Tokenizer
=========

The syntax errors in format strings now cause fatal errors, as we discussed.

Logging
=======

Yes, I see issues with the logging, and in particular it seems correct
that .print should just print verbatim on stdout, like python print.

Also, the test philosophy should be less intrusive. I see I've been
trying to impose too many changes on the system proper. There are log
design issues such as using python print for tracing rather than
logging to a file. However the test system should ideally impose few
constraints on the program to be tested and should try to capture
existing output. So that's where I'd like to head with the test
system. Right now it doesn't capture stdout or stderr, but I'll add
that capability. We can then scan this output with the test filters.

To the test system, stdout and stderr thus become "logs" themselves.

The logging system we have now is pretty flexible and allows the
creation of various kinds of special-purpose logs. For instance you
might want a trace log or other analysis log. But this means the calls
to "print" would have to be changed. But it does not seem productive
to try to change so many things at once, and a test system should test
a system as-is if possible.

But I believe where we go off course a bit is in trying to have logs
to files that also do "console" output, i.e., to stdout or stderr.
The console output should be primary; it's the semantics of that
output that needs handling, such as error, warning, etc. And capture
of that for testing should be done external to the program.

So I propose:

1. Eliminate the current logs created per-program. Instead the main
   program "logs" will just be stdout and stderr. We'll use the same
   log calls to get there, so we get "warning", "error", etc. But
   these will no longer go to a file. We'll capture them to a file in
   the test system, but that's external to the program.

   BTW right now log calls for Error, Warning, or Fatal get printed to
   stderr. Log calls for Info get printed on stdout. This would remain
   so in the new proposal.

2. The logging system (via LogFactory) can be used to create
   special-purpose logs that go to particular files, e.g., one or more
   trace logs. These would just be to files, and for whatever purpose
   is deemed necessary. It's just another way to get an output file,
   and there is capability for bells and whistles if desired, such as
   a seqno on each message.

3. .print should just print unadorned output to the console

4. In the last round I added the fcn wwlog so that it may be called
   from ww via .exec, e.g. .exec wwlog ("message..."). This causes an
   Info-tagged message to be logged. I changed a set of .ww programs
   to call wwlog instead of print. This can remain but in the new
   proposal but it won't go to a file, and I won't push to change the
   code.

Procedure Call and Recursion
============================

I did a little hacking with ww after our talk about recursion. 

The attached program proc-call.ww shows a main prog and a routine
called "subr", which calls itself after decrementing a global
"level". It returns when level hits zero. The print below shows a run
with level initially set to 5. Running it without -q will show some
more detail.

The stack is 10 words, and grows upward. I didn't know how to denote a
block of words, hence stack0, stack1, etc. The push does a
pre-increment, so I start the stack pointer stackp one below
stack0. For a "real" stack we probably want to grow downwards. Anyway
it's odd there is an add-one (ao) to a loc but not sub-one.

You can see there are procedure entry and exit blocks marked in the
code, and in between code for the proc body. In this case some items
are printed and the level var is decremented and tested.

If we do any kind of compilation we'll need a procedure protocol like
this, plus additional protocol for arg passing. The overhead is fairly
high. Although what I have can probably be optimized a bit more, it
does not look possible to make it much more compact.

But anyway it's the basis of recursion and if some arg-passing format
is devised can be used to do say recursive mini-max.

Here is a dump of a run:

$ 
$ python c:/Users/lstabile/whirlwind/InstructionSimulator/Py/Assembler/wwasm.py proc-call.ww -o proc-call
c:\Users\lstabile\whirlwind\InstructionSimulator\Py\Assembler\wwasm.py:105: DeprecationWarning: Bitwise inversion '~' on bool is deprecated. This returns the bitwise inversion of the underlying int object and is usually not what you expect from negating a bool. Use the 'not' operator for boolean negation or ~int(x) if you really want the bitwise inversion of the underlying int.
  in_quotes = ~in_quotes
Listing output to file proc-call.lst
Corefile output to file proc-call.acore
$ python c:/Users/lstabile/whirlwind/InstructionSimulator/Py/Sim/wwsim.py -q proc-call.acore 
start at 0o100
***1 0o202 0o101 0o0 0o101 0o5
***1 0o203 0o101 0o115 0o115 0o4
***1 0o204 0o101 0o115 0o115 0o3
***1 0o205 0o101 0o115 0o115 0o2
***1 0o206 0o101 0o115 0o115 0o1
***2
Halt Instruction!  (Code=0) at pc=0101
Alarm 'Program Halt' (5) at PC=0o101 (0d65)
Ran 100 cycles; Used mem=48MB
$ 




Assembler grammar
-----------------

The tokenizer and parser in wwasmparser.py follow this grammar fairly well, but there are probably a few spots where it doesn't line up. The code version wins unless it's shown to be some kind of error. Something not captured well here is some special casing needed for .exec.

Note that the grammar tries to capture the nuances of nunmber denotation, but in the code we use dot (".") as an operator and distinguish the number types in eval. This frees us from having to add lexical knowledge of those number forms.

Informal grammar of single line, showing what's optional:
<line> = [@ <oct> [. <dec>] : <oct> <sp>] [<label> : <sp>] [<op> <sp> <operand>[, ..., <operand>] [<sp>]] [<comment>] [<auto-comment>]

More formal version, with optionality omitted:
<line> = <prefix-addr> <sep> <label> <sep> <instruction> <sep> <comment> <auto-comment>

Clauses for the the components:

<prefix-addr> = <oct> . <dec> : <oct>
<label>       = <identifier> :
<instruction> = <op> <whitespace>+ <expr>
<op>          = <ww-op>|<pseudo-op>
<ww-op>       = ta|ao|...
<pseudo-op>   = .word|.org|...
<operand>     = <comma-expr>
<expr>        = <comma-expr>
<oct>         = <digit-seq>		Digits 0-7 allowed
<dec>         = <digit-seq>		Digits 0-9 alowed
<number>      = <oct-num> | <dec-num>
<oct-num>     = 0o<oct> | {0|1}.{0-7}^5
<dec-num>     = {+|-}{0|1}.<dec> | <dec>

Tokens (lexical level):

<sep>                        = <separator> = <whitespace>+ | <operator>
<operator>                   = + | - | * | / | @ |  @@ | : | . | ; | , | 0o
<identifier>                 = <extended-alpha-char><extended-alphanumeric-char>*
<digit-seq>                  = {0-9}+
<comment>                    = ; <any-char-but-not-@@>>*
<auto-comment>               = @@  <any-char>*
<extended-alpha-char>        = <alpha> | _
<extended-alphanumeric-char> = <extended-alpha-char> | <numeric-char>
<string>                     = " <any-char>* "

Expressions:

<comma-expr>          = <additive-expr> | <additive-expr> , <comma-expr>
<additive-expr>       = <multiplicative-expr> | <multiplicative-expr> {+ | -}  <additive-expr>
<multiplicative-expr> = <bit-or-expr>  | <bit-or-expr> {* | /}  <multiplicative-expr>
<bit-or-expr>         = <bit-and-expr> | <bit-and-expr> '|' <bit-or-expr>
<bit-and-expr>        = <dotted-expr> | <dotted-expr> & <bit-and-expr>
<dotted-expr>         = <unary-expr> |  <unary-expr> . <dotted-expr>
<unary-expr>          = <atomic-expr> | {+ | - | 0o} <unary-expr>
<atomic-expr>         =  <identifier> | <digit-seq>  |  <string> | ( <expr> )


A (hacked) piece of a C yacc grammar used as a guide for
expressions. Highest-level entry point is additive_expression.  Based
on https://www.lysator.liu.se/c/ANSI-C-grammar-y.html

primary_expression
	: <identifier>
	| <digit-seq>
	| <string>
	| '(' primary_expression ')'
	;

unary_expression
	: primary_expression
	| unary_operator unary_expression
	;

unary_operator
	: '+'
	| '-'
	| '0o'
	;

dotted_expression
	: unary_expression
	| dotted_expression '.' unary_expression
	;

multiplicative_expression
	: dotted_expression
	| multiplicative_expression '*' dotted_expression
	;

additive_expression
	: multiplicative_expression
	| additive_expression '+' multiplicative_expression
	| additive_expression '-' multiplicative_expression
	;

Note +0.11111 not the same as 0.11111, e.g.:

+0.11111 + -0.234 + 0o123

0.11111 + +0.123 + 0o123

Based on a comment in wwasm.py, we'll have identifiers case-sensitive

Identifiers will be used generally as variables bound to addresses,
but literal values are ok too if the asm adopts syntax to deal with
them.

# sample line:
# @0061.49:140001     w0061: mr   0001      ; multiply and roundoff @@WrittenBy a0045 a0101 ReadBy a0101



Eval
====

Arith binary ops:

binarydot (unary-{+,-}, (literal-{0,1}), literal-digit-seq)		Decimal fraction
binarydot (literal-{0,1}, literal-5-oct-digit-seq)				Octal integer
unary-0o (literal-oct-digit-seq)								Octal integer
literal-digit-seq												Decimal inreger


 0.12345
+0.12345

12/23/24 todo assembler and further
	* auto-comment
	* comment space, alignment -- provide options?
	* write listing
	* Button up file handling
		- Except: Default output for core as stdout?
	* Parens in expr print
			Actually needed! crt-test.ww has (a-b)/3. (was a-b/3 and old asm did not follow std precedence.
			[Fixed with new expr type ParenWrapper; just a pass-through in eval, used only in listing.]
	* Related to last comment looks like bug in old asm forming one's-comp negative numbers. See crt-test.acore versus crt-test.n.ncore
	* Quotes in strings
	* .exec doesn't list properly -- strings in this case don't want quotes
	* flexo translation
		Not sure I have it all right
		[New wwflex code and Flascii takes care of it. See below for remaining issues.]
	- "See .dbwgt for more discussion"
	* Assure all wwasm args are handled in some way
		Yes, with some debate ahead
	* Verbosity and Debuggery
		Doesn't seem to be a need for either in new asm right now, but the flags are available in AsmProgram
	* Bail on "too many" errors
		Let everything run, suppress output files on any errors
	x Hacked wwasm.py to accept comma in .dbwgt
		Backed-out; not needed
	* Case-sensitive? Right now new asm is not at all
		We want case-insens ops and case-sens labels and vars
	* Check range on nextcoreaddress since can overflow 2K as in all1.ww. Right now croaks.
		[Fixed by checking range in passTwoOp. Problem in AsmInst.init
		 showed via xref array so just ignore any overflow there since
		 can't xref from/to non-exeutable ops.]
	* Mod and test disasm
	* asm: no-prefx-addr option, to get a pretty-printed source file
		Changed to --MinimalListing
	* --Legacy_Numbers: should go away? Rightnow .org has a mix in the
          code; it's clear some .org numbers are meant to be octal,
          even though they have no 0o prefix. Really should conform to
          std rules and the code with unadorned octal should change.

		  Default octal in Mad-Game? Looks like only for non-address
		  operands (e.g., si). All addresses use symbolic
		  labels. Modified mad-game by copying to .n version and using
		  explicit designators for all octal numbers. Got same results
		  as asm.

		  So right now I favor a bit of extra editing versus reading
		  options.

		  [Yes we agreed it should go]

    * annotate io dev: no reason it shouldn't be default, no option, with auto-comment?
		Done, but it broke idempotency! Fixed that.
	* .wwfile really wants quoted strings -- i.e., expect a var
		All Code-Samples modified thus in .n.ww versions
	- Can probably be more elegant in AsmLabelTab by subclassing dict.
	* Why does core file have 7-oct width?
		Guy thinks because he first wanted to encode the memory bank.
	* Note crt-test has runtest.n.sh, but the drawing output has not
		  been validated against fixes Guy will be supplying.
	* I'l take on a task of updating the asm manual.
		Should be good for now
	* Get rid of yaml files
	* Assure all TestResults* dirs out of git -- ok git in web diff says deleted?
	- Do we need to handle anything special for "overflow" numbers?
      E.g., +1.001. Is there a need to handle this in some way in the
      asm lang?
	- .isa needs prescan? Doc 2.8.3
	- "Preset Params are meant (I think) for doing address assignments
      and calculations, so the values associated with a PP are
      restricted to 0-2047."  This is in asm doc; I currently don't have this restriction.
	- --Logdir -- still active?
	* Clarify C std vis-a-via octal and other number syntax.
		Python does 0o, but C does not
	* Issues with inheritance and *args? See listingString()
		Looks ok -- needed to learn more about *args vs **kwargs
	- Two .print insts in a row cause a comma-expected syntax bug (in sim)
	- Unterminated string seems to crash asm tokenizer
	* How does float dv work? Can't find anything that matches this
	  algorithm. The fixed-point-30 lib does not implement dv.
		[Is almost certainly Taylor series of 1/(a+b), two terms.]
	* Shifts in lz
	* Rename new asm to be current; appropriate rename old prog and stuff if desired.
	  		 1/31/25 -- renamed away from .n
	* Range check float input
	- Found a log bug where the stdout logs were continually making
      LogClass instances. Due to not using class var right -- needs
      wrapper, unlike in C++.
	* Tracebranch in sim -- need way to turn off
		Turn on quiet id -d
	* Suppressed undefined-value error -- too noisy.
	* Debugger: added provisions for "real" debugger by adding a
      SymToAddr table to the sim; it already has an addr-to-sym table,
      SymTab. Also moved wwasmparser.py to Common.
	* Debugger investigation shows the .print tokenizer produces a fatal error. Can we change?
		Changed to error
	* Print floats with scientific notation or the eqv of C's "g" format.
		Python has "g".  Now printing 30,15 floats with 10 digits and 24,6 floats with 8 digits
	* Hoist cpu class so we can share with dbg
	- Show .print etc in dbg. Right now just shows ww insts
	- Get rid of need for dummy parsed line in dbg
	* Dbg doesn't handle signals and alarms
		[Handles all alarms, and kbd interrupt]
	* bounce test (and the one in code-samples) has a .org 1. This
	  doesn't seem right. Fixed the test but not the code-sample.
		[Guy says this is what the original code did.]
	- Asm syntax errors need work. Need better check for unbal'ed
	  parens, and identifying specific clause types in errors,
	  e.g. xyz* gives comma-op syntax error, which is misleading.
	* Trap float overflow in conversion and return inf.
	- Dbg bug in printing AC and prob other regs -- wrong signs. Trying printing neg number.
	* Dbg bug in rs if do rs before running.
		[Fixed with revamp of control structure]
	* Dbg possible enhs: watch-for-write (addr); allow a mem loc to be set
			[Watch-write done,
			 Write-loc done.]
	* Dbg: added tb (traceback)
	* Dbg: Added bp disable/enable
	* Dbg: made "p" print single locs and blocks
	- Dbg: srh etc doesn't read param properly and it comes out as a (too-large) address
	- Dbg: Label versus .pp Parameter -- Shown as same kind of symbol
      mainly since the core files just have a single symbol type.
	- Dbg: Consistency of machine state at alarms and interrupt points
	  is a question.  An instruction which picks up an alarm, like dv
	  alarm or overflow, should leave the state as if the instruction
	  were not executed, and leave the pc at that instruction -- i.e.,
	  IMO. What did real machine do?

	  Instructions like halt execute, and where is the pc left (on the
	  real machine)?

	- Dbg: Fix help wrt what the commands print
	* Send Knuth info we have for any insights
	* Added -r (readable section) to flex converter
	x Made ! be the stop char -- but not really needed
		[Backed out -- not needed.]
	* Added - for stdin to flex convertor. That and the same additionm to
	  sim allows here-docs and thus easier testing of L&Z.
	* sim accepts - for std in for papter tape file, so can easly run tests
	* Float (actually 30,0) printer -- what's the qp instruction?
	* Issues remaining with L&Z:
		* Parens not compleletly working
			[Fixed -- was issue in translated ascii to flex]
		* Divide seems broken overall (more than just the inaccurate spax divide)
		  	[Fixed -- prob same flex issue. But we still have
		  	 inaccurate spax dv and can crash on some tests.]
		* Float printer, flexo device
	* Fixed precedence of | and &
	* Question about one's-comp at asm level -- I'm not in favor
		[Seems resolved that we'll keep it as-is]
	- Dbg: Add debugger section to doc
	- Update doc with new asm comment-fmt options
	* Consider .print control, to turn them on and off easily and in
	  apprpropriate context. Tried adding asm --OmitDotPrint, which
	    takes them out of the core and listing, but does not seem useful so removed.
		[Solved with .if]
	- .if -- emit in listing if --Reformat
	* --Reformat: error handling, etc, -- expr eval needs error value?
		[Looks good for now: added error suppression to evalError if
		 reformatting. So syntax errrors should still bail.]
	* Better heuristics for semicolon-formatting in asm listing. There
	  should be a way to get commented-out code to look "natural"
		Looks a bit better now, but...
	- Asm listingString() and formatComment()
	   have a lot of hacks and should be replaced by a proper FSM scanner.
	* Asm cb.log in infra -- not defined. Eg try unknown flex char
	* !!! Asm .flex broken -- not incrementing address!!??
		[Yes, it was not. Fixed.]
	* Note rc for flex takes high end of word for flex code. If shift in ww need to clc.
	*  Asm .flex needs to understand "\n" and maybe other chars in strings
	  so proper flex code is generated. Also handle shift, color,
	  superscript numbers.
		[Asm now understands Flascii]
	- Flexowin -- check noxwin flag
	* .float does not detect all out-of-range cases -- try .float +0.1,20
		[Fixed check off-by-one.]
	* .float still issues with neg nums, eg try .float -0.1,1 versus +0.1,1
		[Some progress, was not detecting mag(mant) correctly in float reader.]
	* .float gets wrong nunmber if use too many digits, eg .float
	  +0.99999995, 0 => 0.99999994, but .float +0.99999999, 0 =>
	    -0.99999994
		[Fixed by limitng number of digits based on system rounding such that
		 the resulting floating value is less than 1.0.]
	* "help-me" files look like they're coming from flex converter
		[Should go away after revamp of that program. In-progress.]
	* What is supposed to happen if you read beyond the end of a PETR?
		[Unknown, but note mention of <stop> char in L&Z user doc,
		  i.e., stops the computer to e.g. load a new tape. The flex
		  file converter now adds a <stop> char to end of file, which
		  may be detected by a ww program.]
    * Petr: should we have end-of-tape return a <stop> char?
		[No, but we get that effectively with previous entry.]
	* si does not rewind paper tape. Can use A and B but seems hokey
		[Added new device, rewindable PETR, base 0o1000. See ww_io_sim.py]
	- device id for petr seems wrong manual says that code is for mech tr
		[Looks like it was easier for Guy just to support both devices with the same code.]
	- LZ status 5/11/25:
		- Drum-based storage of compiled code NYI (Knuth notes and not in the code)
		- Subscript vars NYI (Knuth notes and not in the code -- note blank op space for vertical bar)
		- Negative exponents -- works after fixing "ca 210" problem
		- SR and CR are not implemented (these did calls to one-line subrs)
		- The F^n library of math functions (eg trig)
	* \n in asm (esp flex) NYI.
		[Added escape support for \n, \t, and \b to asm
		 tokenizer. These produce the literal char e.g. newline. The
		 listingString() function changes it back to the source form.
	- Asm: carat-string is useless. Fix or discard.
	* Float printer -- extreme accuracy issues
		[Looks like bug in spax, where if you shift a 24,6 low word it
		 will get the wrong bits due to a negative exponent. Fixed with
		 ".if f24" enablement in the code.]
	* Float printer: do low-end rounding? eg 42^2 + 57^2 = 5013, but
		printer gives +0.50129985+04. Same issue printing 42^2 and 57^2.
		Problem in essence is the modern style is to do decimal
		rounding, after producing digits. Would need code change to
		frac printer to store digits then do the round. This does not
		seem to be in the spirit of the ww apps at the time.
		[Yes not in the spirit. See "Is integer printing" issue below.]
	* LZ: 197 location needs to change to different space -- runs into comp_code
		[Now grows down from top of comp_code]
	* LZ: Note switch-table loc for a letter (var) is re-used during
			execution, since its parsing job is done and the table
			entries are no longer needed.  But 2 words are needed per
			var. Scanning the table shows that no letter is directly
			followed by another in the table, so variable collisions
			are avoided. The upper case table has a few such
			collisions, but vars are all lower case.
	* LZ: 12th root of 2 accuracy?
		Note use this clisp loop to get many digits of music-note prog for ref:
			 (let ((r (expt 2d0 (coerce 1/12 'double-float)))
				   (s 220d0))
			   (dotimes (i 25)
				 (print (list i s (sq s) (/ 1 (sq s))))
				 (setq s (* r s))))
		[I've probably gone as far as I can with this.]
	* LZ: Is integer printing behavior really like the original? Prints approx from below.
	  	  Eg print 123 -> +.12299998+03
		  Python prints the integer

		  Well...If it's an int, then div by ten drops bits, so we
		  lose precision in normalize. Therefore need better way to
		  detect the int and print differently.

		  But, what is that different way? The frac printer and the
		  original float printer (it seems) printed in the same
		  frac+exp manner. Would they have printed for 123,  +.12300000+03 ?

		  [Found round issue! Now looks better, ie, more like
            original, as in sample in Laning letter.]

	* LZ Paper:
		- -32767 -- fractional behavior
		- Fig 5 -- wrong; it's not the 24,6 routine
	* %fx -- really can't support it
		[Removed]
	- Replace FlexoClass with code in wwflex
		* File names and related stuff in asm flow gen
		- wwdisasm uses it's own flex code table -- not clear it's worth changing
		* "record status message" get a char returned for rc -- necessary? -- currently commented out
			[Keeping it for now]
		- char display at right in tcore files has changed e.g. # rather than \0 for null char:


< @C00160: 0040112 0100207 0040047 0074040 0000000 0000000 0000000 0066315  ; ts ca ts sp si si si ex  :         s3#t###+ : <color>t<color>k###6
< @C00170: 0000510 0005075 0114630 0063147 0000200 0034632 0177533 0157777  ; si .word su ab si cf md SL  :  <shift dn>n##f6<del> :     #ew,#u<del>#
< @C00200: 0137777 0106313 0000100 0017400 0041000 0001000 0000001 0074050  ; dm cs si rd ts si si sp  :     <del>4#####h :  #\b#3<color>##k
< @C00210: 0074062 0074152 0000000 0177766 0130002 0070040 0000001 0074032  ; sp sp si md ao cp si sp  :         by#9et#f :     kk#<del>pc#k
< @C00220: 0100213 0040002 0074157 0000000 0000000  None    None    None    ;    ca ts sp si si        :      4e###       : t<color>k##      
< @C00240: 0040224 0000600 0100223 0024000 0100224 0074060  None    None    ;   ts si ca rc ca sp      :       r#5#ro     : <color>#tstk    
< @C00260: 0040224 0000600 0100223 0024000 0100224 0074071  None    None    ;   ts si ca rc ca sp      : r#5#r<shift up>     : <color>#tstk    
< @C00300: 0040224 0000600 0100223 0024000 0100224 0074130  None    None    ;   ts si ca rc ca sp      :       r#5#rn     : <color>#tstk    
< @C00320: 0040224 0000600 0100223 0024000 0100224 0074141  None    None    ;   ts si ca rc ca sp      :       r#5#r#     : <color>#tstk    
< @C00340: 0040224 0000600 0100223 0024000 0100224 0074153  None    None    ;   ts si ca rc ca sp      :       r#5#r#     : <color>#tstk    
---
> @C00160: 0040112 0100207 0040047 0074040 0000000 0000000 0000000 0066315  ; ts ca ts sp si si si ex  :      s3#t\0\0\0+ : <color>t<color>k\0\0\06
> @C00170: 0000510 0005075 0114630 0063147 0000200 0034632 0177533 0157777  ; si .word su ab si cf md SL  :  <cntl>n#\0f6<del> :   \0ew,\0u<del>#
> @C00200: 0137777 0106313 0000100 0017400 0041000 0001000 0000001 0074050  ; dm cs si rd ts si si sp  : <del>4\0\0\0\0#h : #<bs>\03<color>\0\0k
> @C00210: 0074062 0074152 0000000 0177766 0130002 0070040 0000001 0074032  ; sp sp si md ao cp si sp  :        by\09et#f :   kk\0<del>pc\0k
> @C00220: 0100213 0040002 0074157 0000000 0000000  None    None    None    ;    ca ts sp si si        :    4e#\0\0       : t<color>k\0\0      
> @C00240: 0040224 0000600 0100223 0024000 0100224 0074060  None    None    ;   ts si ca rc ca sp      :     r\05\0ro     : <color>\0tstk    
> @C00260: 0040224 0000600 0100223 0024000 0100224 0074071  None    None    ;   ts si ca rc ca sp      : r\05\0r<cntl>     : <color>\0tstK    
> @C00300: 0040224 0000600 0100223 0024000 0100224 0074130  None    None    ;   ts si ca rc ca sp      :     R\05\0RN     : <color>\0TSTK    
> @C00320: 0040224 0000600 0100223 0024000 0100224 0074141  None    None    ;   ts si ca rc ca sp      :     R\05\0R#     : <color>\0TSTK    
> @C00340: 0040224 0000600 0100223 0024000 0100224 0074153  None    None    ;   ts si ca rc ca sp      :     R\05\0R#     : <color>\0TSTK    

	- Asm log subclass just doesn't work -- python doesn't have the right polymorphism
	- Asm: label: ,word 0o123 parses but produces garbage
	- Runaway detector -- still work? [Looks like it is -- run "...change...tcore". But mad-game loops and it doens't kick in.]
	* ww_flowgraph.py -- LAS42 prints
	- wwutd -- Add addresses to %String
	* Should use immutable  (1,2,3) lists for x in (1,2,3) rather than mutable [1,2,3]
		[Changed wwasmparser to use tuple format. Did perf test and is
		 maybe marginally better. Also had a separate test doing "x in
		 (1,2,3...15)" and "x in [1,2,3...15]" in a loop and it showed
		 almost no perf diff. Perhaps there are jit switches or other
		 magic to get more optimization. Until I feel like diiving in,
		 I'll leave the original code alone.]
	- Dbg: syms screen size wrong? Also should sort
	* wwinfra.py, why this?
				# LAS
                # self.cb.log.warn("Reading Uninitialized Memory at location 0o%o, bank %o" % (addr, bank))
                print ("Reading Uninitialized Memory at location 0o%o, bank %o" % (addr, bank))
		[Seems to work with the warn call, so I put it back]
	* wwinfra.py -- cleanup up commented-out stuff
	* wwinfra.py -- restore "symbol" for "record record"
	* Hoisted CpuClass to its own file wwcpu.py, now in Common.
	- With cpu hoist should be able to simplify debugger interface to sim.
	- update_panel_for_dbg -- needs to do all i/o for dbg or at least more than now.
	- Code-Samples/Bounce/r-196-bounce-example: There is bounce.ww and bounce1954.ww, same except that
		$ file bounce.ww 
			 bounce.ww: ASCII text
		$ file bounce1954.ww 
			bounce1954.ww: ASCII text, with CRLF line terminators
	* LZ: print of .1 comes out as .25
		[Needed zero-checks.]
	* LZ: certain tests fail badly with wrong values. See
      lzt8.save. Not clear if the issue is just printing, as in
      previous issue.
		[Looks good now]
	* Added Justifier class to wwdebug to print syms in neat
	  columns. Algorithm adapted from ls.c. That one looks more time
	  efficient, passing over the string list only once, but using a
	  fair bit of memory, to hold info on the max number of possible
	  columns, e.g. screen-width/3. Mine just formats for 1,2,
	  ... columns until it won't fit, then backs off to the previous.
	- Notes and proposals for output and logging:
	
		- Flex (and tty) output -- too much! For flex, there is
		  line-by-line, "flex said:" everything at the end, and that
		  again if "info" is on, i.e., if it's not -q.  Seems to me we
		  really only need the line-by-line.

		  Removed this extra logging:

                cb.log.info ("Begin Flexout:\n" + logstr)
                cb.log.info ("End Flexout")

		- If sim without -q, we're flooded with "info" messages. This
          should all be off by default. Particularly annoying:
				Info: branch forwards from pc=0o2524 to 0o2745(r199)
				Info: branch backwards from pc=0o2746 to 0o2712(exec_inst)

		  Added --Verbose (-v) in addition to -q. We'll sort out the diff as we go.

		  Should we have -v and -vv (--VeryVerbose)?
			Python uses -V and if you want more, -V -V

	- Control panel:

		- Some doc in 2M page 68 MANUAL INTERVENTION REGISTERS AND INDICATOR LIGHTS

		- Switches esp intervention don't seem to correspond to much
          doc. And why are they radio buttons? And short words?
		  [Guy explained about this radio-octal notation. It's in a
		  panel in a pic from his HNF doc.]

		- Monentary push-buttons should light momentarily when pressed.

		- If FF Regs are for internal indicator use, why tdo we get
		  warnings when we write them?

		- I'm not clear on the "gas discharge" doc -- are they just
		  neon lights, and they use the hysteresis induced by their
		  negative resistance?

		- I can find few pics that show any of the panels described in
          the doc.
		  [Guy: most panels work woith two rosw of lights, one red and one "clear" or "white". 





	- C-ish
	- Get "everything" into git: tape images, images on code, etc.
		Did sizing run see below marked 1/1/25
	* LAS: work on L&Z? Maybe just use new translator and asm?
	- LAS: disasm, C-ish compiler, ...? Where are we wrt to "musesum-ness"
		- One goal is historical research and perhaps a paper on the
		  code we've found and resurrected.
		- Another may be museum exhibits -- esp. hardware currently under dev.
	- How can we characterize the kind of code that was written for ww?
		What about SAGE? Same instruction set? The whole interpretive
		"VM" thing seems to have been pushed hard in the MIT
		setting. What about in practice, wherever that might have
		been?
	- Put together a set of graphics windows that represent the set of
		i/o devices, e.g., a window for the flex printer, perhaps
		another for paper tape, etc.  These would be similar to the
		scope window.


1/12/25
Procedure call and other compilation notes
==========================================

- Stack starts at highest addr and grows down

- Args are pushed on the stack

- When entering a proc, a frame is pushed. Original stackp - n is the
  nth arg (one-based). stackp + n (zero-based) is local var.

- Consistency of td vs ta

- Idiom: Establish an instruction like  ca <initial-addr>, then just ao
  to that instruction to bump a table loc.

- Did rel-addr lib, stack-frame-rel-addr-lib.ww. Complicated! Probably
  better is to save all writeable words on stack and restore on exit.

- Could do k = *p++, where p is a ca instruction. 

2/2/25
Finding dv error in float-lib, note to Guy:

I studied the instruction set and other doc more deeply and so far I
conclude that the behavior described where BR is always positive is in
fact correct. When I think about the difficulty of building hardware
at the time it makes some sense to me. One's complement provides a way
to do addition and subtraction on a common representation of both
positive and negative numbers, but mult and div are still harder with
signed arithmetic. Hence for those operations the hardware converts to
mag form and back again. The B reg is the extender for operations that
spill over a word, and does not need to have the complement logic
built in; this may seem trivial now but then it was an expense.  I
recall, but vaguely now, similar issues when I did signal processing
hw in school, in the SSI/MSI TTL days.
 
Anyway at this point I've turned off the flags that cause negation of
BR, so vibrating-string works ok. I haven't looked at the L&Z issues
yet, but rather dove back into the float lib, to see if these
revelations cast any light on the troubles there. In doing tests and
looking at traces and sim code, I have not found any sim errors in sf,
shifts, add, and so forth. I tested dv on normal ww fractions and it
looks ok.
 
So I then dug into tracing the float-lib dv, and made I think a little
headway, but nothing really solid yet. Where it says:
 
                           ;       Form (2**-2/x**2)' (Use Euclid's algorithm)
 
which starts at r41, there seems to be an error in the note, and it
should say (2**-2/x2)', i.e., it's not something squared. There is
also an error in another note, for the code starting at 37, where it
should be just x2 and not x2**2.
 
The Euclid part is due to using dv to get bits which are then used to
get floor and remainder, for the lower bits of the reciprocal. Just
what the exact calc is here I'm still trying to figure out. The "su
17r" at 44 is really suspicious. 17r contains "ca 0", which is
executed but never written, just read for its value, which is
-32767. Issues arise when the low bits in the original floating
divisor are zero.  We do 0 - -32767 = 32767, then add one to that, and
kaboom. This is a common case; the test I used which crashes is
float1/float2. It may be doing some kind of rounding.
 
By playing with this and adding less than 32767, more tests like sqrt2
run.  One problem is that aspects of the code are position-dependent,
in that calc of dispatch addresses and such depend on fixed offsets of
certain words. So one has to be careful inserting code.
 
I'm pretty sure the overall formula for finding the reciprocal follows
the Taylor series for 1/(a + b), which expands via Alpha as:
 
1/(a+b) = 1/a - b/a^2 + b^2/a^3 - b^3/a^4 + ...
 
It uses the first two terms, which accounts for the x-squared, but it
really threw me off that the notes seem incorrect.
 
Anyway I haven't found the problem yet but making progress.
 
 - Larry

----------------------------------------------------------------------
1/1/25
The mounted shared whirlwind google drive:
pwd
/cygdrive/g/.shortcut-targets-by-id/1-7fYz-kOky_lqe_lvHZ0YBBHz-ikIffj/Whirlwind
du -s -k -h *
42M	Catalogues-and-Indices
73M	Code-Samples-Local
311K	Dave-Walden-WW-Report-R221.pdf
258M	GitHub
18M	HNF-Git
93M	Hardware
1.0K	How-to-Make-a-Release.txt
9.5M	Images
219K	JavaSim
232M	Mag-Tapes
70M	Paper-Tapes
2.4M	Papertape-Decitek-Reader-Punch
923K	Partners
1.1G	Photos
277M	Py-Local
1.5G	Scanned-Docs
56M	SimH
9.1G	Static-Document-Files
2.1M	Whirlwind-Python-Guy-Oct01-18.zipx
14K	Whirlwind-Q-tmp-Oct12-17.docx
366M	guy
1.0K	rsync-to-pi.sh
1.0K	rsync-to-pi.sh~

M-2539-2 Comprehensive System manual
====================================

Section														Pdf page
-------														--------

introduction													5

part i. intro to programming and coding							10

chapter i the cs computer -- simplified version					11
chapter ii transfer of control -- counting						19
chapter iii cycle counters -- modification of addresses			27
chapter iv floating addresses									35
chapter v input and output										43
chapter vi errors and post-mortems								60
chapter vii subroutines											65
				preset parameters								74
chapter viii review												79

part ii. advanced coding techniques								90

chapter ix some more fundamentials								91
chapter x number systems										96
chapter x1 the whirlwind [i] computer							107
chapter xii auxiliary storage and in-out equipment				132
chapter xiii programmed arithmetic								148
chapter xiv the conversion program								167
				ditto											194
chapter xv the utility control program							202
chapter xvi automatic input-output requests [output]			224
chapter xvii generalized post-mortems							241


2/6/25
Conditional exec
================

It was not my intent to be dismissive of the conditional-exec ideas,
and separate from the debugger idea we can consider some sort of
conditional printing. I don't support allowing more Python in the asm
language. We could easily do .printif:

	.printif Debug, "X = %d", X

where Debug can be a .pp symbol or somethig set of the cmd line. We
could similarly do .execif:

	.execif Debug, blah()

Doing a general .if is also possible, e.g.:

	.if Debug, .print "X = %d", X
or
	.if Debug, .exec blah()

These latter forms break the current syntax, but not fatally and I
could probably fit them in.

2/26/25
Debugger Doc
============

The debugger is invoked as follows:

python wwsim.py --Debugger x.acore
python wwsim.py -d x.acore

To my surprise, the -d option wasn't taken!

Invoking -d automatically turns on "very quiet" mode, i.e., no info is
printed like branch-forward, branch-backward, etc. I found this output
too noisy when using the debugger.

The help output is:

dbg 10> h
p expr [, block-len] [, format]
          Format = o: octal, d: decimal, fr: fraction, fl: 24,6 float, fm: 30,15 float, fx: flexo-to-ascii, i: instruction.
          Print an address or block and its contents, or just the value if a register is specfied.
          Default format is octal.
r
          Run program from current pc
s
          Step program one instruction. Typing carriage-return does this too.
rs
          Restart program
b addr1,...,addrN
          Define a breakpoint for each given address. Prints id and corresponding address.
bl
          List breakpoints and watchpoints.
bd id-range1,...,id-rangeN
          id-range = id-num | id-num1 - id-num2 | all
          Delete breakpoint or watchpoint defined by each given id, id range, or all.
          E.g.:
          bd 0-4, 7, 8-10
          bd all
bdis id-range1,...,id-rangeN
          Disable breakpoint or watchpoint defined by each given id, id range, or all.
bden id-range1,...,id-rangeN
          Enable breakpoint or watchpoint defined by each given id, id range, or all.
tb [n-insts]
          Traceback: history of instructions, latest at the bottom.
          Prints n-insts; default (and max) is 100.
wwr [addr1,...,addrN]
          Watch for memory write. When any write instruction (ts, td, ta, ao, ex)
          is executed which writes at one of the given addresses, break.
          Prints watchpoint id and corresponding address.
h
          Print help
quit
          Exit debugger and simulator
dbg 10>

Issues/Notes:

- rs doesn't actually restart, just goes to the beginning, and you
  then have to type r. There may be other issues with it
  too. Generally, I tried to be minimally invasive in the sim's
  control loop, and there might be a few cracks.

- Printing registers has bugs, like negative numbers are wrong when
  printed in decimal.

- .print and .exec will not appear, nor are they executed, at a
  breakpoint. You need to step or run from there to get that
  executed. This is something we can potentially fix, i.e., these would
  be treated as executable statements by the debugger.

- In the sim code, I added a few "helper functions" to pass to the
  debugger, to get info from the sim. We should abstract out at least
  the Cpu class so I don't need all those functions, so that is on the
  to-do list. Note though that these additional functions don't
  interfere with the sim, so I still consider the changes I needed to
  be mininal. But at least python implements closures, so these
  functions work!

- From an implementation standpoint, this is a separate module, with
  an interface class for the sim to initiate control. We are thus able
  to avoid lots of symbol contamination in the sim itself.


Notes to Knuth
==============

(Combined Larry and Guy letter)

Greetings Dr Knuth,

  My colleague Larry Stabile and I have been working in conjunction
  with the Computer History Museum and the MIT Museum to restore to
  operation software from the 1950's Whirlwind computer built at MIT.
  You can see some of this work at
  https://ieeexplore.ieee.org/document/9312479

  Recently, we came across a copy of Laning and Zierler's algebraic
  interpreter, along with your notes analyzing operation of the
  code. After much analysis, transcription, and debugging, we've been
  able to get the code to execute in simulation, evaluating a few
  simple expressions. We were helped immensely by your detailed notes
  and markup of the hand-written listing. There's lots more to do to
  validate some of the less-traveled parts of the program, but it's
  certainly showing signs of life.

  Your notes point out a bug in the code, that a = -b comes out as a =
  1-b. This bug is present in the code we ported. You mentioned "See
  Laning's letter." We cannot find this letter; any insight you may
  have into this will be greatly appreciated.

  The code overall is very inventive and effectively defines an
  interpretive virtual machine of ww instructions; primarily this
  supports fundamental floating point operations, but it's also used
  to support higher-level operations like exponentiation by an
  integer, within the L&Z system. This seems to us an extraordinary
  leap early in the history of computers.

  This effort has also triggered an interest in learning more about
  the context and impact of L&Z's work.  Obviously you thought it was
  important enough at one point to dig into it at some depth.  Do you
  recall why, or if you published anything on your findings?

  I know that there has been some debate over L&Z's impact on Fortran,
  with J Backus first saying that Fortran had been influenced by L&Z,
  then after a more careful study of the timelines, revising the
  opinion to say he couldn't find a specific example where L&Z had
  influenced early Fortran.  I am not surprised that the actual
  interactions were hard to disentangle years later.

  But I wonder if you were left yourself with some impression of the
  reach of L&Z's work...  I believe that Hal Laning himself refined
  the ideas for years on the Apollo Guidance Computer project, but do
  you know if the original L&Z work had impact outside of MIT?

  Finally, in looking at your own notes on the program, I have to
  assume, that given the dates, you would never have seen the program
  actually working...  That, coupled with an unusual instruction set,
  must have made the paper analysis of the code a very challenging
  undertaking!


Coding Idioms
=============

These are code "patterns," mostly found in ww code but some invented
by Guy or Larry.

------------------------------------------------------------------------------
--- Nice test for zero

This tests for x == +-0 (seen in frac printer):
	cm x
	su 0
	cp a	; Branch if x is zero
------------------------------------------------------------------------------


------------------------------------------------------------------------------
--- For-loop

Pattern for a for-loop, executing stuff N times, where N is
non-negative:

	  cs N
	  ts cntr
loop: ao cntr
	  cp cont
	  sp done
cont: stuff
	  sp loop
done: ...

This pattern shows how one's-complement needs to be used with care,
since it's not what we're used to nowadays. When cntr gets to -1,
adding one via ao produces -0.  -0 still checks as negative so the
loop continues. On the next loop adding one to -0 produces 1, and the
loop ends. Thus stuff is executed N times.
------------------------------------------------------------------------------


------------------------------------------------------------------------------
--- Beware the td!

Writing instructions is a normal part of ww coding. Careful with td!
When used with shift instructions td will overwrite the low opcode bit
and potentially change the shift from hold to round.
------------------------------------------------------------------------------


------------------------------------------------------------------------------
--- WW languages designed as regular grammars

This one is more a design theme rather than an idiom.

In looking through L&Z, plus the opnames and types of labels which can
be formed in CSII, it seems their languages were all "rigged"
grammatically to allow for a largely FSM approach to parsing the csii
text. In L&Z, they used a switched-instruction state machine to branch
(i.e., "jump" or "dispatch" table) through char sequences. Those char
sequences are very tightly defined, eg, it just needs the P in PRINT,
and the operations are unambiguous one- or two-letter nmemonics.

In CSII, consider for example the tape output with lines like:

		 cpc1
		 csh1
		 rcr2
		 slr10
		 srr17
		 
In all these cases the second char of the opcode can only be followwed
by chars that are either operands or a third opcode char. There are no
ambiguities as the set of chars allowed at each step is deterministic. The operands also have a simple
and unambiguous interpretation that 

It may be worth considering how to detect this sort of pattern in the
tapes, to help find valid code. In particcular looking for rd loops is
a start.
------------------------------------------------------------------------------


------------------------------------------------------------------------------
--- Using the rc instruction for storage

The rc instruction generally ignores its operand, so you can use that
as storage. In the change-problem code it kept pointer to a string
table. So the instruction was read for its address, and executed as
well, e.g. to write to the printer.
------------------------------------------------------------------------------










Diving into the Tapes  *****
=====================
[9/10/25 Deleted all these dirs and zips because we're using Guy's dir structure now.]

~/whirlwind/Tapes/
	Paper-Tapes
	Mag-Tapes
	Also under here are the original zip files from google drive:
	Paper-Tapes-20250622T214459Z-1-001.zip
	Mag-Tapes-20250622T215056Z-1-001.zip

Env var WWTAPES = ~/whirlwind/Tapes/, set to your local area under
which the Paper-Tapes and Mag-Tapes directories are kept.
	
As of now 6/22/25 these will not be checked in to git.

- What do we know about what's on what tapes now? I.e., what have we extracted successfully?

- .tap files seems to be the base source data, with tcore, ocore, etc. dereived.



Tape Dev
========

Tape Dev Lab Notes
------------------

1/6/26
Ran wwutd with across all the tape files, with the new packed string
detector. Picked up a few more interesting strings, mostly in what
looks like a set of test programs and test executives.

12/31/25
The "change" program works and is now in
Code-Samples/Change-Problem. After much massaging the code is
reasonably comprehensible.

Found a few absolute-address issues, i.e, the code itself looks
correct, but snags were hit trying to convert to mnemonic labels and
so forth. Also in this case it's heavy on strings, and uses a packed
format (Brian says nim programs uses it too). In octal it's
{0|1}xx0yy, where xx and yy are 6-bit flexo chars, big-endian
order. The sign bit is used as an end-of-string indicator.
 
Separating the code from the data in this case was a major
challenge. To help this, I added another tool to the sim, a simple
memory map, which provides some combination of "rwx" (or nothing for
untouched) depending on the runtime access pattern. Right now it just
orders the banks as though they were cat'ed together as one big
address space.  This tool is instantiated with an option since it may
be a performance drag. The map is produced as a separate file, which
can then be examined along with the listing. I contemplated adding it
to the listing somehow but there wasn't a clean way to do that and a
separate file does the job. 
 
The change program accepts a sale amount and amount received via the
panel's "intervention registers." Key in a digit in the left IR, and
add the digit via the activation button in the right IR. The left
activation button then triggers the next phase, either asking for
input or computing and printing the change. A negative input causes a
backspace and an overstrike x, indicating an erasure.
 
The map helped a lot, as well as the fact that the program effectively
worked, and I just had to poke around to figure out how to use it and
pick up it nuances.

Interesting coding idiom: The rc instruction generally ignores its
operand, so you can use that as storage. In this case it holds a
pointer to the string table.

10/31/25
Updated packed flex description of 10/23/25 below. It may be a good
idea to look for this pattern in wwutd.

10/23/25
Wrapped up mad-game in code samples, adding a test and
reformtting. Determined the bad "T" is a bug and noted a fix in the
program.

Looking at 102782306_change_problem_gs001_fb100-6-150.acore. It prints
"Amount of sale: " but the string is not in %Strings. Looks like
packed encoding, and I'm trying to figure it out...

The encoding is packed, but not in a way I expected:

Bit 15--------------------
                         |
Bit 7------------        |
                |        |
Bit 0 ----      |        |
         |      |        |
         v      v        v
         0xxxxxx0 00yyyyyy

xxxxxx is one char, and yyyyyy is another. x is packed just after the
sign bit, which is zero. So a clc 1 puts x in a position to be
printed, then clc 9 puts y in print position, and rc is called to
output them to the flex.

10/22/25
Noted that Code-Samples mad-game is the same as the one found by Brian in the tapes:
	062302422_box63/102684113_mad_game_m_hurvitz.7ch
	102684113_mad_game_m_hurvitz_gs001_fb0.tcore



--------------------------------
Guy's mail 8/27/25:

hi Larry,
  Here's the script I used.
  
  It's currently very inefficient, and I notice now I didn't even try
  to run it on the mysterious .ocore files.

  At the moment, it also prints the name of the file it's searching,
  whether it finds anything or not.  Since almost all attempts find
  nothing, the obvious change is to make it completely silent unless
  it has something useful to say.

  I did add this to my guy-dev branch, in ~/WW/GitHub/Recovered-Tapes/Translated-Files/Scripts

  Thanks for putting up with all these rough edges...

  /guy

$ cat search-for-pattern.sh

# use code-correlate to search for a pattern in the tape corpus
# This script takes quite a while to finish...
# fedorkow, Aug 16, 2025
#
PROBE=`cygpath -w /cygdrive/c/Users/guyfe/Documents/guy/WW/GitHub/Code-Samples/Laning-and-Zierler-Interpreter/float-lib.acore`
LOG=~/tmp/tape-search.log
WWCOR=${PYTHONPATH}\\..\\Tools\\code-correlate.py

find ../Magnetic-Tapes ../Paper-Tapes -name "*.tcore" -exec python ${WWCOR} -q -p ${PROBE} "{}" ";"  -exec echoerr "{}" ';' > ${LOG}
--------------------------------

--------------------------------
Guy's mail 8/30/25:

The file 102782316_fc126-269-330_11-25.fc has color-changes coded as 
VT-100 codes, and also rubouts in it.  The Mouse.fc file is just ascii 
text with the rubouts and color codes deleted.  You can see this coder 
typed most of his/her labels in red.

You can see the CS-II converter at ~/WW/GitHub/Py/CS-II.

It's written in my ad-hoc regex style, but that's clearly not the right 
methodology for parsing this stuff...  they must have done 
character-by-character parsing somehow.

My intent is to convert the relative labels to offsets from a 'real' 
label, but that's not working properly yet.  Other than that, it's close 
to emitting wwasm code.
--------------------------------




--------------------------------
Mail to Guy 10/13/25

I've made number of changes that I hope you'll like. In digging into
the tape processing the first thing that was clear was the need to
unify the flex-code code. Along the way I wanted to experiment with
emitting a static flow graph from the assembler. These things combined
induced a number of changes, some of which we have chatted about
before.

Before doing a merge and pull request I'll demo this to you at our
next meeting.

1. Processing the flex code is now done completely by the classes in
wwflex.py. These use FSM lex techniques to assure we have the right
interpretation. In particular, translation of superscripts to
appropriate ascii now works, and I think the different formats are
clearer in the code. One thing this shows is that a lot of the fc
files have numbers with exponents in them. This may give us a clue to
their use.

%String in the core output from wwutd now includes chars from both the
upper and lower part of the word. This picked up several more new
interesting-looking strings. We should go over whether and how we
should annotate the addresses for the strings.

We'll need to go over the need and use for flex char translation which
is not dependent on context, as in the core file tables.

2. I'm moving ahead with the idea that the system (at least the sim)
should be quiet(er) by default. So there is now a --Verbose (-v), and
-q is the default. Thus -q is now a nop and just stays for compat. I
mostly did not change the flags in the code, so quiet = not
verbose. However there are a few related flags and I'll consolidate as
seems reasonable. I'll go over these before any drastic changes.

There are a few printouts that really seem unnecessary, and I'm
commenting them out for now. One is use use of a "symbol" returned
from rc for the "rc record" or something. Another is the "branch
fwd/back" print. The latter produces tremendous output is of
questionable use so the flag controlling it is commented out.

3. The old FlexoClass is now FlexoControlClass, and just has what's
needed for device control, not the flex code processing.

4. The class CpuClass has been pulled out of wwsim.py and into its
own file in Common, wwcpu.py. The stubs that were in a couple of files
have been deleted. A couple of other files had to move into Common,
like radar.py.

One thing I can now do is make the interface to the debugger a little
cleaner, but I'm not rushing into it. But what put me over the edge
for this was trying to integrate the flowgraph.

5. wwasm.py has a new --FlowGraph (-f) option, which will make
prog.flow.static.gv from the static structure.

6. Tape processing is in progress. wwutd.py uses the new flex classes,
and I've set up scripts to build needed files from the tape images en
masse. As mentioned this has already exposed some things like
exponents in numbers. We should go over this when we chat next.

 - Larry



------------------------------------------------------------------------------
12/5/25 -- Foray into 3D modeling using VPython

Summary: An interesting system for 3D and not too hard to use, but
lacks practical tools and appears to be mainly a teaching vehicle.

Test code is in the Py/Tester dir:

    Tester/vpython-test.py
    Tester/VPythonDemos_no_notebook/

First do:

    pip install vpython

The demo vpython-test.py of toggle switches and lights works pretty
well, but is super-slow to render. Tracked this down primarily to the
use of "compound" and "extrusion" objects. There seem to be built-in
flushes and screen-redraws when these are used. Even with the source
code I've not been able to track down why this is so, and I'd need to
devote much more time to it.

VPython isn't bad, but without the source code you're lost, since much
is omitted from the doc. However I have my doubts that this will be a
good way to build interactive realistic-looking Whirlwind panels of
lights, switches, knobs, and meters. VPython/Glowscript has been
around foe a long time, and has evolved from Python-only to web-based,
with translations to javascript at first but then more recently a
client-server approach.

The older translation-style system is "WebVPython" (link below) which
shows better the translation to js. But this looks like just teaching
stuff, though the code is available at the github site below. On its
face both these packages lack basic utilities like logs and debug
dumps, saving of state, and related APIs for interaction.

There is also a "Jupyter Notebook" version, and I have not looked at
whether that might alleviate some of the shortcomings.

Further exploration may be had starting from this these links:

    https://vpython.org/
    https://github.com/vpython/glowscript/blob/master/docs/GlowScriptOverview.md

They should lead to the different versions, doc, etc.
