


























This is a collection of notes and scratchings on Larry's efforts in
the Whirlwind project. It started as a doc dump for the tester, but
has expanded into assembler and other areas.
----------------------------------------------------------------------

Testing system
==============

LAS 1/1/25: Note this now represents the latest attempt at testing,
which largely discards the first idea, using yaml, etc. So those notes
are gone and are available via a previous git version. Some of the
rationale for the change is below in a note to Guy dated Nov 2024.

The main thing new is that we're script-based, and use basic scripting
to run tests and do diffs. It's based on bolier-plate scripting which
is copied an modified to make a new test. The convenience and
flexibility of such script developement outweighs the "badness" of the
redundancy, and if needed we can develop mass-editing tools to help us
if an across-the-board change is needed.

We also get free of having to provide tests only in a special "test"
area. Though we'll have one of those, tests can be anywhere in the dev
tree.

Tests are denoted by the existence of a script in a dir called
runtest.sh. This conains the info needed to run the test, filter and
compare files, announce passage or failure, and accept a test once
blessed.

To serve as a test, we need test references, so another assumption is
the existence of a TestRefs dir, probably, but not required to be,
co-resident in the dir with runtest.sh, and by convention called
TestRefs, but not required.

Each runtest.sh must have a --Accept option, which copies a set of log
or output files to the test refs area.

Each runtest.sh also has a standard cd to its own location (i.e., the
dir of arg $0), to allow it to be run more easily from an external
program. In particular, to run all tests,

   cd <whirlwind-simulator-top-level-dir>
   find . -name runtest.sh -print -exec {} \;

While I have considered making the wwtester.py code be a more
comprehensive test tool, as I did at first, I don't see the need, and
I'll archive this program in some way. Some of the techniques for
subprocess management and other items may be useful for something. But
overall my goal is to use scripts as much as possible for driving the
tests.

----------------------------------------------------------------------






Log formatting and conventions
	Seqno across all logs
	info, warning, error (etc?)
	Option (default?) for warning and error to go to stderr too.
		For asm, disasm, should be default, -q suppresses
		For sim, quiet would be default, and verbose brings out warning and error

!!! In wwsim.py:
# There can be a source file that contains subroutines that might be called by exec statements specific
#   to the particular project under simulation.  If the file exists in the current working dir, import it.
if os.path.exists("project_exec.py"):
    sys.path.append('.')
    from project_exec import *
    print("imported project_exec.py")

  Must be in wd!






wwasm
disasm
	Default: errors, warnings, fatals, and info all go to asm/disasm log
			 errors, warnings, and fatals also printed to stderr
	-v errors, warnings, fatals, and info also printed to stderr
	-q Only errors and fatals are also printed to stderr
	asm/disam log files are only suppressed via the log-suppression options
	Other logs which may be created underneath are files only (no stdout
		or stderr), and may be suppressed via the log-suppression options

wwsim
	Default: errors, warnings, fatals, and info all go to wwsim log
			 errors, warnings, and fatals  also printed to stderr
			 Output from .print and exec(wwlog) goes to wwsim log and stderr
	-v
	-q Only errors and fatals go to stderr
	Other logs which may be created underneath are files only (no stdout
		or stderr), and may be suppressed via the log-suppression options

StdArgs:

--Verbose -v ? Only makes sense if default is to print Info
	Propose: Default is to show info, -q turns it off.

	Should verbose be available as a flag for any general printing? 

--Quiet -q Suppresses Info severity

--LogDir  Directory into which to store logs. Default is current wd.

--NoStdErr Normally warnings, errors, and fatals are written to stderr
		   in addition to being logged. With this option only the log
		   is written.



Log Names, <base>.<logname>.log, e.g., bounce.wwsim.log:
	wwasm
	disasm
	radar
	wwexec
	gen
	wwio





wwsim  [-flowgraph]
wwasm
wwdisasm
	wwutd
	wwdiff






python wwasm.py xxx.py
python wwsim.py -x -y xxx.acore -z -t
python wwtester --filter xxx.wwsim.log "ww_draw_point" xxx.wwsim.filtered.log
python wwtester --verify xxx.wwsim.filtered.log Code-Samples/xxx/xxx.wwsim.filtered.reference.log




reference.log
     At top is the filter used to create and test against it
	 XML or JSON or some crap?
		reference.log.json

test.info.json
	Whole script, basically
	Perhaps some way to generate, but at first can just hand-edit

self-contained in code-samples dir


Or python?

./Py/Assembler/wwasm.py:    parser.add_argument("inputfile", help="file name of ww asm source file")
./Py/Assembler/wwasm.py:    parser.add_argument("--Verbose", '-v',  help="print progress messages", action="store_true")
./Py/Assembler/wwasm.py:    parser.add_argument("--Debug", '-d', help="Print lotsa debug info", action="store_true")
./Py/Assembler/wwasm.py:    parser.add_argument("--Legacy_Numbers", help="guy-legacy - Assume numeric strings are Octal", action="store_true")
./Py/Assembler/wwasm.py:    parser.add_argument("-D", "--DecimalAddresses", help="Display traec information in decimal (default is octal)",
./Py/Assembler/wwasm.py:    parser.add_argument("--ISA_1950", help="Use the 1950 version of the instruction set",
./Py/Assembler/wwasm.py:    parser.add_argument('--outputfilebase', '-o', type=str, help='base name for output file')

./Py/Disassembler/wwdisasm.py:    parser.add_argument("inputfile", help="file name of ww input core file")
./Py/Disassembler/wwdisasm.py:    parser.add_argument('--outputfile', '-o', type=str, help="output file name ('-'=stdout)")
./Py/Disassembler/wwdisasm.py:    parser.add_argument('--use_default_tsr', '-u',
./Py/Disassembler/wwdisasm.py:    parser.add_argument("--DefZeroOne", '-z', help="Define core[0,1] as 0 and 1", action="store_true")
./Py/Disassembler/wwdisasm.py:    parser.add_argument("--Debug", '-d', help="Print lotsa debug info", action="store_true")

./Py/Sim/wwsim.py:    parser.add_argument("corefile", help="file name of simulation core file")
./Py/Sim/wwsim.py:    parser.add_argument("-t", "--TracePC", help="Trace PC for each instruction", action="store_true")
./Py/Sim/wwsim.py:    parser.add_argument("-a", "--TraceALU", help="Trace ALU for each instruction", action="store_true")
./Py/Sim/wwsim.py:    parser.add_argument("-f", "--FlowGraph", help="Collect data to make a flow graph. Default output file <corefile-base-name>.flow.gv", action="store_true")
./Py/Sim/wwsim.py:    parser.add_argument("-fo", "--FlowGraphOutFile", help="Specify flow graph output file. Implies -f", type=str)
./Py/Sim/wwsim.py:    parser.add_argument("-j", "--JumpTo", type=str, help="Sim Start Address in octal")
./Py/Sim/wwsim.py:    parser.add_argument("-q", "--Quiet" , help="Suppress run-time message", action="store_true")
./Py/Sim/wwsim.py:    parser.add_argument("-D", "--DecimalAddresses", help="Display trace information in decimal (default is octal)",
./Py/Sim/wwsim.py:    parser.add_argument("-c", "--CycleLimit", help="Specify how many instructions to run (zero->'forever')", type=int)
./Py/Sim/wwsim.py:    parser.add_argument("--CycleDelayTime", help="Specify how many msec delay to insert after each instruction", type=int)
./Py/Sim/wwsim.py:    parser.add_argument("-r", "--Radar", help="Incorporate Radar Data Source", action="store_true")
./Py/Sim/wwsim.py:    parser.add_argument("--AutoClick", help="Execute pre-programmed mouse clicks during simulation", action="store_true")
./Py/Sim/wwsim.py:    parser.add_argument("--AnalogScope", help="Display graphical output on an analog CRT", action="store_true")
./Py/Sim/wwsim.py:    parser.add_argument("--NoXWin", help="Don't open any x-windows", action="store_true")
./Py/Sim/wwsim.py:    parser.add_argument("--NoToggleSwitchWarning", help="Suppress warning if WW code writes a read-only toggle switch",
./Py/Sim/wwsim.py:    parser.add_argument("--LongTraceFormat", help="print all the cpu registers in TracePC",
./Py/Sim/wwsim.py:    parser.add_argument("--TraceCoreLocation", help="Trace references to Core Memory Location <n> octal", type=str)
./Py/Sim/wwsim.py:    parser.add_argument("--PETRAfile", type=str,
./Py/Sim/wwsim.py:    parser.add_argument("--PETRBfile", type=str,
./Py/Sim/wwsim.py:    parser.add_argument("--NoAlarmStop", help="Don't stop on alarms", action="store_true")
./Py/Sim/wwsim.py:    parser.add_argument("-n", "--NoCloseOnStop", help="Don't close the display on halt", action="store_true")
./Py/Sim/wwsim.py:    parser.add_argument("--NoZeroOneTSR",
./Py/Sim/wwsim.py:    parser.add_argument("--SynchronousVideo",
./Py/Sim/wwsim.py:    parser.add_argument("--CrtFadeDelay",
./Py/Sim/wwsim.py:    parser.add_argument("--DumpCoreToFile",
./Py/Sim/wwsim.py:    parser.add_argument("--RestoreCoreFromFile",
./Py/Sim/wwsim.py:    parser.add_argument("--DrumStateFile",
./Py/Sim/wwsim.py:    parser.add_argument("--MuseumMode",
./Py/Sim/wwsim.py:    parser.add_argument("--MidnightRestart",
./Py/Sim/wwsim.py:    parser.add_argument("--LogDir",
./Py/Sim/wwsim.py:    parser.add_argument("--NoStdErr",

./Py/Sim/wwtester.py:    parser.add_argument ("testBaseName", help="base name of test")
./Py/Sim/wwtester.py:    parser.add_argument ("--srcDir", help="Dir of source ww code, reference logs, etc.", type=str)
./Py/Sim/wwtester.py:    parser.add_argument ("--dstDir", help="Dir where to deposit logs and other files from the test run.", type=str)

./Py/Tape-Decode/wwutd.py:    parser.add_argument("tape_file", help="file name of tape image in .tap or .7ch format")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("--Ch7Format", help="interpret the file as .7ch paper tape", action="store_true")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("--TapFormat", help="interpret the file as .tap magnetic tape", action="store_true")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-F", "--FlexoForce", help="treat the file as Flex Characters", action="store_true")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-o", "--OutputFile", type=str, help="Base name for output core file(s)")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-q", "--Quiet", help="Suppress run-time message", action="store_true")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-T", "--DebugTAP", help="TAP record debug info", action="store_true")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-5", "--Debug556", help="WW 556 block debug info", action="store_true")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-7", "--Debug7ch", help="WW paper tape code debug info", action="store_true")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-C", "--DebugCore", help="WW corefile debug info", action="store_true")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-X", "--DebugXsum", help="556 checksum debug", action="store_true")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-d", "--DumpOctalBlocks", help="Dump out unknown octal tape blocks", action="store_true")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("--No556Header", help="Don't decode the 556 state machine; just assemble 556 words from bytes",
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-P", "--NoReadPastEOF", help="Stop reading at mag-tape double-tape-mark", action="store_true")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-B", "--BlockErrorStop", help="Stop reading at TAP Block Error", action="store_true")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-g", "--GlobalHistogram", help="Compute a baseline opcode histogram across all files",
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-m", "--MinFileSize", type=int, help="Ignore objects smaller than MinFileSize words")
./Py/Tape-Decode/wwutd.py:    parser.add_argument("-a", "--ASCIIonly", help="Suppress unprintable characters in FC conversion",

./Py/Tools/wwdiff.py:    parser.add_argument("diff_file_a", help="first .core file")
./Py/Tools/wwdiff.py:    parser.add_argument("diff_file_b", help="second .core file")
./Py/Tools/wwdiff.py:    parser.add_argument("-q", "--Quiet", help="Suppress run-time message", action="store_true")
./Py/Tools/wwdiff.py:    parser.add_argument("-5", "--Debug556", help="WW 556 block debug info", action="store_true")


--Quiet

--Debug
--Verbose


--LogDir
--NoStdErr

--OutputFile
--InputFile


logFilters = [LogFilter ("wwsim", "Warning|Error"),
              LogFilter ("wwasm", "Error:")]


LogMsgType = Enum ("LogMsgType", ["Log", "Debug", "Debug7ch", "Debug556",
                                  "DebugLoader", "DebugTap"])

LogMsgSeverity = Enum ("LogMsgType", ["Error", "Info", "Warning", "Fatal"])



- TesInfo.yaml => TestSpec.yaml
- Tokenizer tighten for testspec args
- Clear or rm dest log files before run -- caution!









whirlwind/
	Code-Samples/
	LICENSE/
	MacOS-Binary/
	Py/
	README.md/
	Win-Binary/
	Tests/
		Bounce/
			TestSpec.yaml
			bounce.ww
			TestRefs/
			TestResults/
		Arith/
			TestSpec.yaml
			arith-test.ww
			TestRefs/
			TestResults/

Options:
	Don't remove results dir; explicitly delete each result file
		Issue: can be hard to know what all the files are
	Rename results dir x.old after deleting whole dir x.old, then create new results dir
		Can check that contents of x.old looks "whirlwindy," ie contains ww-ish files. If not, ask for confirmation

			
os.rename (src, dst) -- rename file or dir

Syntax: os.remove(path, *, dir_fd = None) 
Parameter: path: A path-like object representing a file path. A path-like object is either a string or bytes object representing a path. 
dir_fd (optional): A file descriptor referring to a directory. The default value of this parameter is None. If the specified path is absolute then dir_fd is ignored.

Syntax: os.rmdir(path, *, dir_fd = None) 
Parameter: 
path: A path-like object representing a file path. A path-like object is either a string or bytes object representing a path. 
dir_fd (optional): A file descriptor referring to a directory. The default value of this parameter is None. If the specified path is absolute then dir_fd is ignored. 


Nov 2024 Alternative ideas

Here is the status of some of the things we went over the other day. 

Tokenizer
=========

The syntax errors in format strings now cause fatal errors, as we discussed.

Logging
=======

Yes, I see issues with the logging, and in particular it seems correct
that .print should just print verbatim on stdout, like python print.

Also, the test philosophy should be less intrusive. I see I've been
trying to impose too many changes on the system proper. There are log
design issues such as using python print for tracing rather than
logging to a file. However the test system should ideally impose few
constraints on the program to be tested and should try to capture
existing output. So that's where I'd like to head with the test
system. Right now it doesn't capture stdout or stderr, but I'll add
that capability. We can then scan this output with the test filters.

To the test system, stdout and stderr thus become "logs" themselves.

The logging system we have now is pretty flexible and allows the
creation of various kinds of special-purpose logs. For instance you
might want a trace log or other analysis log. But this means the calls
to "print" would have to be changed. But it does not seem productive
to try to change so many things at once, and a test system should test
a system as-is if possible.

But I believe where we go off course a bit is in trying to have logs
to files that also do "console" output, i.e., to stdout or stderr.
The console output should be primary; it's the semantics of that
output that needs handling, such as error, warning, etc. And capture
of that for testing should be done external to the program.

So I propose:

1. Eliminate the current logs created per-program. Instead the main
   program "logs" will just be stdout and stderr. We'll use the same
   log calls to get there, so we get "warning", "error", etc. But
   these will no longer go to a file. We'll capture them to a file in
   the test system, but that's external to the program.

   BTW right now log calls for Error, Warning, or Fatal get printed to
   stderr. Log calls for Info get printed on stdout. This would remain
   so in the new proposal.

2. The logging system (via LogFactory) can be used to create
   special-purpose logs that go to particular files, e.g., one or more
   trace logs. These would just be to files, and for whatever purpose
   is deemed necessary. It's just another way to get an output file,
   and there is capability for bells and whistles if desired, such as
   a seqno on each message.

3. .print should just print unadorned output to the console

4. In the last round I added the fcn wwlog so that it may be called
   from ww via .exec, e.g. .exec wwlog ("message..."). This causes an
   Info-tagged message to be logged. I changed a set of .ww programs
   to call wwlog instead of print. This can remain but in the new
   proposal but it won't go to a file, and I won't push to change the
   code.

Procedure Call and Recursion
============================

I did a little hacking with ww after our talk about recursion. 

The attached program proc-call.ww shows a main prog and a routine
called "subr", which calls itself after decrementing a global
"level". It returns when level hits zero. The print below shows a run
with level initially set to 5. Running it without -q will show some
more detail.

The stack is 10 words, and grows upward. I didn't know how to denote a
block of words, hence stack0, stack1, etc. The push does a
pre-increment, so I start the stack pointer stackp one below
stack0. For a "real" stack we probably want to grow downwards. Anyway
it's odd there is an add-one (ao) to a loc but not sub-one.

You can see there are procedure entry and exit blocks marked in the
code, and in between code for the proc body. In this case some items
are printed and the level var is decremented and tested.

If we do any kind of compilation we'll need a procedure protocol like
this, plus additional protocol for arg passing. The overhead is fairly
high. Although what I have can probably be optimized a bit more, it
does not look possible to make it much more compact.

But anyway it's the basis of recursion and if some arg-passing format
is devised can be used to do say recursive mini-max.

Here is a dump of a run:

$ 
$ python c:/Users/lstabile/whirlwind/InstructionSimulator/Py/Assembler/wwasm.py proc-call.ww -o proc-call
c:\Users\lstabile\whirlwind\InstructionSimulator\Py\Assembler\wwasm.py:105: DeprecationWarning: Bitwise inversion '~' on bool is deprecated. This returns the bitwise inversion of the underlying int object and is usually not what you expect from negating a bool. Use the 'not' operator for boolean negation or ~int(x) if you really want the bitwise inversion of the underlying int.
  in_quotes = ~in_quotes
Listing output to file proc-call.lst
Corefile output to file proc-call.acore
$ python c:/Users/lstabile/whirlwind/InstructionSimulator/Py/Sim/wwsim.py -q proc-call.acore 
start at 0o100
***1 0o202 0o101 0o0 0o101 0o5
***1 0o203 0o101 0o115 0o115 0o4
***1 0o204 0o101 0o115 0o115 0o3
***1 0o205 0o101 0o115 0o115 0o2
***1 0o206 0o101 0o115 0o115 0o1
***2
Halt Instruction!  (Code=0) at pc=0101
Alarm 'Program Halt' (5) at PC=0o101 (0d65)
Ran 100 cycles; Used mem=48MB
$ 




Assembler grammar
-----------------

The tokenizer and parser in wwasmparser.py follow this grammar fairly well, but there are probably a few spots where it doesn't line up. The code version wins unless it's shown to be some kind of error. Something not captured well here is some special casing needed for .exec.

Note that the grammar tries to capture the nuances of nunmber denotation, but in the code we use dot (".") as an operator and distinguish the number types in eval. This frees us from having to add lexical knowledge of those number forms.

Informal grammar of single line, showing what's optional:
<line> = [@ <oct> [. <dec>] : <oct> <sp>] [<label> : <sp>] [<op> <sp> <operand>[, ..., <operand>] [<sp>]] [<comment>] [<auto-comment>]

More formal version, with optionality omitted:
<line> = <prefix-addr> <sep> <label> <sep> <instruction> <sep> <comment> <auto-comment>

Clauses for the the components:

<prefix-addr> = <oct> . <dec> : <oct>
<label>       = <identifier> :
<instruction> = <op> <whitespace>+ <expr>
<op>          = <ww-op>|<pseudo-op>
<ww-op>       = ta|ao|...
<pseudo-op>   = .word|.org|...
<operand>     = <comma-expr>
<expr>        = <comma-expr>
<oct>         = <digit-seq>		Digits 0-7 allowed
<dec>         = <digit-seq>		Digits 0-9 alowed
<number>      = <oct-num> | <dec-num>
<oct-num>     = 0o<oct> | {0|1}.{0-7}^5
<dec-num>     = {+|-}{0|1}.<dec> | <dec>

Tokens (lexical level):

<sep>                        = <separator> = <whitespace>+ | <operator>
<operator>                   = + | - | * | / | @ |  @@ | : | . | ; | , | 0o
<identifier>                 = <extended-alpha-char><extended-alphanumeric-char>*
<digit-seq>                  = {0-9}+
<comment>                    = ; <any-char-but-not-@@>>*
<auto-comment>               = @@  <any-char>*
<extended-alpha-char>        = <alpha> | _
<extended-alphanumeric-char> = <extended-alpha-char> | <numeric-char>
<string>                     = " <any-char>* "

Expressions:

<comma-expr>          = <additive-expr> | <additive-expr> , <comma-expr>
<additive-expr>       = <multiplicative-expr> | <multiplicative-expr> {+ | -}  <additive-expr>
<multiplicative-expr> = <bit-or-expr>  | <bit-or-expr> {* | /}  <multiplicative-expr>
<bit-or-expr>         = <bit-and-expr> | <bit-and-expr> '|' <bit-or-expr>
<bit-and-expr>        = <dotted-expr> | <dotted-expr> & <bit-and-expr>
<dotted-expr>         = <unary-expr> |  <unary-expr> . <dotted-expr>
<unary-expr>          = <atomic-expr> | {+ | - | 0o} <unary-expr>
<atomic-expr>         =  <identifier> | <digit-seq>  |  <string> | ( <expr> )


A (hacked) piece of a C yacc grammar used as a guide for
expressions. Highest-level entry point is additive_expression.  Based
on https://www.lysator.liu.se/c/ANSI-C-grammar-y.html

primary_expression
	: <identifier>
	| <digit-seq>
	| <string>
	| '(' primary_expression ')'
	;

unary_expression
	: primary_expression
	| unary_operator unary_expression
	;

unary_operator
	: '+'
	| '-'
	| '0o'
	;

dotted_expression
	: unary_expression
	| dotted_expression '.' unary_expression
	;

multiplicative_expression
	: dotted_expression
	| multiplicative_expression '*' dotted_expression
	;

additive_expression
	: multiplicative_expression
	| additive_expression '+' multiplicative_expression
	| additive_expression '-' multiplicative_expression
	;

Note +0.11111 not the same as 0.11111, e.g.:

+0.11111 + -0.234 + 0o123

0.11111 + +0.123 + 0o123

Based on a comment in wwasm.py, we'll have identifiers case-sensitive

Identifiers will be used generally as variables bound to addresses,
but literal values are ok too if the asm adopts syntax to deal with
them.

# sample line:
# @0061.49:140001     w0061: mr   0001      ; multiply and roundoff @@WrittenBy a0045 a0101 ReadBy a0101



Eval
====

Arith binary ops:

binarydot (unary-{+,-}, (literal-{0,1}), literal-digit-seq)		Decimal fraction
binarydot (literal-{0,1}, literal-5-oct-digit-seq)				Octal integer
unary-0o (literal-oct-digit-seq)								Octal integer
literal-digit-seq												Decimal inreger


 0.12345
+0.12345

12/23/24 todo assembler and further
	* auto-comment
	* comment space, alignment -- provide options?
	* write listing
	* Button up file handling
		- Except: Default output for core as stdout?
	* Parens in expr print
			Actually needed! crt-test.ww has (a-b)/3. (was a-b/3 and old asm did not follow std precedence.
			[Fixed with new expr type ParenWrapper; just a pass-through in eval, used only in listing.]
	* Related to last comment looks like bug in old asm forming one's-comp negative numbers. See crt-test.acore versus crt-test.n.ncore
	* Quotes in strings
	* .exec doesn't list properly -- strings in this case don't want quotes
	- flexo translation
		Not sure I have it all right
	- "See .dbwgt for more discussion"
	* Assure all wwasm args are handled in some way
		Yes, with some debate ahead
	* Verbosity and Debuggery
		Doesn't seem to be a need for either in new asm right now, but the flags are available in AsmProgram
	* Bail on "too many" errors
		Let everything run, suppress output files on any errors
	x Hacked wwasm.py to accept comma in .dbwgt
		Backed-out; not needed
	* Case-sensitive? Right now new asm is not at all
		We want case-insens ops and case-sens labels and vars
	- Check range on nextcoreaddress since can overflow 2K as in all1.ww. Right now croaks.
	* Mod and test disasm
	* asm: no-prefx-addr option, to get a pretty-printed source file
		Changed to --MinimalListing
	* --Legacy_Numbers: should go away? Rightnow .org has a mix in the
          code; it's clear some .org numbers are meant to be octal,
          even though they have no 0o prefix. Really should conform to
          std rules and the code with unadorned octal should change.

		  Default octal in Mad-Game? Looks like only for non-address
		  operands (e.g., si). All addresses use symbolic
		  labels. Modified mad-game by copying to .n version and using
		  explicit designators for all octal numbers. Got same results
		  as asm.

		  So right now I favor a bit of extra editing versus reading
		  options.

		  [Yes we agreed it should go]

    * annotate io dev: no reason it shouldn't be default, no option, with auto-comment?
		Done, but it broke idempotency! Fixed that.
	* .wwfile really wants quoted strings -- i.e., expect a var
		All Code-Samples modified thus in .n.ww versions
	- Can probably be more elegant in AsmLabelTab by subclassing dict.
	* Why does core file have 7-oct width?
		Guy thinks because he first wanted to encode the memory bank.
	- Note crt-test has runtest.n.sh, but the drawing output has not
		  been validated against fixes Guy will be supplying.
	* I'l take on a task of updating the asm manual.
		Should be good for now
	- Get rid of yaml files
	* Assure all TestResults* dirs out of git -- ok git in web diff says deleted?
	- Do we need to handle anything special for "overflow" numbers?
      E.g., +1.001. Is there a need to handle this in some way in the
      asm lang?
	- .isa needs prescan? Doc 2.8.3
	- "Preset Params are meant (I think) for doing address assignments
      and calculations, so the values associated with a PP are
      restricted to 0-2047."  This is in asm doc; I currently don't have this restriction.
	- --Logdir -- still active?
	* Clarify C std vis-a-via octal and other number syntax.
		Python does 0o, but C does not
	* Issues with inheritance and *args? See listingString()
		Looks ok -- needed to learn more about *args vs **kwargs
	- Two .print insts in a row cause a comma-expected syntax bug (in sim)
	- Unterminated string seems to crash asm tokenizer
	- C-ish
	- How does float dv work? Can't find anything that matches this
	  algorithm. The fixed-point-30 lib does not implement dv.
		Appears to be Taylor series of 1/(a+b), two terms.
	* Shifts in lz
	* Rename new asm to be current; appropriate rename old prog and stuff if desired.
	  		 1/31/25 -- renamed away from .n
	* Range check float input
	- Found a log bug where the stdout logs were continually making
      LogClass instances. Due to not using class var right -- needs
      wrapper, unlike in C++.
	* Tracebranch in sim -- need way to turn off
		Turn on quiet id -d
	* Suppressed undefined-value error -- too noisy.
	* Debugger: added provisions for "real" debugger by adding a
      SymToAddr table to the sim; it already has an addr-to-sym table,
      SymTab. Also moved wwasmparser.py to Common.
	* Debugger investigation shows the .print tokenizer produces a fatal error. Can we change?
		Changed to error
	* Print floats with scientific notation or the eqv of C's "g" format.
		Python has "g".  Now printing 30,15 floats with 10 digits and 24,6 floats with 8 digits
	- Hoist cpu class so we can share with dbg
	- Show .print etc in dbg. Right now just shows ww insts
	- Get rid of need for dummy parsed line in dbg
	- Dbg doesn't handle signals
	* bounce test (and the one in code-samples) has a .org 1. This
	  doesn't seem right. Fixed the test but not the code-sample.
		[Guy says this is what the original code did.]
	- Asm syntax errors need work. Need better check for unbal'ed
	  parens, and identifying specific clause types in errors,
	  e.g. xyz* gives comma-op syntax error, which is misleading.
	* Trap float overflow in conversion and return inf.
	- Dbg bug in printing AC and prob other regs -- wrong signs. Trying printing neg number.
	- Dbg bug in rs if do rs before running.
	* Dbg possible enhs: watch-for-write (addr); allow a mem loc to be set
			[Watch-write done,
			 Write-loc done.]
	* Dbg: added tb (traceback)
	* Dbg: Added bp disable/enable
	* Dbg: made "p" print single locs and blocks
	* Send Knuth info we have for any insights
	* Added -r (readable section) to flex converter
	x Made ! be the stop char -- but not really needed
		[Backed out -- not needed.]
	* Added - for stdin to flex convertor. That and the same additionm to
	  sim allows here-docs and thus easier testing of L&Z.
	* sim accepts - for std in for papter tape file, so can easly run tests
	- Float (actually 30,0) printer -- what's the qp instruction?
	- Issues remaining with L&Z:
		* Parens not compleletly working
			[Fixed -- was issue in translated ascii to flex]
		* Divide seems broken overall (more than just the inaccurate spax divide)
		  	[Fixed -- prob same flex issue. But we still have
		  	 inaccurate spax dv and can crash on some tests.]
		- Float printer, flexo device
	* Fixed precedence of | and &
	* Question about one's-comp at asm level -- I'm not in favor
		[Seems resolved that we'll keep it as-is]
	- Add debugger section to doc
	- Update doc with new asm comment-fmt options
	- Consider .print control, to turn them on and off easily and in
	  apprpropriate context. Tried adding asm --OmitDotPrint, which
	    takes them out of the core and listing, but does not seem useful so removed.
	- .if -- emit in listing if --Reformat
	* Better heuristics for semicolon-formatting in asm listing. There
	  should be a way to get commented-out code to look "natural"
		Looks a bit better now, but...
	- Asm listingString() and formatComment()
	   have a lot of hacks and should be replaced by a proper FSM scanner.
	* Asm cb.log in infra -- not defined. Eg try unknown flex char
	* !!! Asm .flex broken -- not incrementing address!!??
		[Yes, it was not. Fixed.]
	* Note rc for flex takes high end of word for flex code. If shift in ww need to clc.
	- Asm .flex needs to understand "\n" and maybe other chars in strings
	  so proper flex code is generated. Also handle shift, color,
	  superscript numbers.
	- Flexowin -- check noxwin flag
	- .float does not detect all out-of-range cases -- try .float +0.1,20
	- .float gets wrong nunmber if use too many digits, eg .float
	  +0.99999995, 0 => 0.99999994, but .float +0.99999999, 0 =>
	    -0.99999994





	- Get "everything" into git: tape images, images on code, etc.
		Did sizing run see below marked 1/1/25
	* LAS: work on L&Z? Maybe just use new translator and asm?
	- LAS: disasm, C-ish compiler, ...? Where are we wrt to "musesum-ness"
		- One goal is historical research and perhaps a paper on the
		  code we've found and resurrected.
		- Another may be museum exhibits -- esp. hardware currently under dev.
	- How can we characterize the kind of code that was written for ww?
		What about SAGE? Same instruction set? The whole interpretive
		"VM" thing seems to have been pushed hard in the MIT
		setting. What about in practice, wherever that might have
		been?
	- Put together a set of graphics windows that represent the set of
		i/o devices, e.g., a window for the flex printer, perhaps
		another for paper tape, etc.  These would be similar to the
		scope window.


1/12/25
Procedure call and other compilation notes
==========================================

- Stack starts at highest addr and grows down

- Args are pushed on the stack

- When entering a proc, a frame is pushed. Original stackp - n is the
  nth arg (one-based). stackp + n (zero-based) is local var.

- Consistency of td vs ta

- Idiom: Establish an instruction like  ca <initial-addr>, then just ao
  to that instruction to bump a table loc.

- Did rel-addr lib, stack-frame-rel-addr-lib.ww. Complicated! Probably
  better is to save all writeable words on stack and restore on exit.

- Could do k = *p++, where p is a ca instruction. 

2/2/25
Finding dv error in float-lib, note to Guy:

I studied the instruction set and other doc more deeply and so far I
conclude that the behavior described where BR is always positive is in
fact correct. When I think about the difficulty of building hardware
at the time it makes some sense to me. One's complement provides a way
to do addition and subtraction on a common representation of both
positive and negative numbers, but mult and div are still harder with
signed arithmetic. Hence for those operations the hardware converts to
mag form and back again. The B reg is the extender for operations that
spill over a word, and does not need to have the complement logic
built in; this may seem trivial now but then it was an expense.  I
recall, but vaguely now, similar issues when I did signal processing
hw in school, in the SSI/MSI TTL days.
 
Anyway at this point I've turned off the flags that cause negation of
BR, so vibrating-string works ok. I haven't looked at the L&Z issues
yet, but rather dove back into the float lib, to see if these
revelations cast any light on the troubles there. In doing tests and
looking at traces and sim code, I have not found any sim errors in sf,
shifts, add, and so forth. I tested dv on normal ww fractions and it
looks ok.
 
So I then dug into tracing the float-lib dv, and made I think a little
headway, but nothing really solid yet. Where it says:
 
                           ;       Form (2**-2/x**2)' (Use Euclid's algorithm)
 
which starts at r41, there seems to be an error in the note, and it
should say (2**-2/x2)', i.e., it's not something squared. There is
also an error in another note, for the code starting at 37, where it
should be just x2 and not x2**2.
 
The Euclid part is due to using dv to get bits which are then used to
get floor and remainder, for the lower bits of the reciprocal. Just
what the exact calc is here I'm still trying to figure out. The "su
17r" at 44 is really suspicious. 17r contains "ca 0", which is
executed but never written, just read for its value, which is
-32767. Issues arise when the low bits in the original floating
divisor are zero.  We do 0 - -32767 = 32767, then add one to that, and
kaboom. This is a common case; the test I used which crashes is
float1/float2. It may be doing some kind of rounding.
 
By playing with this and adding less than 32767, more tests like sqrt2
run.  One problem is that aspects of the code are position-dependent,
in that calc of dispatch addresses and such depend on fixed offsets of
certain words. So one has to be careful inserting code.
 
I'm pretty sure the overall formula for finding the reciprocal follows
the Taylor series for 1/(a + b), which expands via Alpha as:
 
1/(a+b) = 1/a - b/a^2 + b^2/a^3 - b^3/a^4 + ...
 
It uses the first two terms, which accounts for the x-squared, but it
really threw me off that the notes seem incorrect.
 
Anyway I haven't found the problem yet but making progress.
 
 - Larry

----------------------------------------------------------------------
1/1/25
The mounted shared whirlwind google drive:
pwd
/cygdrive/g/.shortcut-targets-by-id/1-7fYz-kOky_lqe_lvHZ0YBBHz-ikIffj/Whirlwind
du -s -k -h *
42M	Catalogues-and-Indices
73M	Code-Samples-Local
311K	Dave-Walden-WW-Report-R221.pdf
258M	GitHub
18M	HNF-Git
93M	Hardware
1.0K	How-to-Make-a-Release.txt
9.5M	Images
219K	JavaSim
232M	Mag-Tapes
70M	Paper-Tapes
2.4M	Papertape-Decitek-Reader-Punch
923K	Partners
1.1G	Photos
277M	Py-Local
1.5G	Scanned-Docs
56M	SimH
9.1G	Static-Document-Files
2.1M	Whirlwind-Python-Guy-Oct01-18.zipx
14K	Whirlwind-Q-tmp-Oct12-17.docx
366M	guy
1.0K	rsync-to-pi.sh
1.0K	rsync-to-pi.sh~

M-2539-2 Comprehensive System manual
====================================

Section														Pdf page
-------														--------

introduction													5

part i. intro to programming and coding							10

chapter i the cs computer -- simplified version					11
chapter ii transfer of control -- counting						19
chapter iii cycle counters -- modification of addresses			27
chapter iv floating addresses									35
chapter v input and output										43
chapter vi errors and post-mortems								60
chapter vii subroutines											65
				preset parameters								74
chapter viii review												79

part ii. advanced coding techniques								90

chapter ix some more fundamentials								91
chapter x number systems										96
chapter x1 the whirlwind [i] computer							107
chapter xii auxiliary storage and in-out equipment				132
chapter xiii programmed arithmetic								148
chapter xiv the conversion program								167
				ditto											194
chapter xv the utility control program							202
chapter xvi automatic input-output requests [output]			224
chapter xvii generalized post-mortems							241


2/6/25
Conditional exec
================

It was not my intent to be dismissive of the conditional-exec ideas,
and separate from the debugger idea we can consider some sort of
conditional printing. I don't support allowing more Python in the asm
language. We could easily do .printif:

	.printif Debug, "X = %d", X

where Debug can be a .pp symbol or somethig set of the cmd line. We
could similarly do .execif:

	.execif Debug, blah()

Doing a general .if is also possible, e.g.:

	.if Debug, .print "X = %d", X
or
	.if Debug, .exec blah()

These latter forms break the current syntax, but not fatally and I
could probably fit them in.

2/26/25
Debugger Doc
============

The debugger is invoked as follows:

python wwsim.py --Debugger x.acore
python wwsim.py -d x.acore

To my surprise, the -d option wasn't taken!

Invoking -d automatically turns on "very quiet" mode, i.e., no info is
printed like branch-forward, branch-backward, etc. I found this output
too noisy when using the debugger.

The help output is:

dbg 10> h
p expr [, block-len] [, format]
          Format = o: octal, d: decimal, fr: fraction, fl: 24,6 float, fm: 30,15 float, fx: flexo-to-ascii, i: instruction.
          Print an address or block and its contents, or just the value if a register is specfied.
          Default format is octal.
r
          Run program from current pc
s
          Step program one instruction. Typing carriage-return does this too.
rs
          Restart program
b addr1,...,addrN
          Define a breakpoint for each given address. Prints id and corresponding address.
bl
          List breakpoints and watchpoints.
bd id-range1,...,id-rangeN
          id-range = id-num | id-num1 - id-num2 | all
          Delete breakpoint or watchpoint defined by each given id, id range, or all.
          E.g.:
          bd 0-4, 7, 8-10
          bd all
bdis id-range1,...,id-rangeN
          Disable breakpoint or watchpoint defined by each given id, id range, or all.
bden id-range1,...,id-rangeN
          Enable breakpoint or watchpoint defined by each given id, id range, or all.
tb [n-insts]
          Traceback: history of instructions, latest at the bottom.
          Prints n-insts; default (and max) is 100.
wwr [addr1,...,addrN]
          Watch for memory write. When any write instruction (ts, td, ta, ao, ex)
          is executed which writes at one of the given addresses, break.
          Prints watchpoint id and corresponding address.
h
          Print help
quit
          Exit debugger and simulator
dbg 10>

Issues/Notes:

- rs doesn't actually restart, just goes to the beginning, and you
  then have to type r. There may be other issues with it
  too. Generally, I tried to be minimally invasive in the sim's
  control loop, and there might be a few cracks.

- Printing registers has bugs, like negative numbers are wrong when
  printed in decimal.

- .print and .exec will not appear, nor are they executed, at a
  breakpoint. You need to step or run from there to get that
  executed. This is something we can potentially fix, i.e., these would
  be treated as executable statements by the debugger.

- In the sim code, I added a few "helper functions" to pass to the
  debugger, to get info from the sim. We should abstract out at least
  the Cpu class so I don't need all those functions, so that is on the
  to-do list. Note though that these additional functions don't
  interfere with the sim, so I still consider the changes I needed to
  be mininal. But at least python implements closures, so these
  functions work!

- From an implementation standpoint, this is a separate module, with
  an interface class for the sim to initiate control. We are thus be
  able to avoid lots of symbol contamination in the sim itself.


Notes to Knuth
==============

(Combined Larry and Guy letter)

Greetings Dr Knuth,

  My colleague Larry Stabile and I have been working in conjunction
  with the Computer History Museum and the MIT Museum to restore to
  operation software from the 1950's Whirlwind computer built at MIT.
  You can see some of this work at
  https://ieeexplore.ieee.org/document/9312479

  Recently, we came across a copy of Laning and Zierler's algebraic
  interpreter, along with your notes analyzing operation of the
  code. After much analysis, transcription, and debugging, we've been
  able to get the code to execute in simulation, evaluating a few
  simple expressions. We were helped immensely by your detailed notes
  and markup of the hand-written listing. There's lots more to do to
  validate some of the less-traveled parts of the program, but it's
  certainly showing signs of life.

  Your notes point out a bug in the code, that a = -b comes out as a =
  1-b. This bug is present in the code we ported. You mentioned "See
  Laning's letter." We cannot find this letter; any insight you may
  have into this will be greatly appreciated.

  The code overall is very inventive and effectively defines an
  interpretive virtual machine of ww instructions; primarily this
  supports fundamental floating point operations, but it's also used
  to support higher-level operations like exponentiation by an
  integer, within the L&Z system. This seems to us an extraordinary
  leap early in the history of computers.

  This effort has also triggered an interest in learning more about
  the context and impact of L&Z's work.  Obviously you thought it was
  important enough at one point to dig into it at some depth.  Do you
  recall why, or if you published anything on your findings?

  I know that there has been some debate over L&Z's impact on Fortran,
  with J Backus first saying that Fortran had been influenced by L&Z,
  then after a more careful study of the timelines, revising the
  opinion to say he couldn't find a specific example where L&Z had
  influenced early Fortran.  I am not surprised that the actual
  interactions were hard to disentangle years later.

  But I wonder if you were left yourself with some impression of the
  reach of L&Z's work...  I believe that Hal Laning himself refined
  the ideas for years on the Apollo Guidance Computer project, but do
  you know if the original L&Z work had impact outside of MIT?

  Finally, in looking at your own notes on the program, I have to
  assume, that given the dates, you would never have seen the program
  actually working...  That, coupled with an unusual instruction set,
  must have made the paper analysis of the code a very challenging
  undertaking!


Coding Idioms
=============

These are code "patterns," mostly found in ww code but some invented
by Guy or Larry.

This tests for x == 0 (seen in frac printer):
	cm x
	su 0
	cp a	; Branch if x is zero


Pattern for a for-loop, executing stuff N times, where N is
non-negative:

	  cs N
	  ts cntr
loop: ao cntr
	  cp cont
	  sp done
cont: stuff
	  sp loop
done: ...

This pattern shows how one's-complement needs to be used with care,
since it's not what we're used to nowadays. When cntr gets to -1,
adding one via ao produces -0.  -0 still checks as negative so the
loop continues. On the next loop adding one to -0 produces 1, and the
loop ends. Thus stuff is executed N times.

