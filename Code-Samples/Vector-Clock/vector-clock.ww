
; Vector clock to run on Whirlwind

      .org 0
zero:     .word 0   ; these are set automatically
one:      .word 1      

;  DISPLAY POINTS 0600 TO 0677 (octal)
      .org 0o40
main:     ca 0
          sp refresh_screen
          sp update_time
          ; si 0         ; halt after one pass
          sp main
          

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;; Update the current time of day ;;;;;;
; call this once per second
; output is the three vars, cur_sec, cur_min, cur_hour

update_time:
          ta ut_ret_sp        ; this points to the actual return instruction
                              ; but there's some common code at the end of the routine, so the other
                              ; branches all go to ut_ret
          
          ao cur_sec          ; increment seconds and check for overflow
          ts cur_sec
          su sixty
          dm 0
          cp i_ut_new_minute
          sp ut_ret           ; if the seconds don't overflow, we're done
          
i_ut_new_minute:
          ca 0
          ts cur_sec
          
          ao cur_min
          ts cur_min
          su sixty
          dm 0
          cp i_ut_new_hour
          sp ut_ret           ; if the minutes don't overflow, we're done
          
          
i_ut_new_hour:          
          sp ut_ret

ut_ret:          
          ca 0
          .print "New Time hour=%d; min=%d; sec=%d", cur_hour, cur_min, cur_sec
ut_ret_sp:          
          sp 0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;  Redraw the screen  ;;;;;;;;;;;;;;;;;
; Input params are hour, minute, second
cur_sec:  .word 0
cur_min:  .word 0
cur_hour: .word 0

refresh_screen:
          ta rs_ret
          sp draw_ring
          sp draw_seconds_hand
          sp draw_minutes_hand
          ; sp draw_hours_hand
rs_ret:   sp 0


draw_seconds_hand:
          ta br_ds_ret

          ca 0        ; seconds hand starts from the origin, (0,0)
          ts dv_arg_x1
          ts dv_arg_y1

          ca point_99
          ts rtt_arg_scale
          ca cur_sec  ; load the table offset into AC
          sp read_trig_table  ; then call the routine to index the table and fetch (x, y)
          
          ca rtt_x
          ts dv_arg_x2
          ca rtt_y
          ts dv_arg_y2
          sp draw_vector
br_ds_ret:
          sp 0
          

draw_minutes_hand:
          ta br_dm_ret
          
          ca point_99
          ts dth_arg_len_scale
          ca cur_min
          ts dth_arg_angle
          ca two
          ts dth_arg_width
          sp draw_triangle_hand

br_dm_ret:
          sp 0
  


draw_hours_hand:
          ta br_dh_ret
          
          ca point_75
          ts dth_arg_len_scale
          ca cur_sec
          ad four
          ts dth_arg_angle
          ca four
          ts dth_arg_width
          sp draw_triangle_hand

br_dh_ret:
          sp 0
  

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;; Subroutine draw_triangle_hand ;;;;;;;
; draw a clock hand in the shape of a triangle centered
; at the origin and rotated by the appropriate time offset
; in the range 0-59.
; The assumption is that we'll draw a triangle with the "point" indicating the
; current time, and a tail of the hand offset the in the opposite direction on 
; the clock face.
; Args give
;   - the rotational angle
;   - the relative length of the hand, as a fraction of the outer ring dimension
;   - the width of the hand, given in units of offset rotation (i.e., 2 or 4)
dth_arg_angle:     .word 0
dth_arg_len_scale: .word 0
dth_arg_width:     .word 0

draw_triangle_hand:
          ta br_dth_ret
          
          ca dth_arg_len_scale
          ts rtt_arg_scale      ; set the scale factor for values returned from the trig table lookup
          mr point_20
          ts dth_tail_scale     ; set the length of the tail for the triangle hand
          
          ; compute the left tail end of the triangle hand
          ca dth_arg_angle  ; load the table offset into AC
          ad thirty
          su dth_arg_width
          sp read_trig_table  ; then call the routine to index the table and fetch (x, y)
          ca rtt_x
          mr dth_tail_scale
          ts dv_arg_x1
          ts dth_tail_x2
          ca rtt_y
          mr dth_tail_scale
          ts dv_arg_y1
          ts dth_tail_y2

          ; compute the point of the minutes hand
          ca dth_arg_angle  ; load the table offset into AC
          sp read_trig_table  ; then call the routine to index the table and fetch (x, y)
          
          ca rtt_x
          ts dv_arg_x2
          ca rtt_y
          ts dv_arg_y2
          sp draw_vector  ; draw the left-hand edge of the minutes hand
          
          ; compute the right tail end of the triangle hand
          ca dth_arg_angle  ; load the table offset into AC
          ad thirty
          ad dth_arg_width
          sp read_trig_table  ; then call the routine to index the table and fetch (x, y)
          ca rtt_x
          mr dth_tail_scale
          ts dv_arg_x1
          ts dth_tail_x1
          ca rtt_y
          mr dth_tail_scale
          ts dv_arg_y1
          ts dth_tail_y1

          ; (re)compute the point of the triangle hand  (this lookup could be optimized out!)
          ca dth_arg_angle  ; load the table offset into AC
          sp read_trig_table  ; then call the routine to index the table and fetch (x, y)
          
          ca rtt_x
          ts dv_arg_x2
          ca rtt_y
          ts dv_arg_y2
          sp draw_vector    ; draw the right hand end of the triangle hand

dth_draw_tail:              ; close the triangle shape with one more line
          ca dth_tail_x1
          ts dv_arg_x1
          ca dth_tail_y1
          ts dv_arg_y1
          ca dth_tail_x2
          ts dv_arg_x2
          ca dth_tail_y2
          ts dv_arg_y2
          ; .print "triangle hand tail: x1=%d y1=%d x2=%d y2=%d", dv_arg_x1, dv_arg_y1, dv_arg_x2, dv_arg_y2
          sp draw_vector

br_dth_ret:
          sp 0

; local variables
dth_tail_x1:  .word 0
dth_tail_y1:  .word 0
dth_tail_x2:  .word 0
dth_tail_y2:  .word 0
dth_tail_scale: .word +0.20
         



; Subroutine draw_ring draws the outer graticule of the clock, with 60
; points, and hour markers every five ticks

; this routine should be updated to use read_trig_table
          ; initialize the loop
draw_ring:
          ta dr_ret
          
          ca point_99
          ts rtt_arg_scale         ; it's a start to using rtt (not done yet!)
          
          ca minutes_ring_pointer  ; initialize the instruction pointers
          td i_ca_x1
          ad 01
          td i_ca_y1
          ca minus59
          ts dr_cnt1     ; initialize the loop counter

          ; Commence the point-drawing loop
          ; Starting with the first, every fifth of the sixty markers should be
          ;   a short vector, while the rest are dots
          ; No args
draw_outer_ring:
          ; start by de-indexing pointers to x & y values
i_ca_x1:  ca 0  
          ts dr_x1
i_ca_y1:  ca 0  
          ts dr_y1
          ao i_ca_y1      ; increment the Y address twice
          ao i_ca_y1
          ao i_ca_x1      ; increment the X address twice
          ao i_ca_x1
         
          ; test the loop counter to see if this is "every fifth"
          ca dr_cnt1        ; pick up the rotational angle around the face
          sp find_mod5      ; compute the modulo-5 remainder
          ; .print "find_mod return %ao"
          cp dr_tick        ; branch on neg-zero to draw a tick-mark
          
          ; draw a dot
          ca dr_y1          ; pick up the Y value
          si 0o677          ; select all the scopes; set Y value
          ca dr_x1
          rc 0
          sp outer_ring_dot
          
          ; Draw a tick-mark instead of a dot
dr_tick:  ca dr_x1
          ts dv_arg_x1
          mr point_95
          ts dv_arg_x2
          ca dr_y1
          ts dv_arg_y1
          mr point_95
          ts dv_arg_y2
          sp draw_vector
          
outer_ring_dot:          
          ao dr_cnt1         ; increment the counter
          cp draw_outer_ring   ; loop while the counter is still negative
      
dr_ret:   sp 0            ; end of subroutine
; local vars
dr_x1:    .word 0
dr_y1:    .word 0
dr_cnt1:  .word 0




;; Subroutine draw_vector
; Args are dv_arg_x1 and dv_arg_y1, dv_arg_x2 and dv_arg_y2
; Start by finding the delta-x and delta-y
; Figure out which one is higher magnitude
; Calculate the slope to project the other delta
; Iteratively, turn it into enough short vectors to draw the line
;   Each segment draws up to max_vector distance on the long side of the
;   slope, reduces the remaining delta distance, and moves the origin for the next
;   point to the end of the last vector

;   delta_x = dv_x2 - dv_x1
;   delta_y = dv_y2 - dv_y1
;   if |delta_x| > |delta_y|
;      while delta_x != 0
;          dx = delta_x
;          if (delta_x > max_vector)
;              dx = max_vector
;          dy = delta_y * slope
;          short_vector(dv_x1, dv_y1, dx, dy)
;          dv_x1 += dx
;          dv_y1 += dy
;          delta_x -= dx

dv_arg_x1:    .word 0
dv_arg_y1:    .word 0
dv_arg_x2:    .word 0
dv_arg_y2:    .word 0
draw_vector:
          ta dv_ret       ; save the return address

          ca 0
          ts dv_swap_xy   ; default is to assume that the slope is less than 1.0
          ca dv_arg_x1
          ts dv_x1
          ca dv_arg_y1
          ts dv_y1
          ca dv_arg_x2
          ts dv_x2
          ca dv_arg_y2
          ts dv_y2

dv_calc_slope:          
          ; compute the two deltas and find which one has a larger magnitude
          ca dv_y1
          srr 1             ; divide by two
          ts dv_slope_tmp1
          
          ca dv_y2
          srr 1
          su dv_slope_tmp1
          ts dv_delta_y
          dm 0            ; find magnitude of delta_y
          ts dv_tmp1
          
          ca dv_x1
          srr 1             ; divide by two
          ts dv_slope_tmp1
          
          ca dv_x2
          srr 1
          su dv_slope_tmp1
          ts dv_delta_x
          dm 0            ; find magnitude of delta_x
          su dv_tmp1      ; subtract |y| from |x|
          cp br_dv_y_is_bigger  ; branch if the Y delta is bigger than X
          
br_dv_x_is_bigger:
          ca dv_delta_y      ; calculate the slope
          dv dv_delta_x
          slr 15
          ts dv_x_slope      ; save the slope
          
          ca dv_delta_x
          ts dv_dx            ; copy to the tmp dx
          ca dv_delta_y
          ts dv_dy            ; copy to the tmp dy
          
br_dv_x_loop:
          ca dv_dx            ; fetch the remaining delta
          dm 0               ; subtract zero from the abs value of AC (i.e., make it positive)
          su max_vector      ; test if it's short enough to draw as-is
          cp br_dv_short_x      ; branch if it's short enough to draw as-is
          
          ; the following stanza sets DX to the longest allowed vector, either positive or negative as needed.
          ca dv_dx            ; test the sign of dx
          cp br_dv_neg_dx       ; bramch if negative
          ca max_vector      ; otherwise, change dx to the max +vector
          ts dv_dx
          sp br_dv_calc_y       ; continue to figure dY
          
br_dv_neg_dx:
          ca 0
          su max_vector      ; otherwise, change dx to the max -vector
          ts dv_dx
          
br_dv_short_x:
          sp br_dv_calc_y:   ; I don't think there's anything else to do here...

br_dv_calc_y:          
          ; now figure out the dy value
          ca dv_dx
          mr dv_x_slope  ; multiply the delta_x by the slope
          ts dv_dy


          sp draw_short_vector
          
          ; move the starting point by the dx, dy just used, in prep for the next pass through the loop
          ca dv_y1
          ad dv_dy
          ts dv_y1
          ca dv_x1
          ad dv_dx
          ts dv_x1        ; finished updating for this loop
dv_pre_test_loop_end:
          ; Just testing for Equal isn't a Piece of Cake.  For small numbers, we just subtract one from
          ; the other, then compare the magnitude of the result to zero.  But for numbers larger than 1/2,
          ; that's not so easy; (1 - (-1)) = 2.  
          ; So I'm xor'ing the two numbers first; if the sign bit turns on after the xor, that must mean 
          ; the two numbers have different signs, i.e., they can's possibly be equal
          ; (oops, and this might not work comparing +0 and -0)
          ; Remeber that AC contains dv_x1 at this point
          sd dv_x2
          cp br_dv_x_loop ; go around again
          
dv_test_loop_end:
          ca dv_x1
          su dv_x2        ; test to see if x1==x2; if so, we're done
          dm 0
          cp dv_ret       ; branch if negative zero; we're done
          
          ca dv_x2        ; if we're going around again, update dv_dx.
          su dv_x1        ;  (no need to mess with dv_dy; it's recomputed from the slope
          ts dv_dx
          sp br_dv_x_loop ; go around again
          

          sp dv_ret       ; all done with the x-is-bigger vector

br_dv_loop_exit:
          sp dv_ret

dv_ret:   sp 0


br_dv_y_is_bigger:  ; slope is greater than 1.0, so swap (x, y) 
          ca 1
          ts dv_swap_xy   ; slope is greater than 1.0
          ca dv_arg_x1
          ts dv_y1
          ca dv_arg_y1
          ts dv_x1
          ca dv_arg_x2
          ts dv_y2
          ca dv_arg_y2
          ts dv_x2
          
          sp dv_calc_slope


; local vars
dv_x1:    .word 0
dv_y1:    .word 0
dv_x2:    .word 0
dv_y2:    .word 0

dv_delta_x:  .word 0
dv_delta_y:  .word 0
dv_dx:       .word 0
dv_dy:       .word 0
dv_x_slope:  .word 0
dv_swap_xy:  .word 0     ; swap x & y if this value is non-zero; don't swap if zero
dv_tmp1:     .word 0 
dv_slope_tmp1: .word 0




;; Subroutine to Draw Short Vector
          ; Input Args:
          ; The starting point is assumed to be in dv_x1 and dv_y1
          ; The deltas are in dv_dx and dv_dy
          ; All four numbers are in the same units -- a signed ten-bit number in the top 11 bits of the word
          ; If the dv_swap_xy flag is non-zero, swap x & y to accommodate a vector with slope > 1
          ; Don't change the input args during processing in this routine!
          ; Start by assembling the single word that gives the x and y offsets from the 
          ; vector starting point
draw_short_vector:
          ta dsv_ret     ; store the return address
          
          ca dv_swap_xy ; load the swap bit
          dm 0          ; compare to zero; dm is -0 if the value in dv_swap_xy is +0 or -0, and positive otherwise
          cp dsv_dont_do_swap
          
          ca dv_dx      ; copy incoming args to local vars without swap
          ts dsv_dy
          ca dv_dy
          ts dsv_dx
          ca dv_x1
          ts dsv_y1
          ca dv_y1
          ts dsv_x1
          sp dsv_figure_offset

dsv_dont_do_swap:
          ca dv_dx      ; copy incoming args to local vars without swap
          ts dsv_dx
          ca dv_dy
          ts dsv_dy
          ca dv_x1
          ts dsv_x1
          ca dv_y1
          ts dsv_y1
          
dsv_figure_offset:          
          ca dsv_dx
          slr 5
          md top_6_bits
          ts dsv_vec
          ca dsv_dy
          srr 3       ; shift to lower part of word, preserving the sign bit
          md low_6_bits   ; mask off the unused upper half
          ad dsv_vec   ; this should be an "OR", but no such luck
          ts dsv_vec
          ; draw the vector
          .print "Short Vector: x1=%d; y1=%d; dx=%d; dy=%d; vec=%o", dv_x1, dv_y1, dv_dx, dv_dy, dsv_vec
          ca dsv_y1         ; pick up the Y value
          si 0o1677        ; select all the scopes; set Y value
          ca dsv_x1
          rc dsv_vec

dsv_ret:   sp 0

; local variables
dsv_vec:  .word 0   ; one word for the assembly of the Delta Vector
dsv_dx:   .word 0   ; tmp copies of input args, possibly swapped.
dsv_dy:   .word 0
dsv_x1:   .word 0
dsv_y1:   .word 0



;; Subroutine to calculate modulus
; AC should contain the number to be modulo'd
find_mod5:
          ta ret1
          cp negative_arg
          sp positive_arg
negative_arg:
          sd all_ones   ; invert the negative arg
positive_arg:
          ts fm_arg1       ; save the incoming argument
          dv mod
          slh 9         ; after this instruction, AC contains the Quotient
          mh mod
          slh 6
          su fm_arg1    ; subtract the initial number; this gives the negative of the Remainder
          dm four       ; yeah, ok, the incoming arg is negative and counts up to zero;
          dm zero       ;    but I want the return code to start at zero and count up to four
ret1:     sp 0
mod:    .word 0o05000  ; that's 5/64  
fm_arg1:   .word 0    ; temporary storage for Mod argument
t1:     .word 0


; Subroutine 
; Take an index, nominally 0-59, in AC and index the ring table to find x, y components
; The rtt_arg_scale is a multiplier to be applied to the results of the table lookup
; before returning.
; Computed values are returned in rtt_x and rtt_y

rtt_arg_scale:  .word 0
rtt_x:  .word 0
rtt_y:  .word 0
read_trig_table:
          ta rtt_ret      ; save return address
          
          ts rtt_index    ; store the index so we can do the range-checks with the AC
          
          ; wrap the table index to get it into the 0-59 range
          ; I'm assuming that any out-of-range is less than a full rotation, i.e. we don't
          ; need a modulus operation
          ; Is it bigger than 59?
          ad minus59
          cp rtt_smaller_than_sixty
          su sixty    ; if it's larger than 60, subtract 60 to get it in range
          ts rtt_index
rtt_smaller_than_sixty:
          ; test for less than zero
          ca rtt_index
          su 0        ; make sure if it's zero, it's negative zero; not sure it there's a better way to do this!
          ad one      ; increment by one.  If it was negative zero, this makes it positive; if negative one or 
                      ;   less, the addition will cause it to stay negative
          cp rtt_less_than_zero  ; br is less than zero
          sp rtt_do_lookup
rtt_less_than_zero:
          ad fifty_nine   ; we already incremented the AC by one, so adding 59 more wraps the index in AC
          ts rtt_index
rtt_do_lookup:          
          ca rtt_index
          slr 1       ; double the offset to make a table index
          ad minutes_ring_pointer
          td i_rtt_ca_x1
          ad 01
          td i_rtt_ca_y1
          
i_rtt_ca_x1:          
          ca 0
          mr rtt_arg_scale
          ts rtt_x
i_rtt_ca_y1:
          ca 0
          mr rtt_arg_scale
          ts rtt_y

rtt_ret:
        sp 0
; local vars
rtt_index: .word 0

 
 

;;;;;;;;;;;;  Constants ;;;;;;;;;;;;


two:        .word 2
four:       .word 4
minus59:    .word -59
fifty_nine: .word 59
sixty:      .word 60
twenty_eight:  .word 28
thirty:     .word 30
thirty_two: .word 32
all_ones:   .word 0o177777
point_99:   .word +0.99
point_95:   .word +0.95
point_75:   .word +0.75
point_20:   .word +0.20
top_6_bits: .word 0o176000  ; mask for x vector offset
low_6_bits: .word 0o000374  ; mask for y vector offset
max_vector: .word 0o001740    ; It's five bits (ignoring the sign), offset to end on Bit 10


minutes_ring_pointer:    .word minutes_ring
minutes_ring:
      .word +0.00000
      .word +0.90000

      .word +0.09407
      .word +0.89506

      .word +0.18712
      .word +0.88033

      .word +0.27811
      .word +0.85595

      .word +0.36606
      .word +0.82219

      .word +0.44999
      .word +0.77942

      .word +0.52900
      .word +0.72811

      .word +0.60221
      .word +0.66883

      .word +0.66883
      .word +0.60221

      .word +0.72811
      .word +0.52900

      .word +0.77942
      .word +0.45000

      .word +0.82219
      .word +0.36606

      .word +0.85595
      .word +0.27811

      .word +0.88033
      .word +0.18712

      .word +0.89506
      .word +0.09407

      .word +0.90000
      .word -0.00000

      .word +0.89506
      .word -0.09407

      .word +0.88033
      .word -0.18712

      .word +0.85595
      .word -0.27811

      .word +0.82219
      .word -0.36606

      .word +0.77942
      .word -0.44999

      .word +0.72811
      .word -0.52900

      .word +0.66883
      .word -0.60221

      .word +0.60221
      .word -0.66883

      .word +0.52900
      .word -0.72811

      .word +0.44999
      .word -0.77942

      .word +0.36606
      .word -0.82219

      .word +0.27811
      .word -0.85595

      .word +0.18712
      .word -0.88033

      .word +0.09407
      .word -0.89506

      .word -0.00000
      .word -0.90000

      .word -0.09407
      .word -0.89506

      .word -0.18712
      .word -0.88033

      .word -0.27811
      .word -0.85595

      .word -0.36606
      .word -0.82219

      .word -0.45000
      .word -0.77942

      .word -0.52900
      .word -0.72811

      .word -0.60221
      .word -0.66883

      .word -0.66883
      .word -0.60221

      .word -0.72811
      .word -0.52900

      .word -0.77942
      .word -0.45000

      .word -0.82219
      .word -0.36606

      .word -0.85595
      .word -0.27811

      .word -0.88033
      .word -0.18712

      .word -0.89506
      .word -0.09407

      .word -0.90000
      .word +0.00000

      .word -0.89506
      .word +0.09407

      .word -0.88033
      .word +0.18712

      .word -0.85595
      .word +0.27811

      .word -0.82219
      .word +0.36606

      .word -0.77942
      .word +0.45000

      .word -0.72811
      .word +0.52900

      .word -0.66883
      .word +0.60221

      .word -0.60221
      .word +0.66883

      .word -0.52900
      .word +0.72811

      .word -0.45000
      .word +0.77942

      .word -0.36606
      .word +0.82219

      .word -0.27811
      .word +0.85595

      .word -0.18712
      .word +0.88033

      .word -0.09407
      .word +0.89506


hours_ring:
      .word +0.00000
      .word +0.70000

      .word +0.07316
      .word +0.69616

      .word +0.14553
      .word +0.68470

      .word +0.21631
      .word +0.66573

      .word +0.28471
      .word +0.63948

      .word +0.34999
      .word +0.60621

      .word +0.41144
      .word +0.56631

      .word +0.46839
      .word +0.52020

      .word +0.52020
      .word +0.46839

      .word +0.56631
      .word +0.41144

      .word +0.60621
      .word +0.35000

      .word +0.63948
      .word +0.28471

      .word +0.66573
      .word +0.21631

      .word +0.68470
      .word +0.14553

      .word +0.69616
      .word +0.07316

      .word +0.70000
      .word -0.00000

      .word +0.69616
      .word -0.07316

      .word +0.68470
      .word -0.14553

      .word +0.66573
      .word -0.21631

      .word +0.63948
      .word -0.28471

      .word +0.60621
      .word -0.34999

      .word +0.56631
      .word -0.41144

      .word +0.52020
      .word -0.46839

      .word +0.46839
      .word -0.52020

      .word +0.41144
      .word -0.56631

      .word +0.34999
      .word -0.60621

      .word +0.28471
      .word -0.63948

      .word +0.21631
      .word -0.66573

      .word +0.14553
      .word -0.68470

      .word +0.07316
      .word -0.69616

      .word -0.00000
      .word -0.70000

      .word -0.07316
      .word -0.69616

      .word -0.14553
      .word -0.68470

      .word -0.21631
      .word -0.66573

      .word -0.28471
      .word -0.63948

      .word -0.35000
      .word -0.60621

      .word -0.41144
      .word -0.56631

      .word -0.46839
      .word -0.52020

      .word -0.52020
      .word -0.46839

      .word -0.56631
      .word -0.41144

      .word -0.60621
      .word -0.35000

      .word -0.63948
      .word -0.28471

      .word -0.66573
      .word -0.21631

      .word -0.68470
      .word -0.14553

      .word -0.69616
      .word -0.07316

      .word -0.70000
      .word +0.00000

      .word -0.69616
      .word +0.07316

      .word -0.68470
      .word +0.14553

      .word -0.66573
      .word +0.21631

      .word -0.63948
      .word +0.28471

      .word -0.60621
      .word +0.35000

      .word -0.56631
      .word +0.41144

      .word -0.52020
      .word +0.46839

      .word -0.46839
      .word +0.52020

      .word -0.41144
      .word +0.56631

      .word -0.35000
      .word +0.60621

      .word -0.28471
      .word +0.63948

      .word -0.21631
      .word +0.66573

      .word -0.14553
      .word +0.68470

      .word -0.07316
      .word +0.69616


inner_ring:
      .word -0.00000
      .word -0.20000

      .word -0.02090
      .word -0.19890

      .word -0.04158
      .word -0.19562

      .word -0.06180
      .word -0.19021

      .word -0.08134
      .word -0.18270

      .word -0.09999
      .word -0.17320

      .word -0.11755
      .word -0.16180

      .word -0.13382
      .word -0.14862

      .word -0.14862
      .word -0.13382

      .word -0.16180
      .word -0.11755

      .word -0.17320
      .word -0.10000

      .word -0.18270
      .word -0.08134

      .word -0.19021
      .word -0.06180

      .word -0.19562
      .word -0.04158

      .word -0.19890
      .word -0.02090

      .word -0.20000
      .word +0.00000

      .word -0.19890
      .word +0.02090

      .word -0.19562
      .word +0.04158

      .word -0.19021
      .word +0.06180

      .word -0.18270
      .word +0.08134

      .word -0.17320
      .word +0.09999

      .word -0.16180
      .word +0.11755

      .word -0.14862
      .word +0.13382

      .word -0.13382
      .word +0.14862

      .word -0.11755
      .word +0.16180

      .word -0.09999
      .word +0.17320

      .word -0.08134
      .word +0.18270

      .word -0.06180
      .word +0.19021

      .word -0.04158
      .word +0.19562

      .word -0.02090
      .word +0.19890

      .word +0.00000
      .word +0.20000

      .word +0.02090
      .word +0.19890

      .word +0.04158
      .word +0.19562

      .word +0.06180
      .word +0.19021

      .word +0.08134
      .word +0.18270

      .word +0.10000
      .word +0.17320

      .word +0.11755
      .word +0.16180

      .word +0.13382
      .word +0.14862

      .word +0.14862
      .word +0.13382

      .word +0.16180
      .word +0.11755

      .word +0.17320
      .word +0.10000

      .word +0.18270
      .word +0.08134

      .word +0.19021
      .word +0.06180

      .word +0.19562
      .word +0.04158

      .word +0.19890
      .word +0.02090

      .word +0.20000
      .word -0.00000

      .word +0.19890
      .word -0.02090

      .word +0.19562
      .word -0.04158

      .word +0.19021
      .word -0.06180

      .word +0.18270
      .word -0.08134

      .word +0.17320
      .word -0.10000

      .word +0.16180
      .word -0.11755

      .word +0.14862
      .word -0.13382

      .word +0.13382
      .word -0.14862

      .word +0.11755
      .word -0.16180

      .word +0.10000
      .word -0.17320

      .word +0.08134
      .word -0.18270

      .word +0.06180
      .word -0.19021

      .word +0.04158
      .word -0.19562

      .word +0.02090
      .word -0.19890


markings_ring:
      .word +0.00000
      .word +0.94500

      .word +0.09877
      .word +0.93982

      .word +0.19647
      .word +0.92434

      .word +0.29202
      .word +0.89874

      .word +0.38436
      .word +0.86330

      .word +0.47249
      .word +0.81839

      .word +0.55545
      .word +0.76452

      .word +0.63232
      .word +0.70227

      .word +0.70227
      .word +0.63232

      .word +0.76452
      .word +0.55545

      .word +0.81839
      .word +0.47250

      .word +0.86330
      .word +0.38436

      .word +0.89874
      .word +0.29202

      .word +0.92434
      .word +0.19647

      .word +0.93982
      .word +0.09877

      .word +0.94500
      .word -0.00000

      .word +0.93982
      .word -0.09877

      .word +0.92434
      .word -0.19647

      .word +0.89874
      .word -0.29202

      .word +0.86330
      .word -0.38436

      .word +0.81839
      .word -0.47249

      .word +0.76452
      .word -0.55545

      .word +0.70227
      .word -0.63232

      .word +0.63232
      .word -0.70227

      .word +0.55545
      .word -0.76452

      .word +0.47249
      .word -0.81839

      .word +0.38436
      .word -0.86330

      .word +0.29202
      .word -0.89874

      .word +0.19647
      .word -0.92434

      .word +0.09877
      .word -0.93982

      .word -0.00000
      .word -0.94500

      .word -0.09877
      .word -0.93982

      .word -0.19647
      .word -0.92434

      .word -0.29202
      .word -0.89874

      .word -0.38436
      .word -0.86330

      .word -0.47250
      .word -0.81839

      .word -0.55545
      .word -0.76452

      .word -0.63232
      .word -0.70227

      .word -0.70227
      .word -0.63232

      .word -0.76452
      .word -0.55545

      .word -0.81839
      .word -0.47250

      .word -0.86330
      .word -0.38436

      .word -0.89874
      .word -0.29202

      .word -0.92434
      .word -0.19647

      .word -0.93982
      .word -0.09877

      .word -0.94500
      .word +0.00000

      .word -0.93982
      .word +0.09877

      .word -0.92434
      .word +0.19647

      .word -0.89874
      .word +0.29202

      .word -0.86330
      .word +0.38436

      .word -0.81839
      .word +0.47250

      .word -0.76452
      .word +0.55545

      .word -0.70227
      .word +0.63232

      .word -0.63232
      .word +0.70227

      .word -0.55545
      .word +0.76452

      .word -0.47250
      .word +0.81839

      .word -0.38436
      .word +0.86330

      .word -0.29202
      .word +0.89874

      .word -0.19647
      .word +0.92434

      .word -0.09877
      .word +0.93982


