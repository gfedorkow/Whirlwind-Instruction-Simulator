
                                      ; Tic Tac toe
                                      ; Guy Fedorkow
                                      ; Sep 26, 2024

                                      ; Simple game of tic-tac-toe written in Whirlwind assembly code.
                                      ; The game displays on the WW CRT, and can be played with the light gun
                                      ; (As of Sep 26, it's a two-person game, i.e., i alternates X and O plays)

                                      ; Geometry
                                      ; the basic game board is laid out on a 16x16 grid as follows:

                                      ;  cell 0   | cell 1   |  cell 2
                                      ;  @(4,12)  | @(8,12)  |  @(12,12)
                                      ; --------------------------------
                                      ;  cell 3   | cell 4   |  cell 5
                                      ;  @(4,8)   | @(8,8)   |  @(12,8)
                                      ; --------------------------------
                                      ;  cell 6   | cell 7   |  cell 8
                                      ;  @(4,4)   | @(8,4)   |  @(12,4)

                                      ;----------- old layout ----------
                                      ;  cell 6   | cell 7   |  cell 8
                                      ;  @(4,12)  | @(8,12)  |  @(12,12)
                                      ; --------------------------------
                                      ;  cell 3   | cell 4   |  cell 5
                                      ;  @(4,8)   | @(8,8)   |  @(12,8)
                                      ; --------------------------------
                                      ;  cell 0   | cell 1   |  cell 2
                                      ;  @(4,4)   | @(8,4)   |  @(12,4)
                                      ;-------------------------------

                                      .org 0
                                zero:
@0000:000000                 const_0: .word 0                  ; @@WrittenBy apc_table_ts upc_table_ts a0601 apm_copy_dst a0667 igb_table_ts a1411 a1444 a1647 a1664 a1711 a1727 a1773 a2000 ReadBy ca_addr a0142 dd_y_arg dd_x_arg dc_y_arg dc_x_arg dn_y_arg dn_x1_arg dw_y_arg dw_x_arg dt_y_arg dt_x_arg lgh_x1_arg lgh_y1_arg apc_ca0 upc_ca0 a0555 a0573 a0602 apm_copy_src a0621 a0631 a0640 a0670 a0705 itw_st_ca a0720 itw_cell_ts a0727 a0736 a0744 itw_inc_gb a1055 a1073 a1124 iML_bptr rd_brd1 rd_brd2 a1270 rd_brd3 a1300 a1314 a1332 a1350 a1360 a1363 a1410 a1443 a1575 a1602 a1612 a1623 a1632 a1643 a1650 a1674 a1705 a1712 a1735 a1736 a1761 a1767 a2064 a2070 a2271 a2303 a2326 a2331 JumpedToBy gb_state_sp a0145 a0314 a0331 a0353 a0374 a0416 a0435 a0454 a0464 light_gun_cell_hit_ret a0534 a0564 a0603 a0671 a0672 a1005 a1075 a1252 a1306 a1371 a1423 a1452 a1741 a2017 a2076 a2335
                                 one:
@0001:000001                 const_1: .word 1                  ; @@ReadBy a0102 a0104 a0473 a0532 a0625 a0703 a1242 a1247 a1251 a1305 a1312 a1341 a1402 a1432 a1435 a1651 a1653 a1663 a1713 a1715 a1726 a1755 a1774 a1777 a2277 a2301
@0002:000017                    c_15: .word 15                 ; @@ReadBy a2273
@0003:000040                    c_32: .word 32
@0004:073300            c_scope_edge: .word 950 * 32           ; close to the edge of the scope screen @@ReadBy a0136 a2025
@0005:062000             c_msg_x_pos: .word 800 * 32           ; @@ReadBy a0140


                                      ; constants for SI graphics instruction
                                      .pp scope_vector, 0o1677 ; draw a vector on all scopes
                                      .pp scope_point, 0o0677  ; draw a point on all scopes



                                      .org 0o40


@0040:075054                    main: sp init_game_board

@0041:074043            refresh_loop: sp draw_game_board       ; @@JumpedToBy a0042
                                      ;            si 0
@0042:074041                          sp refresh_loop



                                      ; ************* Refresh the game board display ********************
                                      ; draw the tic-tac-toe grid
                                      ; two horizontal lines first
                     draw_game_board:
@0043:050145                          ta draw_game_board_ret   ; @@JumpedToBy refresh_loop
@0044:105100                          cs const_2
@0045:040152                          ts loop_count
@0046:101103                          ca const_6
@0047:040154                          ts y_arg
                         x_grid_loop:
@0050:101100                          ca const_2               ; @@JumpedToBy a0060
@0051:040153                          ts x_arg
@0052:105110                          cs const_11
@0053:040157                          ts n_segments            ; segment count should be negative, ie, we will incr the value until positive
@0054:074276                          sp draw_x_line

@0055:101107                          ca const_10
@0056:040154                          ts y_arg
@0057:130152                          ao loop_count
@0060:070050                          cp x_grid_loop

                                      ; two vertical lines next
@0061:105100                          cs const_2
@0062:040152                          ts loop_count
@0063:101103                          ca const_6
@0064:040153                          ts x_arg
                         y_grid_loop:
@0065:101100                          ca const_2               ; @@JumpedToBy a0075
@0066:040154                          ts y_arg
@0067:105110                          cs const_11
@0070:040157                          ts n_segments            ; segment count should be negative, ie, we will incr the value until positive
@0071:074315                          sp draw_y_line

@0072:101107                          ca const_10
@0073:040153                          ts x_arg
@0074:130152                          ao loop_count
@0075:070065                          cp y_grid_loop

                                      ; Draw the game_state, ie, dots, naughts, or crosses
                     draw_game_state:
@0076:105105                          cs const_8               ; nine passes; var should be 8; loop count is negative
@0077:040152                          ts loop_count
@0100:100242                          ca gb_table_start
@0101:040147                          ts next_x_addr
@0102:110001                          ad const_1
@0103:040150                          ts next_y_addr
@0104:110001                          ad const_1
@0105:040151                          ts next_gb_state_addr
                             gb_loop:
@0106:100147               gb_x_inst: ca next_x_addr           ; @@JumpedToBy a0131
@0107:040155                          ts x_addr_arg
@0110:100150               gb_y_inst: ca next_y_addr
@0111:040156                          ts y_addr_arg
@0112:100151              gb_gs_inst: ca next_gb_state_addr
@0113:044114                          td ca_addr
@0114:100000                 ca_addr: ca 0                     ; @@WrittenBy a0113
@0115:044116                          td gb_state_sp
@0116:074000             gb_state_sp: sp 0                     ; draw the X, O or dot @@WrittenBy a0115

                                      ; increment pointers and loop count for the next pass
@0117:100147                          ca next_x_addr
@0120:111101                          ad const_3
@0121:040147                          ts next_x_addr
@0122:100150                          ca next_y_addr
@0123:111101                          ad const_3
@0124:040150                          ts next_y_addr
@0125:100151                          ca next_gb_state_addr
@0126:111101                          ad const_3
@0127:040151                          ts next_gb_state_addr
@0130:130152                          ao loop_count
@0131:070106                          cp gb_loop

                 draw_current_player:
                                      ;            ca player_state_x_ptr
                                      ;            ts x_addr_arg
                                      ;            ca player_state_y_ptr
                                      ;            ts y_addr_arg
@0132:100161                          ca which_player          ; see definition for this number
@0133:175104                          md const_7               ; clear the sign bit in case of "Game Over"
@0134:110171                          ad state_msg_tablep
@0135:044142                          td dcp_ca_addr
                                      ; this small strip drew symbols for the player state instead of printing words...  used prior to getting the
                                      ; string-printer to work...
                                      ;dcp_ca_addr: ca 0
                                      ;            td dxp_which_player_sp
                                      ;dxp_which_player_sp:
                                      ;            sp 0        ; call the subroutine to draw an X or O to show which player is on deck

@0136:104004                          cs c_scope_edge          ; set the location to draw a string
@0137:042101                          ts ds_argy
@0140:104005                          cs c_msg_x_pos
@0141:042100                          ts ds_argx
                         dcp_ca_addr:
@0142:100000                          ca 0                     ; get the pointer to the string into ACC @@WrittenBy a0135
@0143:076054                          sp draw_str              ; "print" the string on the screen

@0144:074455                          sp draw_reset_symbol     ; draw the symbol to call for a game reset

                 draw_game_board_ret:                          ; return from the 'board display' subroutine
@0145:074000                          sp 0                     ; @@WrittenBy a0043


                                      ; Global variables
@0146:000000             move_number: .word 0                  ; count the number of moves @@WrittenBy a0563 a1056 ReadBy a0554 a0563

                                      ; ephemeral loop state variables
@0147:000000             next_x_addr: .word 0                  ; @@WrittenBy a0101 a0121 ReadBy gb_x_inst a0117
@0150:000000             next_y_addr: .word 0                  ; @@WrittenBy a0103 a0124 ReadBy gb_y_inst a0122
@0151:000000      next_gb_state_addr: .word 0                  ; @@WrittenBy a0105 a0127 ReadBy gb_gs_inst a0125

                          loop_count:                          ; used only in top-level routines for drawing the game board
@0152:000000                          .word 0                  ; @@WrittenBy a0045 a0057 a0062 a0074 a0077 a0130 a1063 a1071 ReadBy a0057 a0074 a0130 a1071


                                      ; Arguments to pass into routines
@0153:000000                   x_arg: .word 0                  ; @@WrittenBy a0051 a0064 a0073 a0305 a0311 ReadBy a0303 a0306 a0311 a0322
@0154:000000                   y_arg: .word 0                  ; @@WrittenBy a0047 a0056 a0066 a0326 ReadBy a0277 a0316 a0326
@0155:000000              x_addr_arg: .word 0                  ; pointer to x_addr @@WrittenBy a0107 ReadBy a0343 a0363 a0404 a0426 a0445 a0467
@0156:000000              y_addr_arg: .word 0                  ; @@WrittenBy a0111 ReadBy a0335 a0355 a0376 a0420 a0437 a0475
@0157:000000              n_segments: .word 0                  ; @@WrittenBy a0053 a0070 a0312 a0327 ReadBy a0312 a0327
@0160:000000            gb_state_arg: .word 0

                                      ;  Game Play State
                                      ; this var is zero or one to show which player is on-deck for the next move
                                      ; But it can also be set to negative to say "Game Over", or 2 to say Win, three to say Draw/Tie
                                      ; The var, less the sign bit, is used to index player_icon_table below
@0161:000000            which_player: .word 0                  ; @@WrittenBy a0533 a0765 a0770 a1004 a1074 ReadBy a0132 a0333 a0525 a0531 a0546

@0162:000007     player_state_x_addr: .word 7                  ; These two constants control where the X or O indicator lands on the screen
@0163:000001     player_state_y_addr: .word 1
@0164:000162      player_state_x_ptr: .word player_state_x_addr
@0165:000163      player_state_y_ptr: .word player_state_y_addr

                                      ; Static lookup table to find how to draw the current player state
                                      ; The table is a pointer to subroutine entry points
@0166:000167       player_icon_table: .word dct0               ; @@ReadBy a0524 a0545
@0167:000354                    dct0: .word draw_cross
@0170:000375                    dct1: .word draw_naught        ; @@ReadBy a0600 a0666
                                      ;dct2:       .word draw_win
                                      ;dct3:       .word draw_tie

@0171:000172        state_msg_tablep: .word state_msg_table    ; @@ReadBy a0134
                     state_msg_table:
@0172:000177                          .word msg_cross_play
@0173:000210                          .word msg_naught_play
@0174:000221                          .word msg_x_win
@0175:000227                          .word msg_o_win
@0176:000235                          .word msg_draw


                      msg_cross_play:
@0177:000054                          .flexl "P"
@0200:000044                          .flexl "L"
@0201:000006                          .flexl "A"
@0202:000052                          .flexl "Y"
@0203:000002                          .flexl "E"
@0204:000024                          .flexl "R"
@0205:000010                          .flexl " "
@0206:000072                          .flexl "X"
@0207:177776                          .word -1

                     msg_naught_play:
@0210:000054                          .flexl "P"
@0211:000044                          .flexl "L"
@0212:000006                          .flexl "A"
@0213:000052                          .flexl "Y"
@0214:000002                          .flexl "E"
@0215:000024                          .flexl "R"
@0216:000010                          .flexl " "
@0217:000060                          .flexl "O"
@0220:177776                          .word -1

                           msg_x_win:
@0221:000072                          .flexl "X"
@0222:000010                          .flexl " "
@0223:000046                          .flexl "W"
@0224:000014                          .flexl "I"
@0225:000030                          .flexl "N"
@0226:177776                          .word -1

                           msg_o_win:
@0227:000060                          .flexl "O"
@0230:000010                          .flexl " "
@0231:000046                          .flexl "W"
@0232:000014                          .flexl "I"
@0233:000030                          .flexl "N"
@0234:177776                          .word -1

                            msg_draw:
@0235:000022                          .flexl "D"
@0236:000024                          .flexl "R"
@0237:000006                          .flexl "A"
@0240:000046                          .flexl "W"
@0241:177776                          .word -1



                                      ; Game State Variables
                                      ; The Game Table is a nine-entry array that has one entry for each cell of the game board.
                                      ; The position of each cell on the game board is static, but the "state" var shows
                                      ; whether the cell contains a dot, a naught or a cross
@0242:000243          gb_table_start: .word gb0_x              ; @@ReadBy a0100 a0521 a0542 a0575 a0607 a0664 a0715 a1057
                                      ; Game Board State
@0243:000004                   gb0_x: .word 4
@0244:000014                   gb0_y: .word 12
@0245:000332               gb0_state: .word draw_dot
@0246:000010                   gb1_x: .word 8
@0247:000014                   gb1_y: .word 12
@0250:000332               gb1_state: .word draw_dot
@0251:000014                   gb2_x: .word 12
@0252:000014                   gb2_y: .word 12
@0253:000332               gb2_state: .word draw_dot
@0254:000004                   gb3_x: .word 4
@0255:000010                   gb3_y: .word 8
@0256:000332               gb3_state: .word draw_dot
@0257:000010                   gb4_x: .word 8
@0260:000010                   gb4_y: .word 8
@0261:000332               gb4_state: .word draw_dot
@0262:000014                   gb5_x: .word 12
@0263:000010                   gb5_y: .word 8
@0264:000332               gb5_state: .word draw_dot
@0265:000004                   gb6_x: .word 4
@0266:000004                   gb6_y: .word 4
@0267:000332               gb6_state: .word draw_dot
@0270:000010                   gb7_x: .word 8
@0271:000004                   gb7_y: .word 4
@0272:000332               gb7_state: .word draw_dot
@0273:000014                   gb8_x: .word 12
@0274:000004                   gb8_y: .word 4
@0275:000332               gb8_state: .word draw_dot



                                      ; subroutine to draw a horizontal line
                         draw_x_line:
@0276:050314                          ta draw_x_line_ret       ; save the return address @@JumpedToBy a0054
@0277:100154                          ca y_arg
@0300:115105                          su const_8               ; shift from 0-15 axis to -8 to +7
@0301:154014                          slr 12                   ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@0302:001677                          si scope_vector          ; initialize vector gen ; Auto-Annotate I/O: Display Vectors
@0303:100153                          ca x_arg
@0304:115105                          su const_8               ; shift from 0-15 axis to -8 to +7
@0305:040153                          ts x_arg
                          next_x_seg:
@0306:100153                          ca x_arg                 ; re-fetch the next x_arg @@JumpedToBy a0313
@0307:154014                          slr 12                   ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0

@0310:025116                          rc horiz_line_seg        ; Draw a segment with x=ACC
@0311:130153                          ao x_arg
@0312:130157                          ao n_segments            ; increment the segment counter
@0313:070306                          cp next_x_seg
                     draw_x_line_ret:
@0314:074000                          sp 0                     ; @@WrittenBy a0276

                                      ; subroutine to draw a vertical line
                         draw_y_line:
@0315:050331                          ta draw_y_line_ret       ; save the return address @@JumpedToBy a0071
                          next_y_seg:
@0316:100154                          ca y_arg                 ; @@JumpedToBy a0330
@0317:115105                          su const_8               ; shift from 0-15 axis to -8 to +7
@0320:154014                          slr 12                   ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@0321:001677                          si scope_vector          ; initialize vector gen with the y-coord in ACC ; Auto-Annotate I/O: Display Vectors
@0322:100153                          ca x_arg
@0323:115105                          su const_8               ; shift from 0-15 axis to -8 to +7
@0324:154014                          slr 12                   ; gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0

@0325:025117                          rc vert_line_seg         ; Draw a segment with x=ACC
@0326:130154                          ao y_arg
@0327:130157                          ao n_segments            ; increment the segment counter
@0330:070316                          cp next_y_seg
                     draw_y_line_ret:
@0331:074000                          sp 0                     ; @@WrittenBy a0315




                                      ; subroutine to draw a light-gun dot in an unplayed game cell
                                      ; the args into this routine are addresses of x and y locations, not
                                      ; the locations themselves
                            draw_dot:
@0332:050353                          ta draw_dot_ret          ; save return address
@0333:100161                          ca which_player          ; test to see if there's another move allowed
@0334:070353                          cp draw_dot_ret          ; if the var is negative, we're done playing

@0335:100156                          ca y_addr_arg            ; assuming the game's not over, we continue to draw
@0336:044337                          td dd_y_arg
@0337:100000                dd_y_arg: ca 0                     ; @@WrittenBy a0336
@0340:115105                          su const_8
@0341:154014                          slr 12                   ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@0342:000677                          si scope_point           ; initialize point gen with the y-coord in ACC ; Auto-Annotate I/O: Display Points
@0343:100155                          ca x_addr_arg
@0344:044345                          td dd_x_arg
@0345:100000                dd_x_arg: ca 0                     ; @@WrittenBy a0344
@0346:115105                          su const_8               ; shift from 0-15 axis to -8 to +7
@0347:154014                          slr 12                   ; gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@0350:024000                          rc 0                     ; Draw a pont with x=ACC
@0351:014000                          rd 0                     ; read the light gun
@0352:070465                          cp light_gun_cell_hit    ; call a subroutine to handle the light gun.  The gun number is in ACC
                        draw_dot_ret:
@0353:074000                          sp 0                     ; @@WrittenBy a0332 JumpedToBy a0334


                                      ; draw an "X" centered on the screen at the position of the x and y args
                                      ; args are passed as addresses
                          draw_cross:
@0354:050374                          ta draw_cross_ret

@0355:100156                          ca y_addr_arg
@0356:044357                          td dc_y_arg
@0357:100000                dc_y_arg: ca 0                     ; @@WrittenBy a0356
@0360:115105                          su const_8               ; shift from 0-15 axis to -8 to +7
@0361:154014                          slr 12                   ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@0362:001677                          si scope_vector          ; initialize vector gen with the y-coord in ACC ; Auto-Annotate I/O: Display Vectors
@0363:100155                          ca x_addr_arg
@0364:044365                          td dc_x_arg
@0365:100000                dc_x_arg: ca 0                     ; @@WrittenBy a0364
@0366:115105                          su const_8               ; shift from 0-15 axis to -8 to +7
@0367:154014                          slr 12                   ; gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0

@0370:025120                          rc diag_up_right_seg     ; Draw a segment with x=ACC
@0371:025121                          rc diag_dn_left_seg      ; Draw a segment with x=ACC
@0372:025123                          rc diag_up_left_seg      ; Draw a segment with x=ACC
@0373:025122                          rc diag_dn_right_seg     ; Draw a segment with x=ACC
                      draw_cross_ret:
@0374:074000                          sp 0                     ; @@WrittenBy a0354

                                      ; draw an "naught" (i.e. a diamond) centered on the screen at the position of the x and y args
                                      ; args are passed as addresses
                         draw_naught:
@0375:050416                          ta draw_naught_ret

@0376:100156                          ca y_addr_arg
@0377:044400                          td dn_y_arg
@0400:100000                dn_y_arg: ca 0                     ; @@WrittenBy a0377
@0401:115105                          su const_8               ; shift from 0-15 axis to -8 to +7
@0402:154014                          slr 12                   ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@0403:001677                          si scope_vector          ; initialize vector gen with the y-coord in ACC ; Auto-Annotate I/O: Display Vectors
@0404:100155                          ca x_addr_arg
@0405:044406                          td dn_x1_arg
@0406:100000               dn_x1_arg: ca 0                     ; @@WrittenBy a0405
@0407:115106                          su const_9               ; shift from 0-15 axis to -8 to +7; plus an offset
@0410:154014                          slr 12                   ; gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0

@0411:025120                          rc diag_up_right_seg     ; Draw a segment with x=ACC
@0412:025122                          rc diag_dn_right_seg     ; Draw a segment with x=ACC

@0413:111112                          ad const_2_cell          ; shift the x-pos two cells right
@0414:025123                          rc diag_up_left_seg      ; Draw a segment with x=ACC
@0415:025121                          rc diag_dn_left_seg      ; Draw a segment with x=ACC

                     draw_naught_ret:
@0416:074000                          sp 0                     ; @@WrittenBy a0375

                                      ; placeholder to draw a Win symbol centered on the screen at the position of the x and y args
                                      ; args are passed as addresses
                            draw_win:
@0417:050435                          ta draw_win_ret

@0420:100156                          ca y_addr_arg
@0421:044422                          td dw_y_arg
@0422:100000                dw_y_arg: ca 0                     ; @@WrittenBy a0421
@0423:115105                          su const_8               ; shift from 0-15 axis to -8 to +7
@0424:154014                          slr 12                   ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@0425:001677                          si scope_vector          ; initialize vector gen with the y-coord in ACC ; Auto-Annotate I/O: Display Vectors
@0426:100155                          ca x_addr_arg
@0427:044430                          td dw_x_arg
@0430:100000                dw_x_arg: ca 0                     ; @@WrittenBy a0427
@0431:115105                          su const_8               ; shift from 0-15 axis to -8 to +7
@0432:154014                          slr 12                   ; gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0

@0433:025120                          rc diag_up_right_seg     ; Draw a segment with x=ACC
                                      ;          rc diag_dn_left_seg   ; Draw a segment with x=ACC
@0434:025123                          rc diag_up_left_seg      ; Draw a segment with x=ACC
                                      ;          rc diag_dn_right_seg  ; Draw a segment with x=ACC
                        draw_win_ret:
@0435:074000                          sp 0                     ; @@WrittenBy a0417

                                      ; placeholder to draw a Tie symbol centered on the screen at the position of the x and y args
                                      ; args are passed as addresses
                            draw_tie:
@0436:050454                          ta draw_tie_ret

@0437:100156                          ca y_addr_arg
@0440:044441                          td dt_y_arg
@0441:100000                dt_y_arg: ca 0                     ; @@WrittenBy a0440
@0442:115105                          su const_8               ; shift from 0-15 axis to -8 to +7
@0443:154014                          slr 12                   ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@0444:001677                          si scope_vector          ; initialize vector gen with the y-coord in ACC ; Auto-Annotate I/O: Display Vectors
@0445:100155                          ca x_addr_arg
@0446:044447                          td dt_x_arg
@0447:100000                dt_x_arg: ca 0                     ; @@WrittenBy a0446
@0450:115105                          su const_8               ; shift from 0-15 axis to -8 to +7
@0451:154014                          slr 12                   ; gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0

                                      ;          rc diag_up_right_seg  ; Draw a segment with x=ACC
@0452:025121                          rc diag_dn_left_seg      ; Draw a segment with x=ACC
                                      ;          rc diag_up_left_seg   ; Draw a segment with x=ACC
@0453:025122                          rc diag_dn_right_seg     ; Draw a segment with x=ACC
                        draw_tie_ret:
@0454:074000                          sp 0                     ; @@WrittenBy a0436


                   draw_reset_symbol:
@0455:050464                          ta draw_reset_symbol_ret ; @@JumpedToBy a0144
@0456:105104                          cs const_7               ; put the point at game-board coord (1, 1)
@0457:154014                          slr 12
                                      ; ACC contains the coord; use the same number for x and y
@0460:000677                          si scope_point           ; initialize point gen with the y-coord in ACC ; Auto-Annotate I/O: Display Points
@0461:024000                          rc 0                     ; Draw a pont with x=ACC
@0462:014000                          rd 0                     ; read the light gun
@0463:071054                          cp init_game_board       ; call a subroutine to handle the light gun.

               draw_reset_symbol_ret:
@0464:074000                          sp 0                     ; @@WrittenBy a0455



                                      ; ***************************  User Interaction ***********************

                                      ; Handle a user light_gun hit on one of the game cells
                                      ; Remember that this is called only from the routine that draws a
                                      ; dot in the middle of a cell on the game grid.
                                      ; This routine converts the y_address from screen polarity (more positive is up)
                                      ; to Game Board polarity (numbered from top=0 to bottom=2) by subtracting the
                                      ; light gun coord from three.
                                      ; The light gun number is passed to this routine in ACC
                  light_gun_cell_hit:
@0465:050511                          ta light_gun_cell_hit_ret; @@JumpedToBy a0352

@0466:040514                          ts lcl_gun_num
@0467:100155                          ca x_addr_arg
@0470:044471                          td lgh_x1_arg
@0471:100000              lgh_x1_arg: ca 0                     ; load the x value of the cell's address in the grid @@WrittenBy a0470
@0472:160002                          srr 2                    ; divide the cell x address by four to get 1, 2, or 3
@0473:114001                          su const_1               ; change from one-base to zero-base
@0474:040512                          ts lcl_cell_x

@0475:100156                          ca y_addr_arg            ; repeat the process for the y coordinate
@0476:044477                          td lgh_y1_arg
@0477:100000              lgh_y1_arg: ca 0                     ; load the y value of the cell's address in the grid @@WrittenBy a0476
@0500:160002                          srr 2                    ; divide the cell y address by four to get 1, 2, or 3
@0501:031077                          sd const_0n              ; invert to get negative number
@0502:111101                          ad const_3               ; change from one-base to zero-base and invert order
@0503:040513                          ts lcl_cell_y
@0504:155001                          slh 1                    ; multiply y by three, i.e., double then address
@0505:110513                          ad lcl_cell_y
@0506:110512                          ad lcl_cell_x            ; add x to get the cell number in the range 0-8

                                      .print "light gun %o hit x=%o, y=%o, cell=%ao", lcl_gun_num, lcl_cell_x, lcl_cell_y

                                      ; sp alternate_play_cell   ; do something with the light gun hit!; this call is for two-person play
@0507:074536                          sp user_play_cell        ; do something with the light gun hit!  ; this call is for person-vs-computer play

@0510:074676                          sp is_there_winner       ; test to see if it's Game Over

@0511:074000  light_gun_cell_hit_ret: sp 0                     ; @@WrittenBy a0465

                                      ; temp vars for figuring the cell number in light_gun_cell_hit
@0512:000000              lcl_cell_x: .word 0                  ; @@WrittenBy a0474 ReadBy a0506
@0513:000000              lcl_cell_y: .word 0                  ; @@WrittenBy a0503 ReadBy a0505
@0514:000000             lcl_gun_num: .word 0                  ; @@WrittenBy a0466


                                      ; "Play" a cell
                                      ; This routine does a simple two-person-style play; each light gun hit simply alternates
                                      ; between X and O
                                      ; The Cell Number to play is passed in the ACC
                                      ; Note that this routine can only be called on a previously-unplayed cell, 'cause those
                                      ; are the only ones with dots in them, and that's all the light gun can see
                 alternate_play_cell:
@0515:050534                          ta alternate_play_cell_ret

@0516:040535                          ts lcl_aplay_cell_num    ; figure the pointer to the first cell draw function in game table
@0517:155001                          slh 1                    ;  thats table_start + 3*cwll_num + 2
@0520:110535                          ad lcl_aplay_cell_num    ; multiply cell number by three for a table offset
@0521:110242                          ad gb_table_start
@0522:111100                          ad const_2
@0523:044530                          td apc_table_ts

@0524:100166                          ca player_icon_table     ; figure out what the new cell should be
@0525:110161                          ad which_player
@0526:044527                          td apc_ca0
@0527:100000                 apc_ca0: ca 0                     ; ACC should now contain the address of the X or O display routine @@WrittenBy a0526
@0530:040000            apc_table_ts: ts 0                     ; store the display routine to the game state table @@WrittenBy a0523

                                      ; now switch to the other player for the next move
@0531:100161                          ca which_player
@0532:030001                          sd const_1               ; xor a 1 into the LSB; i.e. 0->1 or 1->0
@0533:040161                          ts which_player

             alternate_play_cell_ret:
@0534:074000                          sp 0                     ; @@WrittenBy a0515
@0535:000000      lcl_aplay_cell_num: .word 0                  ; @@WrittenBy a0516 ReadBy a0520



                                      ; This routine plays person against computer; each light gun hit plays an Cross,
                                      ; then the machine plays Naught
                                      ; Note that this routine can only be called on a previously-unplayed cell, 'cause those
                                      ; are the only ones with dots in them, and that's all the light gun can see
                      user_play_cell:
@0536:050564                          ta user_play_cell_ret    ; @@JumpedToBy a0507

@0537:040565                          ts lcl_uplay_cell_num    ; figure the pointer to the first cell draw function in game table
@0540:155001                          slh 1                    ;  thats table_start + 3*cell_num + 2
@0541:110565                          ad lcl_uplay_cell_num    ; multiply cell number by three for a table offset
@0542:110242                          ad gb_table_start
@0543:111100                          ad const_2
@0544:044551                          td upc_table_ts

@0545:100166                          ca player_icon_table     ; figure out what the new cell should be
@0546:110161                          ad which_player
@0547:044550                          td upc_ca0
@0550:100000                 upc_ca0: ca 0                     ; ACC should now contain the address of the X or O display routine @@WrittenBy a0547
@0551:040000            upc_table_ts: ts 0                     ; store the display routine to the game state table @@WrittenBy a0544

@0552:074676                          sp is_there_winner       ; check to see if this user move ended the game
@0553:070563                          cp upc_cleanup           ; negative means it's a tie; no more moves

                                      ; now switch to the other player for the next move
                                      ; table_play_move is used to optimize the first move by a simple table lookup
                                      ; auto_play_move calls minimax to figure the best move, then makes the move
                                      ; by updating the icon on the game board.
@0554:100146                          ca move_number
@0555:134000                          dm 0                     ; test if this is Move Zero, i.e., the first user move
@0556:070561                          cp upc_move_zero         ; branch for first move, fall through for subsequent moves

@0557:074606                          sp auto_play_move
@0560:074563                          sp upc_cleanup

                       upc_move_zero:
@0561:100565                          ca lcl_uplay_cell_num    ; @@JumpedToBy a0556
@0562:074566                          sp table_play_move

                         upc_cleanup:
@0563:130146                          ao move_number           ; @@JumpedToBy a0553 a0560
                  user_play_cell_ret:
@0564:074000                          sp 0                     ; @@WrittenBy a0536
@0565:000000      lcl_uplay_cell_num: .word 0                  ; @@WrittenBy a0537 ReadBy a0541 a0561


                                      ; The first move is optimized to avoid MinMax. by using a Table lookup
                                      ; AC contains the cell number of the first human move
                     table_play_move:
@0566:050603                          ta table_play_move_ret   ; @@JumpedToBy a0562
@0567:040604                          ts lcl_tpm_user_move     ; stash the arg

@0570:101042                          ca first_move_table_start
@0571:110604                          ad lcl_tpm_user_move
@0572:044573                          td tpm_fetch_move_table
                tpm_fetch_move_table:
@0573:100000                          ca 0                     ; fetch the offset of the computer move that will be used to respond @@WrittenBy a0572
@0574:040605                          ts lcl_tpm_table_move
@0575:110242                          ad gb_table_start
@0576:111126                          ad c_2
@0577:044601                          td tpm_store_move
@0600:100170                          ca dct1                  ; this is wired to have the machine move Naught
                      tpm_store_move:
@0601:040000                          ts 0                     ; update the game state table @@WrittenBy a0577
                                      .print "User move to cell %d; Table-driven move to cell offset %d / 3, ts 0o%o 0o%ao", lcl_tpm_user_move, lcl_tpm_table_move, tpm_store_move
@0602:030000                          sd zero                  ; no-op for Print

                 table_play_move_ret:
@0603:074000                          sp 0                     ; @@WrittenBy a0566

                   lcl_tpm_user_move:
@0604:000000                          .word 0                  ; @@WrittenBy a0567 ReadBy a0571
                  lcl_tpm_table_move:
@0605:000000                          .word 0                  ; @@WrittenBy a0574



                                      ; set up to call findBestMove
                      auto_play_move:
@0606:050671                          ta apm_ret               ; @@JumpedToBy a0557
@0607:100242                          ca gb_table_start
@0610:111100                          ad const_2               ; the game piece is offset three from the table start
@0611:044616                          td apm_copy_src
@0612:101232                          ca boardp
@0613:044644                          td apm_copy_dst
@0614:105105                          cs const_8
@0615:040673                          ts lcl_apm_copy_count

@0616:100000            apm_copy_src: ca 0                     ; @@WrittenBy a0611 a0646 a0647 a0650 ReadBy a0646 a0647 a0650 JumpedToBy a0652
@0617:040674                          ts lcl_apm_cell_state

@0620:135016            apm_test_dot: dm dot_fn_addr           ; test if it's a Dot
@0621:134000                          dm 0
@0622:070624                          cp apm_its_a_dot
@0623:074627                          sp apm_test_naught
@0624:131012           apm_its_a_dot: ao lcl_dot_count         ; @@JumpedToBy a0622
@0625:104001                          cs one                   ; store -1 for "unplayed"
@0626:074644                          sp apm_copy_dst

@0627:100674         apm_test_naught: ca lcl_apm_cell_state    ; retrieve the cell state @@JumpedToBy a0623
@0630:135020                          dm naught_fn_addr        ; test if it's an X
@0631:134000                          dm 0
@0632:070634                          cp apm_its_a_naught
@0633:074636                          sp apm_test_cross
@0634:101136        apm_its_a_naught: ca c_oh                  ; load the value for a Naught @@JumpedToBy a0632
@0635:074644                          sp apm_copy_dst

@0636:100674          apm_test_cross: ca lcl_apm_cell_state    ; @@JumpedToBy a0633
@0637:135017                          dm cross_fn_addr         ; test if it's an X
@0640:134000                          dm 0
@0641:070643                          cp apm_its_a_cross
@0642:074672                          sp apm_panic             ; huh, it's not a dot, cross or naught
@0643:101135         apm_its_a_cross: ca c_XX                  ; load value for a cross @@JumpedToBy a0641
                                      ; fall through to finish the copy step

@0644:040000            apm_copy_dst: ts 0                     ; @@WrittenBy a0613 a0645 ReadBy a0645 JumpedToBy a0626 a0635
@0645:130644                          ao apm_copy_dst          ; step the destination once
@0646:130616                          ao apm_copy_src          ; step the source three times
@0647:130616                          ao apm_copy_src
@0650:130616                          ao apm_copy_src
@0651:130673                          ao lcl_apm_copy_count
@0652:070616                          cp apm_copy_src          ; around the loop again
                                      ; finished copying

                                      ; this ought to test who's playing whom, but the code below has the
                                      ; human player wired as Cross, the computer plays Nought
@0653:101136                          ca c_oh
@0654:041137                          ts player
@0655:101135                          ca c_XX
@0656:041140                          ts opponent
                                      ; .exec print_board(cm, rl("boardp"), rl("push_lcl_depth"), rl("player"), "calling findBestMove")
@0657:075752                          sp findBestMove          ; return the cell number for the Best Move in ACC
@0660:040675                          ts lcl_cell_for_move

                                      ; prepare to make the suggested move permanent in the game board
@0661:154001                          slr 1                    ; multiply cell number by three
@0662:110675                          ad lcl_cell_for_move
@0663:111126                          ad c_2                   ; point to cell state in game board table
@0664:110242                          ad gb_table_start
@0665:044667                          td apm_store_move

                                      ; ca player           ;  "player" is (1, 2) for (X, O); offset for player_tab (0, 1) for (X, O)
                                      ; su one
                                      ; ad player_icon_table  ; form a pointer to the icon table
                                      ; td apm_fetch_icon_fn
                                      ; ca dct1                 ; the code above should be "put back" to compute the right icon
                                      ; td apm_fetch_icon_fn

                                      .exec print_experiment(cm, cb, "move game board player %d to cell %d, function 0o%o to gb offset 0o%o", ("player", "lcl_cell_for_move", "apm_fetch_icon_fn", "apm_store_move"), 0)

                   apm_fetch_icon_fn:
@0666:100170                          ca dct1                  ; this address should be dynamically set, not fixed to "naught"
                      apm_store_move:
@0667:040000                          ts 0                     ; @@WrittenBy a0665
@0670:030000                          sd zero                  ; for debug

                             apm_ret:
@0671:074000                          sp 0                     ; @@WrittenBy a0606

                           apm_panic:
                                      .print "not dot, cross or naught in auto_play_move: lcl_apm_cell_state=0o%o", lcl_apm_cell_state
@0672:074000                          sp 0                     ; @@JumpedToBy a0642

                  lcl_apm_copy_count:
@0673:000000                          .word 0                  ; @@WrittenBy a0615 a0651 ReadBy a0651
                  lcl_apm_cell_state:
@0674:000000                          .word 0                  ; @@WrittenBy a0617 ReadBy apm_test_naught apm_test_cross
                   lcl_cell_for_move:
@0675:000000                          .word 0                  ; @@WrittenBy a0660 ReadBy a0662

                                      ;;;;;;;;;;;;;;;;;

                                      ; Analyze game for a winner
                                      ; This is done by counting X and O in each horiz & vert row, plus the two diagonals.
                                      ; The routine is controlled by a table giving the start cell and increment.  For each
                                      ; table entry, we count three cells in the game_board state array
                                      ; This routing contains two nested loops, the outer one that walks the analysis table,
                                      ; and the inner one that counts three cells
                                      ; This long subroutine goes in two parts
                                      ;   a) count what's in each cell on each row, column and diagonal (eight in all)
                                      ;   b) then see if anyone won
                                      ;   [future part c might determine if anyone could win on the next round]
                                      ; The second part also can determine if the game is tied, i.e., no open cells left to play
                     is_there_winner:
@0676:051005                          ta is_there_winner_ret   ; @@JumpedToBy a0510 a0552
                                      ; set up the outer loop
@0677:105104                          cs const_7
@0700:041006                          ts lcl_tb_loop_count
@0701:101021                          ca analysis_table_start  ; prepare pointers into the analysis table
@0702:044711                          td itw_st_ca
@0703:110001                          ad const_1
@0704:044751                          td itw_inc_gb
@0705:104000                          cs const_0               ; initialize with negative zero to simply zero-detect later
@0706:041013                          ts lcl_total_dots        ; count all the unplayed cells

                                      ; set up the inner loop
@0707:105100          itw_outer_loop: cs const_2               ; @@JumpedToBy a0777
@0710:041007                          ts lcl_cell_loop_count
@0711:100000               itw_st_ca: ca 0                     ; load the starting cell number from the table @@WrittenBy a0702 a0772 a0773 ReadBy a0772 a0773
@0712:041014                          ts lcl_cell_number
@0713:155001                          slh 1
@0714:111014                          ad lcl_cell_number
@0715:110242                          ad gb_table_start
@0716:111100                          ad const_2               ; move to the gb_state val in gb table
@0717:044724                          td itw_cell_ts           ; pointer to first entry for this try in the gb table

@0720:100000                          ca const_0
@0721:041010                          ts lcl_naught_count
@0722:041011                          ts lcl_cross_count
@0723:041012                          ts lcl_dot_count

                      itw_inner_loop:
@0724:100000             itw_cell_ts: ca 0                     ; fetch whatever is in this cell @@WrittenBy a0717 a0752 ReadBy a0750 JumpedToBy a0754
@0725:041015                          ts lcl_cell_state
@0726:135016                test_dot: dm dot_fn_addr           ; test if it's a Dot
@0727:134000                          dm 0
@0730:070732                          cp its_a_dot
@0731:074734                          sp test_naught
@0732:131012               its_a_dot: ao lcl_dot_count         ; @@JumpedToBy a0730
@0733:131013                          ao lcl_total_dots

@0734:101015             test_naught: ca lcl_cell_state        ; retrieve the cell state @@JumpedToBy a0731
@0735:135020                          dm naught_fn_addr        ; test if it's an X
@0736:134000                          dm 0
@0737:070741                          cp its_a_naught
@0740:074742                          sp test_cross
@0741:131010            its_a_naught: ao lcl_naught_count      ; @@JumpedToBy a0737

@0742:101015              test_cross: ca lcl_cell_state        ; @@JumpedToBy a0740
@0743:135017                          dm cross_fn_addr         ; test if it's an X
@0744:134000                          dm 0
@0745:070747                          cp its_a_cross
@0746:074750                          sp itw_inner_loop_test_end
@0747:131011             its_a_cross: ao lcl_cross_count       ; @@JumpedToBy a0745

             itw_inner_loop_test_end:
                                      ; move to next cell in the inner loop
@0750:100724                          ca itw_cell_ts           ; @@JumpedToBy a0746
@0751:110000              itw_inc_gb: ad 0                     ; add whatever the analysis table says is the increment @@WrittenBy a0704 a0774 a0775 ReadBy a0774 a0775
@0752:040724                          ts itw_cell_ts
@0753:131007                          ao lcl_cell_loop_count
@0754:070724                          cp itw_inner_loop        ; end of inner loop

                                      ; .print "analysis loop %o, dots=%o, crosses=%o, naughts=%o", lcl_tb_loop_count, lcl_dot_count, lcl_cross_count, lcl_naught_count
                                      ; test to see if there's a winner
@0755:101101                          ca const_3
@0756:135010                          dm lcl_naught_count
@0757:070764                          cp naught_win
@0760:101101                          ca const_3
@0761:135011                          dm lcl_cross_count
@0762:070767                          cp cross_win
@0763:074772                          sp itw_next_outer_loop

@0764:101114              naught_win: ca const_o_win           ; 02 with the sign bit @@JumpedToBy a0757
@0765:040161                          ts which_player          ; mark the game as "over" and a Win
                                      .print "naught win"
@0766:074772                          sp itw_next_outer_loop

@0767:101113               cross_win: ca const_x_win           ; @@JumpedToBy a0762
@0770:040161                          ts which_player          ; mark the game as "over" and a Win
                                      .print "cross win"
@0771:074772                          sp itw_next_outer_loop

                                      ; now move to next entry in outer loop
                 itw_next_outer_loop:
@0772:130711                          ao itw_st_ca             ; @@JumpedToBy a0763 a0766 a0771
@0773:130711                          ao itw_st_ca
@0774:130751                          ao itw_inc_gb
@0775:130751                          ao itw_inc_gb
@0776:131006                          ao lcl_tb_loop_count
@0777:070707                          cp itw_outer_loop

                                      .print "unplayed cells=0o%o", lcl_total_dots
@1000:101013                          ca lcl_total_dots
@1001:071003                          cp its_a_tie             ; negative zero means its a tie (i.e., zero dots found)
@1002:075005                          sp is_there_winner_ret   ; so if it's not negative, we're done

@1003:101115               its_a_tie: ca const_draw            ; table offset 04 with the sign bit @@JumpedToBy a1001
                                      .print "game tie"
@1004:040161                          ts which_player          ; mark the game as "over" and a Draw

                 is_there_winner_ret:
@1005:074000                          sp 0                     ; @@WrittenBy a0676 JumpedToBy a1002


                                      ; local variables
@1006:000000       lcl_tb_loop_count: .word 0                  ; @@WrittenBy a0700 a0776 ReadBy a0776
@1007:000000     lcl_cell_loop_count: .word 0                  ; @@WrittenBy a0710 a0753 ReadBy a0753
@1010:000000        lcl_naught_count: .word 0                  ; @@WrittenBy a0721 its_a_naught ReadBy its_a_naught a0756
@1011:000000         lcl_cross_count: .word 0                  ; @@WrittenBy a0722 its_a_cross ReadBy its_a_cross a0761
@1012:000000           lcl_dot_count: .word 0                  ; @@WrittenBy apm_its_a_dot a0723 its_a_dot ReadBy apm_its_a_dot its_a_dot
@1013:000000          lcl_total_dots: .word 0                  ; @@WrittenBy a0706 a0733 ReadBy a0733 a1000
@1014:000000         lcl_cell_number: .word 0                  ; @@WrittenBy a0712 ReadBy a0714
@1015:000000          lcl_cell_state: .word 0                  ; @@WrittenBy a0725 ReadBy test_naught test_cross

                                      ; static addresses
@1016:000332             dot_fn_addr: .word draw_dot           ; @@ReadBy apm_test_dot test_dot
@1017:000354           cross_fn_addr: .word draw_cross         ; @@ReadBy a0637 a0743
@1020:000375          naught_fn_addr: .word draw_naught        ; @@ReadBy a0630 a0735


                                      ; This table gives the instructions for analyzing each horizontal, vertical
                                      ; or diagonal possible win combinations.
                analysis_table_start:
@1021:001022                          .word analysis_table     ; @@ReadBy a0701
                      analysis_table:
@1022:000000                     at0: .word 0                  ; start cell  ; horizontal cells
@1023:000003                          .word 1 * 3              ; increment
@1024:000003                     at1: .word 3                  ; start cell
@1025:000003                          .word 1 * 3              ; increment
@1026:000006                     at2: .word 6                  ; start cell
@1027:000003                          .word 1 * 3              ; increment
@1030:000000                     at3: .word 0                  ; start cell  ; vertical cells
@1031:000011                          .word 3 * 3              ; increment
@1032:000001                     at4: .word 1                  ; start cell
@1033:000011                          .word 3 * 3              ; increment
@1034:000002                     at5: .word 2                  ; start cell
@1035:000011                          .word 3 * 3              ; increment
@1036:000000                     at6: .word 0                  ; start cell  ; up-right diagonal
@1037:000014                          .word 4 * 3              ; increment
@1040:000002                     at7: .word 2                  ; start cell  ; up-left diagonal
@1041:000006                          .word 2 * 3              ; increment


                                      ; This table identifies a pre-computed machine response
                                      ; to each of the possible first player moves
                                      ; i.e., if the player puts a cross in cell zero, respond
                                      ; with a naught in cell 4.
                                      ; Cell numbers are multiplied by three so they can be used to
                                      ; directly index the game state table.
              first_move_table_start:
@1042:001043                          .word first_move_table   ; @@ReadBy a0570
                    first_move_table:
@1043:000014                          .word 4 * 3              ;  0
@1044:000000                          .word 0 * 3              ;  1
@1045:000014                          .word 4 * 3              ;  2
@1046:000000                          .word 0 * 3              ;  3
@1047:000000                          .word 0 * 3              ;  4
@1050:000006                          .word 2 * 3              ;  5
@1051:000014                          .word 4 * 3              ;  6
@1052:000003                          .word 1 * 3              ;  7
@1053:000014                          .word 4 * 3              ;  8


                                      ;;;;;;;;;;;;;;;;
                                      ; Set all the game board cells to "unplayed"
                                      ; Initialize the game state
                     init_game_board:
@1054:051075                          ta init_game_board_ret   ; @@JumpedToBy main a0463

@1055:100000                          ca zero                  ; Reset the Move Counter to Zero
@1056:040146                          ts move_number

@1057:100242                          ca gb_table_start        ; calculate the offset into the game state table for this cell
@1060:111100                          ad const_2               ; offset to third table entry
@1061:045065                          td igb_table_ts          ; store the pointer to the first entry

@1062:105105                          cs const_8               ; nine passes; var should be 8; loop count is negative
@1063:040152                          ts loop_count
@1064:101076                igb_loop: ca lcl_init_val          ; fetch the address to use for the initial function pointer for each cell @@JumpedToBy a1072
@1065:040000            igb_table_ts: ts 0                     ; set a table entry to the default pointer @@WrittenBy a1061 a1070 ReadBy a1066
@1066:101065                          ca igb_table_ts          ; advance the pointer to the next entry
@1067:111101                          ad const_3
@1070:041065                          ts igb_table_ts
@1071:130152                          ao loop_count
@1072:071064                          cp igb_loop              ; around the loop until we've hit all nine entries

@1073:100000                          ca const_0
@1074:040161                          ts which_player

                                      ;;;;;
                                      ; debug - pre-populate two moves
                                      ;            ca dct0  ; X icon
                                      ;            ts gb0_state
                                      ;            ca dct1  ; O icon
                                      ;            ts gb1_state
                                      ;            ca dct1  ; O icon
                                      ;            ts gb2_state
                                      ;            ca dct0  ; X icon
                                      ;            ts gb3_state
                                      ;            ca dct1  ; O icon
                                      ;            ts gb4_state
                                      ;            ca dct0  ; X icon
                                      ;            ts gb7_state

                                      ;;;;;;
                 init_game_board_ret:
@1075:074000                          sp 0                     ; @@WrittenBy a1054
@1076:000332            lcl_init_val: .word draw_dot           ; @@ReadBy igb_loop

                                      ; ****************************************


                                      ; Constants
@1077:177777                const_0n: .word 0o177777           ; @@ReadBy a0501
@1100:000002                 const_2: .word 2                  ; @@ReadBy a0044 a0050 a0061 a0065 a0522 a0543 a0610 itw_outer_loop a0716 a1060
@1101:000003                 const_3: .word 3                  ; @@ReadBy a0120 a0123 a0126 a0502 a0755 a0760 a1067
@1102:000004                 const_4: .word 4
@1103:000006                 const_6: .word 6                  ; @@ReadBy a0046 a0063
@1104:000007                 const_7: .word 7                  ; @@ReadBy a0133 a0456 a0677
@1105:000010                 const_8: .word 8                  ; @@ReadBy a0076 a0300 a0304 a0317 a0323 a0340 a0346 a0360 a0366 a0401 a0423 a0431 a0442 a0450 a0614 a1062
@1106:000011                 const_9: .word 9                  ; @@ReadBy a0407
@1107:000012                const_10: .word 10                 ; @@ReadBy a0055 a0072
@1110:000013                const_11: .word 11                 ; loop counter for 12 iterations @@ReadBy a0052 a0067
@1111:000014                const_12: .word 12
@1112:020000            const_2_cell: .word 8192               ; decimal value of screen coord corresponding to two cells in width @@ReadBy a0413

@1113:100002             const_x_win: .word 0o100002           ; two plus sign bit @@ReadBy cross_win
@1114:100003             const_o_win: .word 0o100003           ; two plus sign bit @@ReadBy naught_win
@1115:100004              const_draw: .word 0o100004           ; three plus sign bit @@ReadBy its_a_tie


                                      ; these two constants give the delta values to draw a "maximum short vector"
@1116:076000          horiz_line_seg: .word 0o174 * 0o400      ; +32 in the top half of the word
@1117:000174           vert_line_seg: .word 0o174              ; +32 in the bottom half of the word
@1120:076174       diag_up_right_seg: .word 0o174 * 0o400 + 0o174
@1121:100200        diag_dn_left_seg: .word 0o200 * 0o400 + 0o200
@1122:076200       diag_dn_right_seg: .word 0o174 * 0o400 + 0o200
@1123:100174        diag_up_left_seg: .word 0o200 * 0o400 + 0o174


                                      ; ---------------------------------------

                          panic_stop:
@1124:100000                          ca 0                     ; @@JumpedToBy a1400
                                      .print "panic stop"
@1125:000000                          si 0                     ; ; Auto-Annotate I/O: unknown i/o device


                                      ; ;these are the values to be placed in a cell on the board to show
                                      ; who's playing which position
                                      .pp XX, 1
                                      .pp Oh, 2
                                      .pp None, -1

                                      ; Constants
@1126:000002                     c_2: .word 2                  ; @@ReadBy a0576 a0663 a1353 a1355
@1127:177775                    c_2n: .word -2                 ; for a loop of three @@ReadBy a1316 a1334
@1130:000003                     c_3: .word 3                  ; @@ReadBy a1323 a1330 a2313 a2316 a2321
@1131:000004                     c_4: .word 4                  ; @@ReadBy a1346
@1132:177767                    c_8n: .word -8                 ; for a loop of nine passes @@ReadBy a1236 a1634 a1676 a1757
@1133:000012                    c_10: .word 10                 ; @@ReadBy a1365 a1367 a1601 a1611
@1134:001750                  c_1000: .word 1000               ; BigNum @@ReadBy a1630 a1672 a1753
@1135:000001                    c_XX: .word XX                 ; @@ReadBy apm_its_a_cross a0655
@1136:000002                    c_oh: .word Oh                 ; @@ReadBy apm_its_a_naught a0653

                                      ; Global Variables
                                      ;Default state to start the game: player = 'x', opponent = 'o';
@1137:000001                  player: .word XX                 ; @@WrittenBy a0654 ReadBy a1362 a1646 a1772
@1140:000002                opponent: .word Oh                 ; @@WrittenBy a0656 ReadBy a1710



                                      ;#define GAME1
                                      ;#ifdef GAME1
                                      ;    char board[3][3] =
                                      ;     {
                                      ;         { '_', 'o', 'x' },
                                      ;         { 'x', 'o', '_' },
                                      ;         { '_', '_', '_' }
                                      ;     };
                                      ; #endif
                                      ; #ifdef GAME2
                                      ;    // X should win this game in one move, but it will try every possible alternative before figuring it out
                                      ;    char board[3][3] =
                                      ;    {
                                      ;        { '_', 'o', 'x' },
                                      ;        { '_', 'o', 'x' },
                                      ;        { '_', '_', '_' }
                                      ;    };
                                      ; #endif


                                      ; pointers - yuck :-(  This cell points to the first of several board layouts
@1141:000011                BRD_SIZE: .word board3 - board2    ; nine words per each boar layouts
                                      ; BRDS_COUNT: .word -5    ; six test board layouts (so far!)
                                      ; BRDS_COUNT: .word (first_boardp - boardp) / (board3 - board2) + 1    ; six test board layouts (so far!)
@1142:000001              BRDS_COUNT: .word 1                  ; set the count to do just one board


                                      ; Board Layout
                                      ;   0  1  2
                                      ;   3  4  5
                                      ;   6  7  8

@1143:001144            first_boardp: .word board2

                                      ;        { 'x', 'o', 'o' },
                                      ;        { 'x', 'o', 'x' },
                                      ;        { '_', '_', '_' }
@1144:000001                  board2: .word XX                 ; 0
@1145:000002                          .word Oh
@1146:000002                          .word Oh
@1147:000001                          .word XX                 ; 3
@1150:000002                          .word Oh
@1151:000001                          .word XX
@1152:177776                          .word None               ; 6
@1153:177776                          .word None
@1154:177776                          .word None

                                      ; X plays next, but Oh wins in one move
                                      ;        { '_', 'o', 'o' },
                                      ;        { 'x', 'o', 'x' },
                                      ;        { '_', '_', '_' }
@1155:177776                  board3: .word None               ; 0
@1156:000002                          .word Oh
@1157:000002                          .word Oh
@1160:000001                          .word XX                 ; 3
@1161:000002                          .word Oh
@1162:000001                          .word XX
@1163:177776                          .word None               ; 6
@1164:177776                          .word None
@1165:177776                          .word None

                                      ; Test evaluate_board, Rows
                                      ; First row is Not a Win, second row should detect a win by X
                                      ;        { '_', 'o', 'o' },
                                      ;        { 'x', 'x', 'x' },
                                      ;        { 'o', '_', '_' }
                     board_row_x_win:
@1166:177776                          .word None               ; 0
@1167:000002                          .word Oh
@1170:000002                          .word Oh
@1171:000001                          .word XX                 ; 3
@1172:000001                          .word XX
@1173:000001                          .word XX
@1174:000002                          .word Oh                 ; 6
@1175:177776                          .word None
@1176:177776                          .word None

                                      ; Test evaluate_board, Cols
                                      ; First col is Not a Win, second col should detect a win by 0
                                      ;        { '_', 'o', 'x' },
                                      ;        { 'x', 'o', 'x' },
                                      ;        { 'o', 'o', '_' }
                     board_col_o_win:
@1177:177776                          .word None               ; 0
@1200:000002                          .word Oh
@1201:000001                          .word XX
@1202:000001                          .word XX                 ; 3
@1203:000002                          .word Oh
@1204:000001                          .word XX
@1205:000002                          .word Oh                 ; 6
@1206:000002                          .word Oh
@1207:177776                          .word None

                                      ; Test evaluate_board, 2-4-6 diagonal
                                      ;        { '_', 'o', 'x' },
                                      ;        { 'o', 'x', 'o' },
                                      ;        { 'x', 'o', '_' }
                board_2_4_6_diagonal:
@1210:177776                          .word None               ; 0
@1211:000002                          .word Oh
@1212:000001                          .word XX
@1213:000002                          .word Oh                 ; 3
@1214:000001                          .word XX
@1215:000002                          .word Oh
@1216:000001                          .word XX                 ; 6
@1217:000002                          .word Oh
@1220:177776                          .word None

                                      ; X plays next, and 'should' play cell 8
                                      ;        { 'o', 'x', '_' },
                                      ;        { '_', 'o', '_' },
                                      ;        { '_', '_', '_' }
@1221:000002                  board4: .word Oh                 ; 0
@1222:000001                          .word XX
@1223:177776                          .word None
@1224:177776                          .word None               ; 3
@1225:000002                          .word Oh
@1226:177776                          .word None
@1227:177776                          .word None               ; 6
@1230:177776                          .word None
@1231:177776                          .word None


@1232:001221                  boardp: .word board4             ; board2 to scan all the games @@ReadBy a0612 a1234 a1256 a1636 a1700 a1763

                                      ; // This function returns true if there are moves
                                      ; // remaining on the board. It returns false if
                                      ; // there are no moves left to play.
                                      ; bool isMovesLeft()
                                      ; {
                                      ;     for (int i = 0; i<3; i++)
                                      ;         for (int j = 0; j<3; j++)
                                      ;             if (board[i][j]=='_')
                                      ;                 return true;
                                      ;     //printf("IsMovesLeft --> false\n");
                                      ;     return false;
                                      ; }
                                      ; IsMovesLeft returns positive if there are more moves, negative if there
                                      ; are no empty cells
                         isMovesLeft:
@1233:051252                          ta isMovesLeftRet        ; @@JumpedToBy a1620
@1234:101232                          ca boardp
@1235:045240                          td iML_bptr              ; store a pointer to the start of the game board
@1236:101132                          ca c_8n
@1237:041253                          ts iML_cnt
@1240:100000                iML_bptr: ca 0                     ; read the cell under test; If the cell is empty, there are move moves, we can stop @@WrittenBy a1235 a1244 ReadBy a1244 JumpedToBy a1246
@1241:071251                          cp iML_empty             ; branch if the cell is empty, ie, neither X or O.

@1242:100001                          ca one                   ; non-empty cell; prepare to return positive
@1243:041254                          ts iML_ret
@1244:131240                          ao iML_bptr              ; update the pointer to the next cell
@1245:131253                  iML_lp: ao iML_cnt               ; increment the loop count
@1246:071240                          cp iML_bptr              ; branch if not done yet

@1247:104001                          cs one                   ; no empty cells; return -1
@1250:075252                          sp isMovesLeftRet

                           iML_empty:
@1251:100001                          ca one                   ; return One for more moves left @@JumpedToBy a1241

                      isMovesLeftRet:
@1252:074000                          sp 0                     ; @@WrittenBy a1233 JumpedToBy a1250

                                      ; local variables
@1253:000000                 iML_cnt: .word 0                  ; loop counter @@WrittenBy a1237 iML_lp ReadBy iML_lp
@1254:000000                 iML_ret: .word 0                  ; return code @@WrittenBy a1243


                                      ; Helper routine for Evaluate_Board
                                      ; Check three adjacent cells to determine if they have the same player identifier
                                      ; Return the negative of the value if it's the same, or +1 if different (or if all three are -1, unoccupied)
                                      ; The offset from the start of the table is in ACC, the stride is in the "local"
                                      ; variable equ3_arg_stride
                                      ; The return value in the AC is inverted to make the test one level up a step
                                      ; simpler...  -1 or -2 means the row contains all X's or O's, +1 means they're not all
                                      ; the same.  The caller can then branch on negative to determine if the search for
                                      ; a winner is complete.
                                equ3:
@1255:051306                          ta equ3_ret              ; @@JumpedToBy a1321 a1337 a1351 a1356
@1256:111232                          ad boardp                ; add base pointer to the board array to offset
@1257:045260                          td rd_brd1
@1260:100000                 rd_brd1: ca 0                     ; read the first element @@WrittenBy a1257 ReadBy a1263
@1261:071305                          cp equ3_ret_not_equal
@1262:041310                          ts equ3_lcl_first_read   ; remember what's in the first cell

@1263:101260                          ca rd_brd1               ; calculate address for second cell by adding stride
@1264:111307                          ad equ3_arg_stride
@1265:045266                          td rd_brd2
@1266:100000                 rd_brd2: ca 0                     ; read the second element @@WrittenBy a1265 ReadBy a1273
@1267:115310                          su equ3_lcl_first_read   ; compare it to the first element read
@1270:134000                          dm zero
@1271:071273                          cp equ3_brd3             ; negative zero means they're the same; so test the third cell
@1272:075305                          sp equ3_ret_not_equal    ; otherwise, bail out

                           equ3_brd3:
@1273:101266                          ca rd_brd2               ; @@JumpedToBy a1271
@1274:111307                          ad equ3_arg_stride
@1275:045276                          td rd_brd3
@1276:100000                 rd_brd3: ca 0                     ; @@WrittenBy a1275
@1277:115310                          su equ3_lcl_first_read
@1300:134000                          dm zero
@1301:071303                          cp equ3_ret_equal        ; negative zero means they're the same
@1302:075305                          sp equ3_ret_not_equal

                      equ3_ret_equal:
@1303:105310                          cs equ3_lcl_first_read   ; return negative one or two @@JumpedToBy a1301
@1304:075306                          sp equ3_ret

                  equ3_ret_not_equal:
@1305:100001                          ca one                   ; @@JumpedToBy a1261 a1272 a1302
                                      ; fall through to equ3_ret

                            equ3_ret:
@1306:074000                          sp 0                     ; @@WrittenBy a1255 JumpedToBy a1304
                                      ; local vars and arguments
                     equ3_arg_stride:
@1307:000000                          .word 0                  ; @@WrittenBy a1313 a1331 a1347 a1354 ReadBy a1264 a1274
                 equ3_lcl_first_read:
@1310:000000                          .word 0                  ; @@WrittenBy a1262 ReadBy a1267 a1277 a1303




                                      ; // This is the evaluation function as discussed
                                      ; // in the previous article ( http://goo.gl/sJgv68 )
                                      ; int evaluate() {

                                      ;     // Checking for Rows for X or O victory.
                                      ;     for (int row = 0; row<3; row++)
                                      ;     {
                                      ;         if (board[row][0]==board[row][1] &&   // stride = +1
                                      ;             board[row][1]==board[row][2])
                                      ;         {
                                      ;             if (board[row][0]==player)
                                      ;                 return +10;
                                      ;             else if (board[row][0]==opponent)
                                      ;                 return -10;
                                      ;         }
                                      ;     }

                                      ;     // Checking for Columns for X or O victory.
                                      ;     for (int col = 0; col<3; col++)
                                      ;     {
                                      ;         if (board[0][col]==board[1][col] &&  // stride = +3
                                      ;             board[1][col]==board[2][col])
                                      ;         {
                                      ;             if (board[0][col]==player)
                                      ;                 return +10;
                                      ;             else if (board[0][col]==opponent)
                                      ;                 return -10;
                                      ;         }
                                      ;     }

                                      ;     // Checking for Diagonals for X or O victory.
                                      ;     if (board[0][0]==board[1][1] && board[1][1]==board[2][2])  // stride = +4
                                      ;     {
                                      ;         if (board[0][0]==player)
                                      ;             return +10;
                                      ;         else if (board[0][0]==opponent)
                                      ;             return -10;
                                      ;     }

                                      ;     if (board[0][2]==board[1][1] && board[1][1]==board[2][0])   // stride = +2
                                      ;     {
                                      ;         if (board[0][2]==player)
                                      ;             return +10;
                                      ;         else if (board[0][2]==opponent)
                                      ;             return -10;
                                      ;     }

                                      ;     // Else if none of them have won then return 0
                                      ;     return 0;
                                      ; }

                                      ; Evaluate the current board for win, lose or incomplete
                                      ; If it's a Win for the Player, return +10; if it's a Lose for the Player, return -10
                                      ; If the game is undecided, return zero
                                      ; This routine takes no input arguments
                      evaluate_board:
@1311:051371                          ta eval_ret              ; @@JumpedToBy a1576
                        eval_chk_row:
                                      ; check rows for a win; stride of three, starting at zero
@1312:100001                          ca one
@1313:041307                          ts equ3_arg_stride       ; set the equ3 stride to one, i.e., three adjacent horizontal cells
@1314:100000                          ca zero                  ; set the equ3 starting cell to row zero
@1315:041372                          ts eval_lcl_nxt_cell
@1316:101127                          ca c_2n                  ; initialize loop counter; prepare to go around the loop three times
@1317:041373                          ts eval_lcl_loop_count
                       eval_row_loop:
@1320:101372                          ca eval_lcl_nxt_cell     ; place offset of first cell to check in AC @@JumpedToBy a1327
@1321:075255                          sp equ3                  ; check one row
@1322:071362                          cp eval_score_players    ; match -- figure out who won

                    eval_chk_nxt_row:
@1323:101130                          ca c_3                   ; next row is three cells forward
@1324:111372                          ad eval_lcl_nxt_cell     ; compute the first cell of the next row
@1325:041372                          ts eval_lcl_nxt_cell
@1326:131373                          ao eval_lcl_loop_count
@1327:071320                          cp eval_row_loop         ; branch if there's another row to check, fall through if we've checked three rows

                                      ; no one won on rows, so go on to check columns

                        eval_chk_col:
                                      ; check cols for a win; stride of three, starting at zero
@1330:101130                          ca c_3
@1331:041307                          ts equ3_arg_stride       ; set the equ3 stride to three, i.e., three adjacent vertical cells
@1332:100000                          ca zero                  ; set the equ3 starting cell to col zero
@1333:041372                          ts eval_lcl_nxt_cell
@1334:101127                          ca c_2n                  ; initialize loop counter; prepare to go around the loop three times
@1335:041373                          ts eval_lcl_loop_count
                       eval_col_loop:
@1336:101372                          ca eval_lcl_nxt_cell     ; place offset of first cell to check in AC @@JumpedToBy a1345
@1337:075255                          sp equ3                  ; check one row
@1340:071362                          cp eval_score_players    ; match -- figure out who won

                    eval_chk_nxt_col:
@1341:100001                          ca one                   ; next col is one cell forward
@1342:111372                          ad eval_lcl_nxt_cell     ; compute the first cell of the next row
@1343:041372                          ts eval_lcl_nxt_cell
@1344:131373                          ao eval_lcl_loop_count
@1345:071336                          cp eval_col_loop         ; branch if there's another row to check, fall through if we've checked three rows

                                      ; there are only two diagonals, no loops here; just test 0, 4, 8 then 2, 4, 6
                  eval_chk_diagonal0:
@1346:101131                          ca c_4
@1347:041307                          ts equ3_arg_stride       ; set the equ3 stride to four, i.e., 0, 4, 8 diagonal cells
@1350:100000                          ca zero                  ; set the equ3 starting cell to col zero
@1351:075255                          sp equ3                  ; check one row
@1352:071362                          cp eval_score_players    ; match -- figure out who won

                  eval_chk_diagonal1:
@1353:101126                          ca c_2
@1354:041307                          ts equ3_arg_stride       ; set the equ3 stride to two, i.e., 2, 4, 6 diagonal cells
@1355:101126                          ca c_2                   ; set the equ3 starting cell to cell 2
@1356:075255                          sp equ3                  ; check one row
@1357:071362                          cp eval_score_players    ; match -- figure out who won

                                      ; nobody won; return 0
@1360:100000                          ca zero
@1361:075371                          sp eval_ret

                                      ; somebody won; check if it's the Player or Opponent
                                      ; The winner cell is -1 or -2 in AC; convert that to a score (recall equ3 results are inverted)
                                      ; depending on whether who's Player and who's Opponent at the moment
                  eval_score_players:
@1362:111137                          ad player                ; test to see if the current Player is the one that was found to have three winning cells @@JumpedToBy a1322 a1340 a1352 a1357
@1363:134000                          dm zero
@1364:071367                          cp eval_player_win

                        eval_opp_win:
@1365:105133                          cs c_10                  ; score an opponent win as -10
@1366:075371                          sp eval_ret

                     eval_player_win:
@1367:101133                          ca c_10                  ; score a Player win as +10 @@JumpedToBy a1364
@1370:075371                          sp eval_ret

                            eval_ret:
                                      ; .print "  Evaluate_Score returns %ad"
@1371:074000                          sp 0                     ; @@WrittenBy a1311 JumpedToBy a1361 a1366 a1370
                   eval_lcl_nxt_cell:
@1372:000000                          .word 0                  ; @@WrittenBy a1315 a1325 a1333 a1343 ReadBy a1320 a1324 a1336 a1342
                 eval_lcl_loop_count:
@1373:000000                          .word 0                  ; @@WrittenBy a1317 a1326 a1335 a1344 ReadBy a1326 a1344


                                      ; ================  MINIMAX Section =====================

                                      ; Two helper functions to save state for recursive calls
                                      ; to "push" onto the stack, we copy all the local minimax variables to
                                      ; where ever the stack pointer is pointing, then increment the stack
                                      ; pointer by the size of the frame
                         push_minmax:
@1374:051423                          ta push_ret              ; @@JumpedToBy a1574
@1375:041454                          ts push_pop_lcl_acc_stash; stash the AC
@1376:101460                          ca stack_size
@1377:115453                          su push_lcl_depth        ; test to be sure we're not running over the allocated space
@1400:071124                          cp panic_stop            ; branch if overflow

@1401:105456                          cs frame_size
@1402:110001                          ad one
@1403:041455                          ts push_pop_word_count   ; initialize the loop counter
@1404:101457                          ca minimax_retp          ; fetch the "source pointer"
@1405:045410                          td push_src
@1406:101461                          ca stackp                ; fetch the "destination pointer"
@1407:045411                          td push_dst

                            push_src:                          ; copy loop
@1410:100000                          ca 0                     ; filled in above @@WrittenBy a1405 a1412 ReadBy a1412 JumpedToBy a1415
                            push_dst:
@1411:040000                          ts 0                     ; @@WrittenBy a1407 a1413 ReadBy a1413
@1412:131410                          ao push_src
@1413:131411                          ao push_dst
@1414:131455                          ao push_pop_word_count
@1415:071410                          cp push_src              ; around the loop until the entire stack frame is copied

@1416:101461                          ca stackp                ; update the stack pointer for next time
@1417:111456                          ad frame_size
@1420:045461                          td stackp
@1421:131453                          ao push_lcl_depth

@1422:101454                          ca push_pop_lcl_acc_stash; retrieve the AC
                            push_ret:
@1423:074000                          sp 0                     ; subroutine return @@WrittenBy a1374


                          pop_minmax:
@1424:051452                          ta pop_ret               ; @@JumpedToBy a1740
@1425:041454                          ts push_pop_lcl_acc_stash; stash the AC
@1426:101461                          ca stackp                ; back up the stack pointer
@1427:115456                          su frame_size
@1430:045461                          td stackp
@1431:101453                          ca push_lcl_depth
@1432:114001                          su one
@1433:041453                          ts push_lcl_depth

@1434:105456                          cs frame_size
@1435:110001                          ad one
@1436:041455                          ts push_pop_word_count   ; initialize the loop counter
@1437:101457                          ca minimax_retp          ; fetch the "destination pointer"
@1440:045444                          td pop_dst
@1441:101461                          ca stackp                ; fetch the "source pointer"
@1442:045443                          td pop_src

                             pop_src:                          ; copy loop
@1443:100000                          ca 0                     ; filled in above @@WrittenBy a1442 a1445 ReadBy a1445 JumpedToBy a1450
                             pop_dst:
@1444:040000                          ts 0                     ; @@WrittenBy a1440 a1446 ReadBy a1446
@1445:131443                          ao pop_src
@1446:131444                          ao pop_dst
@1447:131455                          ao push_pop_word_count
@1450:071443                          cp pop_src               ; around the loop until the entire stack frame is copied

@1451:101454                          ca push_pop_lcl_acc_stash; retrieve the AC
                             pop_ret:
@1452:074000                          sp 0                     ; @@WrittenBy a1424

                      push_lcl_depth:
@1453:000000                          .word 0                  ; @@WrittenBy a1421 a1433 ReadBy a1377 a1421 a1431
              push_pop_lcl_acc_stash:
@1454:000000                          .word 0                  ; @@WrittenBy a1375 a1425 ReadBy a1422 a1451
                 push_pop_word_count:                          ; this var is the copy-word counter for push and pop
@1455:000000                          .word 0                  ; @@WrittenBy a1403 a1414 a1436 a1447 ReadBy a1414 a1447

                                      ; calculate the size of a single push on the stack
@1456:000007              frame_size: .word minmax_lcl_data_end - minmax_ret; @@ReadBy a1401 a1417 a1427 a1434
                        minimax_retp:                          ; Here's the address of the minimax local data to be pushed onto stack
@1457:001741                          .word minmax_ret         ; @@ReadBy a1404 a1437
                          stack_size:
@1460:000012                          .word 10                 ; I've allocated ten frames below for use of the stack @@ReadBy a1376


@1461:001462                  stackp: .word stack0             ; @@WrittenBy a1420 a1430 ReadBy a1406 a1416 a1426 a1441
@1462:000000                  stack0: .word 0                  ; frame 0
@1463:000000                          .word 0
@1464:000000                          .word 0
@1465:000000                          .word 0
@1466:000000                          .word 0
@1467:000000                          .word 0
@1470:000000                          .word 0
@1471:000000                          .word 0                  ; frame 1
@1472:000000                          .word 0
@1473:000000                          .word 0
@1474:000000                          .word 0
@1475:000000                          .word 0
@1476:000000                          .word 0
@1477:000000                          .word 0
@1500:000000                          .word 0                  ; frame 2
@1501:000000                          .word 0
@1502:000000                          .word 0
@1503:000000                          .word 0
@1504:000000                          .word 0
@1505:000000                          .word 0
@1506:000000                          .word 0
@1507:000000                          .word 0                  ; frame 3
@1510:000000                          .word 0
@1511:000000                          .word 0
@1512:000000                          .word 0
@1513:000000                          .word 0
@1514:000000                          .word 0
@1515:000000                          .word 0
@1516:000000                          .word 0                  ; frame 4
@1517:000000                          .word 0
@1520:000000                          .word 0
@1521:000000                          .word 0
@1522:000000                          .word 0
@1523:000000                          .word 0
@1524:000000                          .word 0
@1525:000000                          .word 0                  ; frame 5
@1526:000000                          .word 0
@1527:000000                          .word 0
@1530:000000                          .word 0
@1531:000000                          .word 0
@1532:000000                          .word 0
@1533:000000                          .word 0
@1534:000000                          .word 0                  ; frame 6
@1535:000000                          .word 0
@1536:000000                          .word 0
@1537:000000                          .word 0
@1540:000000                          .word 0
@1541:000000                          .word 0
@1542:000000                          .word 0
@1543:000000                          .word 0                  ; frame 7
@1544:000000                          .word 0
@1545:000000                          .word 0
@1546:000000                          .word 0
@1547:000000                          .word 0
@1550:000000                          .word 0
@1551:000000                          .word 0
@1552:000000                          .word 0                  ; frame 8
@1553:000000                          .word 0
@1554:000000                          .word 0
@1555:000000                          .word 0
@1556:000000                          .word 0
@1557:000000                          .word 0
@1560:000000                          .word 0
@1561:000000                          .word 0                  ; frame 9
@1562:000000                          .word 0
@1563:000000                          .word 0
@1564:000000                          .word 0
@1565:000000                          .word 0
@1566:000000                          .word 0
@1567:000000                          .word 0
@1570:000000                     eos: .word 0                  ; end of stack
@1571:001570              stack_endp: .word eos




                                      ; // This is the minimax function. It considers all
                                      ; // the possible ways the game can go and returns
                                      ; // the value of the board
                                      ; int minimax(int depth, bool isMax)
                                      ; {
                                      ;     int score = evaluate(board);
                                      ;     int m;
                                      ;     int best;

                                      ;     ; printf("%sMinimax Start\n", indent[depth+1]);
                                      ;     // If Maximizer has won the game return his/her
                                      ;     // evaluated score
                                      ;     if (score == 10) {
                                      ;         return score;
                                      ;         ; printf("%sMaximizer wins\n", indent[depth+1]);
                                      ;     }

                                      ;     // If Minimizer has won the game return his/her
                                      ;     // evaluated score
                                      ;     if (score == -10) {
                                      ;         ; printf("%sMinimizer Wins\n", indent[depth+1]);
                                      ;         return score;
                                      ;     }

                                      ;     // If there are no more moves and no winner then
                                      ;     // it is a tie
                                      ;     if (isMovesLeft(board)==false) {
                                      ;         ; printf("%sMinimax: No More Moves\n", indent[depth+1] );
                                      ;         return 0;
                                      ;     }

                                      ;     // If this maximizer's move
                                      ;     if (isMax)
                                      ;     {
                                      ;         best = -1000;

                                      ;         // Traverse all cells
                                      ;         for (int i = 0; i<3; i++)
                                      ;         {
                                      ;             for (int j = 0; j<3; j++)
                                      ;            {
                                      ;                // Check if cell is empty
                                      ;                if (board[i][j]=='_')
                                      ;                {
                                      ;                    // Make the move
                                      ;                    board[i][j] = player;

                                      ;                    // Call minimax recursively and choose
                                      ;                    // the maximum value
                                      ;                    //best = max( best,
                                      ;                    //    minimax(board, depth+1, !isMax) );
                                      ;                    m = minimax(depth+1, !isMax);
                                      ;                    //added by guy:
                                      ;                    m -= depth;
                                      ;                    ; printf("%sminimax isMAX=%d returned score %d  ", indent[depth+1], isMax, m);
                                      ;                    if (m > best) {
                                      ;                        best = m;
                                      ;                        ; printf("%sBest Higher\n", indent[depth+1]);
                                      ;                    } else {
                                      ;                        ; printf("\n");
                                      ;                    }
                                      ;                    ; print_board(depth);

                                      ;                    // Undo the move
                                      ;                    board[i][j] = '_';
                                      ;                }
                                      ;            }
                                      ;         }
                                      ;         return best;
                                      ;     }

                                      ;     // If this minimizer's move
                                      ;     else
                                      ;     {
                                      ;         best = 1000;

                                      ;         // Traverse all cells
                                      ;         for (int i = 0; i<3; i++)
                                      ;         {
                                      ;             for (int j = 0; j<3; j++)
                                      ;             {
                                      ;                 // Check if cell is empty
                                      ;                 if (board[i][j]=='_')
                                      ;                 {
                                      ;                     // Make the move
                                      ;                     board[i][j] = opponent;

                                      ;                     // Call minimax recursively and choose
                                      ;                     // the minimum value
                                      ;                     // best = min(best,
                                      ;                     //       minimax(depth+1, !isMax));
                                      ;                     m = minimax(depth+1, !isMax);
                                      ;                     ; for (int s = 0; s < depth; s++) printf("  ");
                                      ;                    //added by guy:
                                      ;                     m += depth;
                                      ;                     ; printf("    minimax isMAX=%d returned score %d  ", isMax, m);
                                      ;                      if (m < best) {
                                      ;                         best = m;
                                      ;                         ; printf("Best Lower\n");
                                      ;                     } else {
                                      ;                         ; printf("\n");
                                      ;                     }
                                      ;                     ; print_board(depth);

                                      ;                     // Undo the move
                                      ;                     board[i][j] = '_';
                                      ;                 }
                                      ;             }
                                      ;         }
                                      ;         return best;
                                      ;     }
                                      ; }


                                      ; This is the recursive module that tries all the combinations to find the
                                      ; best move.
                                      ; The routine takes one arg to say if we're trying to do Max or Min; Max is +1
                                      ; Min is -1, passed in AC
                             minimax:
@1572:051741                          ta minmax_ret            ; @@JumpedToBy a1652 a1714 a1775
@1573:041742                          ts minmax_lcl_isMax
@1574:075374                          sp push_minmax           ; store state on "the stack"
                                      ; .exec print_indent(cm, "Starting minimax: IsMax:%d, player: %d opponent %d, depth: %d" % (cm.rd(rl("minmax_lcl_isMax")), cm.rd(rl("player")), cm.rd(rl("opponent")), cm.rd(rl("push_lcl_depth"))), rl("push_lcl_depth"))
@1575:030000                          sd zero                  ; no-op
                                      ; .exec print_board(cm, rl("boardp"), rl("push_lcl_depth"), rl("player"), "Starting Minimax")
@1576:075311                          sp evaluate_board        ; figure out how we're doing
@1577:041743                          ts minmax_lcl_score

                     minmax_test_max:                          ; test if Maximizer has won
@1600:101743                          ca minmax_lcl_score
@1601:115133                          su c_10
@1602:134000                          dm 0                     ; test to see if score is +10
@1603:071605                          cp minmax_max_won        ; branch if yes
@1604:075610                          sp minmax_test_min

                      minmax_max_won:
                                      ; .print "Maximizer Won, score %d", minmax_lcl_score
@1605:101743                          ca minmax_lcl_score      ; @@JumpedToBy a1603
@1606:041746                          ts minmax_lcl_best       ; set up the return code
@1607:075735                          sp minmax_exit           ; all done

                     minmax_test_min:
@1610:101743                          ca minmax_lcl_score      ; @@JumpedToBy a1604
@1611:111133                          ad c_10
@1612:134000                          dm 0                     ; test to see if score is -10
@1613:071615                          cp minmax_min_won        ; branch if yes
@1614:075620                          sp minmax_test_tie

                      minmax_min_won:
                                      ; .print "Minimizer Won, score %d", minmax_lcl_score
@1615:101743                          ca minmax_lcl_score      ; @@JumpedToBy a1613
@1616:041746                          ts minmax_lcl_best       ; set up the return code
@1617:075735                          sp minmax_exit           ; all done

                     minmax_test_tie:
@1620:075233                          sp isMovesLeft           ; test if there are more moves to go @@JumpedToBy a1614
                                      ;.print "minmax_test_tie: isMovesLeft = %ad"
@1621:071623                          cp minmax_tie            ; Negative means "no more empty cells"
@1622:075626                          sp minmax_prepare_scan

                          minmax_tie:
@1623:100000                          ca zero                  ; @@JumpedToBy a1621
                                      ;.print "Minimax Tie"
@1624:041746                          ts minmax_lcl_best       ; set up the return code
@1625:075735                          sp minmax_exit           ; bail out

                 minmax_prepare_scan:
@1626:101742                          ca minmax_lcl_isMax      ; @@JumpedToBy a1622
@1627:071672                          cp minmax_not_isMax      ; branch if isMax == False

                                      ; ======== This section is "isMax == True" =============
                        minmax_isMax:
@1630:105134                          cs c_1000
@1631:041746                          ts minmax_lcl_best       ; initialize to Most Negative
@1632:100000                          ca zero                  ; prepare to scan all cells starting w/zero
@1633:041744                          ts minmax_lcl_next_cell
@1634:101132                          ca c_8n                  ; loop nine times
@1635:041745                          ts minmax_lcl_loop_cnt
                        minmax_loop1:
@1636:101232                          ca boardp                ; get the base board ptr to read the next cell @@JumpedToBy a1667
@1637:111744                          ad minmax_lcl_next_cell
@1640:045643                          td minmax_rd1
@1641:045647                          td minmax_wr1
@1642:045747                          td minmax_lcl_undo_move  ; this is only used _after_ the recursive call, and will need to be restored from stack
                          minmax_rd1:
@1643:100000                          ca 0                     ; fetch the next cell @@WrittenBy a1640
@1644:071646                          cp minmax_empty_cell1    ; continue if the cell is empty
@1645:075665                          sp minmax_loop1_end      ; go to the next loop step if the cell is not empty

                  minmax_empty_cell1:                          ; here, we know the cell we tested is empty, and a candidate for analysis
@1646:101137                          ca player                ; fetch the Player marker @@JumpedToBy a1644
                          minmax_wr1:
@1647:040000                          ts 0                     ; ... and write it into the cell @@WrittenBy a1641
                                      .exec print_experiment(cm, cb, "Trying  game piece %d to cell %d, count %d, isMax==True", ("player", "minmax_lcl_next_cell", "minmax_lcl_loop_cnt"), "push_lcl_depth")
@1650:030000                          sd zero                  ; no-op

                                      ;        cs zero                 ; load negative zero, i.e. all ones
                                      ;        sd minmax_lcl_isMax     ; Sum Digits, i.e., xor, will reverse isMax
@1651:104001                          cs one                   ; load -1 to signal isMax should be False
                                      ; here begins the recursion
                                      ; .exec print_indent(cm, "starting recursive call to minimax: isMax==True-branch, cell at %d, depth: %d, loop_count: %d" % (cm.rd(rl("minmax_lcl_next_cell")), cm.rd(rl("push_lcl_depth")), cm.rd(rl("minmax_lcl_loop_cnt"))), rl("push_lcl_depth"))
@1652:075572                          sp minimax
                                      ; the following adjustment probably shouldn't be done if the answer is Zero
@1653:114001                          su one                   ; push_lcl_depth       ; reduce the score by the calling depth
@1654:041751                          ts mm_lcl_ret_val        ; very local storage for the minimax return call
                                      ; .exec print_indent(cm, "finished recursive call to minimax: isMax==True-branch, cell at %d, depth: %d, loop_count: %d, score: 0o%o" % (cm.rd(rl("minmax_lcl_next_cell")), cm.rd(rl("push_lcl_depth")), cm.rd(rl("minmax_lcl_loop_cnt")), cm.rd(rl("mm_lcl_ret_val"))), rl("push_lcl_depth"))
@1655:115746                          su minmax_lcl_best       ; determine if this was the "best" score so far
@1656:071661                          cp minmax_not_best0      ; branch if we've seen a better score already

@1657:101751                          ca mm_lcl_ret_val        ; save this result as the Best Score So Far
@1660:041746                          ts minmax_lcl_best

                    minmax_not_best0:
@1661:101747                          ca minmax_lcl_undo_move  ; remember that modified instruction addresses are effectively local variables, so restore this one from the stack @@JumpedToBy a1656
                                      ;.exec print_experiment(cm, cb, "Undoing game piece %d in cell %d at 0o%o, isMax==True", ("player", "minmax_lcl_next_cell", "minmax_lcl_undo_move"), "push_lcl_depth")
@1662:045664                          td minmax_undo_move0
@1663:104001                          cs one                   ; undo the trial move
                   minmax_undo_move0:
@1664:040000                          ts 0                     ; @@WrittenBy a1662

                    minmax_loop1_end:                          ; get ready for the next cell iteration
@1665:131744                          ao minmax_lcl_next_cell  ; @@JumpedToBy a1645
@1666:131745                          ao minmax_lcl_loop_cnt
                                      ; .print "decrement loop count to %ad, depth: %d, isMax==True-branch", push_lcl_depth
@1667:071636                          cp minmax_loop1          ; go around again if the loop cnt is not exhausted

@1670:101746                          ca minmax_lcl_best       ; return the best score found in AC
@1671:075735                          sp minmax_exit           ; all done with this pass of isMax == True



                                      ; ======== This section is "isMax == False" =============
                    minmax_not_isMax:
@1672:101134                          ca c_1000                ; @@JumpedToBy a1627
@1673:041746                          ts minmax_lcl_best       ; initialize to Most Positive
@1674:100000                          ca zero                  ; prepare to scan all cells starting w/zero
@1675:041744                          ts minmax_lcl_next_cell
@1676:101132                          ca c_8n                  ; loop nine times
@1677:041745                          ts minmax_lcl_loop_cnt
                        minmax_loop2:
@1700:101232                          ca boardp                ; get the base board ptr to read the next cell @@JumpedToBy a1732
@1701:111744                          ad minmax_lcl_next_cell
@1702:045705                          td minmax_rd2
@1703:045711                          td minmax_wr2
@1704:045747                          td minmax_lcl_undo_move  ; store this address on the 'stack' for now
                          minmax_rd2:
@1705:100000                          ca 0                     ; fetch the next cell @@WrittenBy a1702
@1706:071710                          cp minmax_empty_cell2    ; continue if the cell is empty
@1707:075730                          sp minmax_loop2_end      ; go to the next loop step if the cell is not empty

                  minmax_empty_cell2:                          ; here, we know the cell we tested is empty, and a candidate for analysis
@1710:101140                          ca opponent              ; fetch the Opponent marker @@JumpedToBy a1706
                          minmax_wr2:
@1711:040000                          ts 0                     ; ... and write it into the cell @@WrittenBy a1703
                                      ; .exec print_experiment(cm, cb, "Trying  game piece %d in cell %d, count %d, isMax==False", ("opponent", "minmax_lcl_next_cell", "minmax_lcl_loop_cnt"), "push_lcl_depth")
@1712:030000                          sd zero                  ; no-op
                                      ;        cs zero                 ; load negative zero, i.e. all ones
                                      ;        sd minmax_lcl_isMax     ; Sum Digits, i.e., xor, will reverse isMax
@1713:100001                          ca one                   ; load -1 to signal isMax should be True
                                      ; here begins the recursion
                                      ; .exec print_indent(cm, "starting recursive call to minimax: isMax==False-branch, cell at %d, depth: %d, loop_count: %d" % (cm.rd(rl("minmax_lcl_next_cell")), cm.rd(rl("push_lcl_depth")), cm.rd(rl("minmax_lcl_loop_cnt"))), rl("push_lcl_depth"))
@1714:075572                          sp minimax
                                      ; the following adjustment probably shouldn't be done if the answer is Zero
@1715:110001                          ad one                   ;  push_lcl_depth       ; increase the (negative) score by the calling depth
@1716:041751                          ts mm_lcl_ret_val        ; very local storage for the minimax return value
                                      ; .exec print_indent(cm, "finished recursive call to minimax: isMax==False-branch, cell at %d, depth: %d, loop_count: %d, score: 0o%o" % (cm.rd(rl("minmax_lcl_next_cell")), cm.rd(rl("push_lcl_depth")), cm.rd(rl("minmax_lcl_loop_cnt")), cm.rd(rl("mm_lcl_ret_val"))), rl("push_lcl_depth"))


@1717:115746                          su minmax_lcl_best       ; determine if this was the "best" score so far
@1720:071722                          cp minmax_best2
@1721:075724                          sp minmax_not_best2      ; branch if we've seen a better score already

                        minmax_best2:
@1722:101751                          ca mm_lcl_ret_val        ; save this result as the Best Score So Far @@JumpedToBy a1720
@1723:041746                          ts minmax_lcl_best

                    minmax_not_best2:

@1724:101747                          ca minmax_lcl_undo_move  ; remember that modified instruction addresses are effectively local variables, so restore this one from the stack @@JumpedToBy a1721
                                      ; .exec print_experiment(cm, cb, "Undoing game piece %d in cell %d at 0o%o, isMax==False", ("player", "minmax_lcl_next_cell", "minmax_lcl_undo_move"), "push_lcl_depth")
@1725:045727                          td minmax_undo_move2
@1726:104001                          cs one                   ; undo the trial move
                   minmax_undo_move2:
@1727:040000                          ts 0                     ; @@WrittenBy a1725

                    minmax_loop2_end:                          ; get ready for the next cell iteration
@1730:131744                          ao minmax_lcl_next_cell  ; @@JumpedToBy a1707
@1731:131745                          ao minmax_lcl_loop_cnt
@1732:071700                          cp minmax_loop2          ; go around again if the loop cnt is not exhausted

@1733:101746                          ca minmax_lcl_best       ; return the best score found in AC
@1734:075735                          sp minmax_exit           ; all done with this pass of isMax == False


                         minmax_exit:
@1735:030000                          sd zero                  ; no-op for .exec @@JumpedToBy a1607 a1617 a1625 a1671 a1734
                                      ; .exec print_indent(cm, "Exiting minimax: IsMax:%d, depth: %d, score: %d" % (cm.rd(rl("minmax_lcl_isMax")), cm.rd(rl("push_lcl_depth")), cm.rd(rl("minmax_lcl_best"))), rl("push_lcl_depth"))
@1736:030000                          sd zero                  ; this is a no-op
                                      ; .exec print_board(cm, rl("boardp"), rl("push_lcl_depth"), rl("player") )
@1737:101746                          ca minmax_lcl_best

                                      ; note that we stash and retrieve the AC during PoP
@1740:075424                          sp pop_minmax
                          minmax_ret:
@1741:074000                          sp 0                     ; @@WrittenBy a1572

                                      ; the 'local data' for minmax must be copied/retrieved from the "stack" for recursion
                                      ; a "stack frame" must store from minmax_ret to minmax_lcl_data_end
@1742:000000        minmax_lcl_isMax: .word 0                  ; @@WrittenBy a1573 ReadBy a1626
@1743:000000        minmax_lcl_score: .word 0                  ; @@WrittenBy a1577 ReadBy a1600 a1605 a1610 a1615
@1744:000000    minmax_lcl_next_cell: .word 0                  ; @@WrittenBy a1633 a1665 a1675 a1730 ReadBy a1637 a1665 a1701 a1730
@1745:000000     minmax_lcl_loop_cnt: .word 0                  ; @@WrittenBy a1635 a1666 a1677 a1731 ReadBy a1666 a1731
@1746:000000         minmax_lcl_best: .word 0                  ; @@WrittenBy a1606 a1616 a1624 a1631 a1660 a1673 a1723 ReadBy a1655 a1670 a1717 a1733 a1737
@1747:000000    minmax_lcl_undo_move: .word 0                  ; @@WrittenBy a1642 a1704 ReadBy a1661 a1724
@1750:000000     minmax_lcl_data_end: .word 0                  ; this is just a marker for the end of data to be pushed

@1751:000000          mm_lcl_ret_val: .word 0                  ; @@WrittenBy a1654 a1716 ReadBy a1657 a1722



                                      ; // This will return the best possible move for the player
                                      ; // This routine used to return row and move with a single pointer to a struct.
                                      ; // Not a WW Kind of Thing, so I changed it to return two ints via args
                                      ; // struct Move findBestMove)
                                      ; void findBestMove(int *move_row, int *move_col)
                                      ; {
                                      ;     int bestVal = -1000;
                                      ;     int bestMove_row = -1;
                                      ;     int bestMove_col = -1;

                                      ;     // Traverse all cells, evaluate minimax function for
                                      ;     // all empty cells. And return the cell with optimal
                                      ;     // value.
                                      ;     for (int i = 0; i<3; i++)
                                      ;     {
                                      ;         for (int j = 0; j<3; j++)
                                      ;         {
                                      ;             // Check if cell is empty
                                      ;             if (board[i][j]=='_')
                                      ;             {
                                      ;                 // Make the move
                                      ;                 board[i][j] = player;

                                      ;                 // compute evaluation function for this
                                      ;                 // move.
                                      ;                 int moveVal = minimax(0, false);

                                      ;                 // Undo the move
                                      ;                 board[i][j] = '_';

                                      ;                 // If the value of the current move is
                                      ;                 // more than the best value, then update
                                      ;                 // best/
                                      ;                 printf("minimax returned %d  ", moveVal);
                                      ;                 if (moveVal > bestVal)
                                      ;                 {
                                      ;                     bestMove_row = i;
                                      ;                     bestMove_col = j;
                                      ;                     bestVal = moveVal;
                                      ;                     printf("Best\n");
                                      ;                 }
                                      ;                 else {
                                      ;                     printf("\n");
                                      ;                 }
                                      ;             }
                                      ;         }
                                      ;     }

                                      ;     printf("The value of the best Move for Player %c is : %d\n",
                                      ;             player, bestVal);

                                      ;     *move_row = bestMove_row;
                                      ;     *move_col = bestMove_col;
                                      ;     // return // bestMove;
                                      ; }


                                      ; findBestMove cycles through the board to find the move that results
                                      ; in the best score for the current Player
                                      ; The routine takes no explicit argument, but assumes that Player is the
                                      ; one we're trying to advance
                                      ; the assumption on calling this routine is that there's at least one move available to be tried
                        findBestMove:
@1752:052017                          ta fBM_ret               ; @@JumpedToBy a0657

                                      ; initialize the 'best stuff' detector
@1753:105134                          cs c_1000
@1754:042020                          ts fBM_lcl_best_value
                                      ; .print "Starting findBestMove, player=%d, opponent=%d", player, opponent
@1755:104001                          cs one
@1756:042021                          ts fBM_lcl_best_move
@1757:101132                          ca c_8n
@1760:042022                          ts fBM_lcl_loop_count
@1761:100000                          ca zero
@1762:042023                          ts fBM_lcl_current_cell
@1763:101232                          ca boardp                ; we always start from cell zero`
@1764:045767                          td fBM_fetch_cell
@1765:045773                          td fBM_set_cell
@1766:046000                          td fBM_clear_cell

                                      ; we start the loop here, but the first test will bypass the rest of the loop if the cell is already spoken for
                      fBM_fetch_cell:
@1767:100000                          ca 0                     ; read the current cell into AC @@WrittenBy a1764 a2010 ReadBy a2010 JumpedToBy a2015
@1770:071772                          cp fBM_try_move          ; if the cell is empty, go on to try out a move
@1771:076010                          sp fBM_next_loop         ; take a pass on this non-empty cell, go on to the next one

                        fBM_try_move:
@1772:101137                          ca player                ; @@JumpedToBy a1770
                                      ; try out a move on this cell
                                      .print "fBM: try  empty cell %d, player=%d", fBM_lcl_current_cell, player
                        fBM_set_cell:
@1773:040000                          ts 0                     ; @@WrittenBy a1765 a2011 ReadBy a2011
@1774:104001                          cs one                   ; tell Minimax to try for a Min score on this cell

                                      ; sp draw_game_board    ; this doesn't work yet -- unintended recursion...

                                      ; .print "fBM: call minimax, player=%d, IsMax=%ad", player
@1775:075572                          sp minimax               ; call the optimizer; best-score comes back in AC
                                      ;.print "fBM: minimax returned %ad"
@1776:042024                          ts fBM_lcl_tmp_score     ; stash the score for now

@1777:104001                          cs one                   ; undo the trial move, then evaluate the results of minimax
                      fBM_clear_cell:
@2000:040000                          ts 0                     ; @@WrittenBy a1766 a2012 ReadBy a2012

                                      ; see if we bested a previous score
@2001:102024                          ca fBM_lcl_tmp_score     ; compare the new result with previous best
@2002:116020                          su fBM_lcl_best_value    ; branch if the old one was better; i.e., skip updating the eval_score_players
@2003:072010                          cp fBM_next_loop

@2004:102024                          ca fBM_lcl_tmp_score
@2005:042020                          ts fBM_lcl_best_value    ; save the New Best Score
@2006:102023                          ca fBM_lcl_current_cell  ; and remember how we got here, i.e., which cell we tried
                                      .print "fBM new Best Move: score %d, cell %d, loop: %d", fBM_lcl_tmp_score, fBM_lcl_current_cell, fBM_lcl_loop_count
@2007:042021                          ts fBM_lcl_best_move

                       fBM_next_loop:
@2010:131767                          ao fBM_fetch_cell        ; @@JumpedToBy a1771 a2003
@2011:131773                          ao fBM_set_cell
@2012:132000                          ao fBM_clear_cell
@2013:132023                          ao fBM_lcl_current_cell
@2014:132022                          ao fBM_lcl_loop_count
@2015:071767                          cp fBM_fetch_cell        ; go 'round the loop again

                                      ; when we're done with the loop, return the best move found (not the score, the cell that played best)
@2016:102021                          ca fBM_lcl_best_move
                                      .print "fBM findBestMove for player %d returns move to cell %ad, score=%d", player, fBM_lcl_best_value

                             fBM_ret:
@2017:074000                          sp 0                     ; @@WrittenBy a1752
                  fBM_lcl_best_value:                          ; best score found so far
@2020:000000                          .word 0                  ; @@WrittenBy a1754 a2005 ReadBy a2002
                   fBM_lcl_best_move:                          ; remember the move that resulted in the best score
@2021:000000                          .word 0                  ; @@WrittenBy a1756 a2007 ReadBy a2016
                  fBM_lcl_loop_count:
@2022:000000                          .word 0                  ; @@WrittenBy a1760 a2014 ReadBy a2014
                fBM_lcl_current_cell:
@2023:000000                          .word 0                  ; @@WrittenBy a1762 a2013 ReadBy a2006 a2013
                   fBM_lcl_tmp_score:
@2024:000000                          .word 0                  ; @@WrittenBy a1776 ReadBy a2001 a2004


                                      ;=====================================================================================

                                      ; /* 16-segment character generator, originally in Core Memory Clock
                                      ;  *
                                      ;  * Guy Fedorkow, Feb 22, 2025
                                      ;  *  originally for Arduino Mega
                                      ;  *
                                      ;  */



                      unit_test_main:
@2025:104004                          cs c_scope_edge          ; @@JumpedToBy a2032
@2026:042100                          ts ds_argx
@2027:042101                          ts ds_argy
@2030:102033                          ca msgp
@2031:076054                          sp draw_str
                                      ;si 0
@2032:076025                          sp unit_test_main


@2033:002034                    msgp: .word msg                ; @@ReadBy a2030
@2034:000030                     msg: .flexl "N"
@2035:000060                          .flexl "O"
@2036:000046                          .flexl "W"
@2037:000010                          .flexl " "
@2040:000014                          .flexl "I"
@2041:000012                          .flexl "S"
@2042:000010                          .flexl " "
@2043:000040                          .flexl "T"
@2044:000050                          .flexl "H"
@2045:000002                          .flexl "E"
@2046:000010                          .flexl " "
@2047:000040                          .flexl "T"
@2050:000014                          .flexl "I"
@2051:000070                          .flexl "M"
@2052:000002                          .flexl "E"
@2053:177776                          .word -1


                                      ; -----------------------------------------
                                      ; draw a character string on the CRT
                                      ; AC contains a pointer to the string, terminated by the first negative 'character'
                                      ; ds_argx and ds_argy give the initial (x, y) location
                            draw_str:
@2054:052076                          ta ds_ret                ; @@JumpedToBy a0143 a2031
@2055:046077                          td ds_lcl_charp          ; save the character pointer
                             ds_loop:
@2056:102100                          ca ds_argx               ; @@JumpedToBy a2075
@2057:042336                          ts d16c_argx
@2060:102101                          ca ds_argy
@2061:042337                          ts d16c_argy
@2062:102077                          ca ds_lcl_charp          ; walk the string from start to finish
@2063:046064                          td ds_get_char
                         ds_get_char:
@2064:100000                          ca 0                     ; fetch the next character in the string @@WrittenBy a2063
@2065:076266                          sp draw_16seg_char       ; actually draw the character!

@2066:132077                          ao ds_lcl_charp          ; prepare for next char in loop
@2067:046070                          td ds_test_str_end
                     ds_test_str_end:
@2070:100000                          ca 0                     ; @@WrittenBy a2067
@2071:072076                          cp ds_ret                ; test for a negative number as the marker for the string end; branch out if done

@2072:102100                          ca ds_argx
@2073:112265                          ad char_spacing
@2074:042100                          ts ds_argx
@2075:076056                          sp ds_loop

                              ds_ret:
@2076:074000                          sp 0                     ; @@WrittenBy a2054 JumpedToBy a2071

@2077:000000            ds_lcl_charp: .word 0                  ; pointer to the next character to display @@WrittenBy a2055 a2066 ReadBy a2062 a2066
@2100:000000                 ds_argx: .word 0                  ; @@WrittenBy a0141 a2026 a2074 ReadBy a2056 a2072
@2101:000000                 ds_argy: .word 0                  ; @@WrittenBy a0137 a2027 ReadBy a2060

                                      ; ---------------------------

                                      ; The following table, indexed by ASCII character, gives a bit map of which of the 16
                                      ; segments should be lit for each symbol.
                SixteenSegmentFlexop:
@2102:002103                          .word SixteenSegmentFlexo; @@ReadBy a2267
                 SixteenSegmentFlexo:
                         flexo_ucase:
@2103:125074                          .word 0o125074           ; /* # */
@2104:125074                          .word 0o125074           ; /* # */
@2105:100363                          .word 0o100363           ; /* E */
@2106:104377                          .word 0o104377           ; /* 8 */
@2107:125074                          .word 0o125074           ; /* # */
@2110:000060                          .word 0o000060           ; /* _ */
@2111:104317                          .word 0o104317           ; /* A */
@2112:004077                          .word 0o004077           ; /* 3 */
@2113:000000                          .word 0o000000           ; /* (space) */
@2114:021000                          .word 0o021000           ; /* : */
@2115:104273                          .word 0o104273           ; /* S */
@2116:104214                          .word 0o104214           ; /* 4 */
@2117:021063                          .word 0o021063           ; /* I */
@2120:042000                          .word 0o042000           ; /* / */
@2121:000374                          .word 0o000374           ; /* U */
@2122:104167                          .word 0o104167           ; /* 2 */
@2123:177777                          .word 0o177777           ; /* (del) */
@2124:040400                          .word 0o040400           ; /* ) */
@2125:021077                          .word 0o021077           ; /* D */
@2126:110263                          .word 0o110263           ; /* 5 */
@2127:114307                          .word 0o114307           ; /* R */
@2130:002014                          .word 0o002014           ; /* 1 */
@2131:000174                          .word 0o000174           ; /* J */
@2132:000017                          .word 0o000017           ; /* 7 */
@2133:010714                          .word 0o010714           ; /* N */
@2134:012000                          .word 0o012000           ; /* ( */
@2135:100303                          .word 0o100303           ; /* F */
@2136:104373                          .word 0o104373           ; /* 6 */
@2137:000363                          .word 0o000363           ; /* C */
@2140:104000                          .word 0o104000           ; /* - */
@2141:112300                          .word 0o112300           ; /* K */
@2142:125074                          .word 0o125074           ; /* # */
@2143:021003                          .word 0o021003           ; /* T */
@2144:125074                          .word 0o125074           ; /* # */
@2145:042063                          .word 0o042063           ; /* Z */
@2146:177777                          .word 0o177777           ; /* (del) */
@2147:000360                          .word 0o000360           ; /* L */
@2150:000000                          .word 0o000000           ; /* (space) */
@2151:050314                          .word 0o050314           ; /* W */
@2152:125074                          .word 0o125074           ; /* # */
@2153:104314                          .word 0o104314           ; /* H */
@2154:000000                          .word 0o000000           ; /* (space) */
@2155:104274                          .word 0o104274           ; /* Y */
@2156:125074                          .word 0o125074           ; /* # */
@2157:104307                          .word 0o104307           ; /* P */
@2160:125074                          .word 0o125074           ; /* # */
@2161:010377                          .word 0o010377           ; /* Q */
@2162:125074                          .word 0o125074           ; /* # */
@2163:000377                          .word 0o000377           ; /* O */
@2164:177777                          .word 0o177777           ; /* (del) */
@2165:025077                          .word 0o025077           ; /* B */
@2166:125074                          .word 0o125074           ; /* # */
@2167:004373                          .word 0o004373           ; /* G */
@2170:125074                          .word 0o125074           ; /* # */
@2171:104277                          .word 0o104277           ; /* 9 */
@2172:125074                          .word 0o125074           ; /* # */
@2173:002714                          .word 0o002714           ; /* M */
@2174:177777                          .word 0o177777           ; /* (del) */
@2175:052400                          .word 0o052400           ; /* X */
@2176:125074                          .word 0o125074           ; /* # */
@2177:042300                          .word 0o042300           ; /* V */
@2200:177777                          .word 0o177777           ; /* (del) */
@2201:042377                          .word 0o042377           ; /* 0 */
@2202:177777                          .word 0o177777           ; /* (del) */


                                      ; Lower Case not used yet
                                      ;flexo_lcase:
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o140140   ; /* e */
                                      ;        .word 0o104377   ; /* 8 */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o021000   ; /* | */
                                      ;        .word 0o120160   ; /* a */
                                      ;        .word 0o004077   ; /* 3 */
                                      ;        .word 0o000000   ; /* (space) */
                                      ;        .word 0o104060   ; /* = */
                                      ;        .word 0o120241   ; /* s */
                                      ;        .word 0o104214   ; /* 4 */
                                      ;        .word 0o020000   ; /* i */
                                      ;        .word 0o125000   ; /* + */
                                      ;        .word 0o020140   ; /* u */
                                      ;        .word 0o104167   ; /* 2 */
                                      ;        .word 0o177777   ; /* (del) */
                                      ;        .word 0o010000   ; /* . */
                                      ;        .word 0o024034   ; /* d */
                                      ;        .word 0o110263   ; /* 5 */
                                      ;        .word 0o100100   ; /* r */
                                      ;        .word 0o002014   ; /* 1 */
                                      ;        .word 0o021140   ; /* j */
                                      ;        .word 0o000017   ; /* 7 */
                                      ;        .word 0o120100   ; /* n */
                                      ;        .word 0o040000   ; /* , */
                                      ;        .word 0o125002   ; /* f */
                                      ;        .word 0o104373   ; /* 6 */
                                      ;        .word 0o100140   ; /* c */
                                      ;        .word 0o104000   ; /* - */
                                      ;        .word 0o033000   ; /* k */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o100340   ; /* t */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o140040   ; /* z */
                                      ;        .word 0o177777   ; /* (del) */
                                      ;        .word 0o000300   ; /* l */
                                      ;        .word 0o000000   ; /* (space) */
                                      ;        .word 0o050110   ; /* w */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o120300   ; /* h */
                                      ;        .word 0o000000   ; /* (space) */
                                      ;        .word 0o005034   ; /* y */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o101301   ; /* p */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o121201   ; /* q */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o120140   ; /* o */
                                      ;        .word 0o177777   ; /* (del) */
                                      ;        .word 0o120340   ; /* b */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o121241   ; /* g */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o104277   ; /* 9 */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o124110   ; /* m */
                                      ;        .word 0o177777   ; /* (del) */
                                      ;        .word 0o052400   ; /* x */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o040100   ; /* v */
                                      ;        .word 0o177777   ; /* (del) */
                                      ;        .word 0o042377   ; /* 0 */
                                      ;        .word 0o177777   ; /* (del) */


                                      ; // size of 16-segment characters
                                      .pp WIDTH_16SEG, 0o60
                                      .pp HEIGHT_16SEG, 0o110
                                      .pp OFFSET_16SEG, 0o10   ; 0d08
                                      .pp SPACING_16SEG, WIDTH_16SEG + WIDTH_16SEG / 4 * 64

                                      ; Delta word for vectors
                                      ;  Left 8 bits are horizontal, right 8 are vertical
                                      ;  Of each, only the six left bits are used

                                      .pp DOWN_LEFT, 127 - OFFSET_16SEG - 3 * 256 * 2 + 255 - HEIGHT_16SEG
                                      .pp UP_RIGHT, OFFSET_16SEG - 3 * 256 * 2 + HEIGHT_16SEG
                                      .pp HORIZ_RIGHT, WIDTH_16SEG * 256

                                      .pp UP_RIGHT_DIAG, OFFSET_16SEG + WIDTH_16SEG * 256 + HEIGHT_16SEG
                                      .pp DOWN_RIGHT_DIAG, WIDTH_16SEG - OFFSET_16SEG * 256 + 255 - HEIGHT_16SEG


                                      ; // these defines give the relative offsets for the points
                                      ; // that make up a 16-segment display
                                      .pp P0x, 64 * OFFSET_16SEG
                                      .pp P0y, 64 * HEIGHT_16SEG

                                      .pp P1x, 64 * OFFSET_16SEG + WIDTH_16SEG / 2
                                      .pp P1y, 64 * HEIGHT_16SEG

                                      .pp P2x, 64 * OFFSET_16SEG + WIDTH_16SEG
                                      .pp P2y, 64 * HEIGHT_16SEG

                                      .pp P3x, 64 * OFFSET_16SEG / 2 + WIDTH_16SEG
                                      .pp P3y, 64 * HEIGHT_16SEG / 2

                                      .pp P4x, 64 * WIDTH_16SEG
                                      .pp P4y, 64 * 0

                                      .pp P5x, 64 * WIDTH_16SEG / 2;  P0...P1...P2
                                      .pp P5y, 64 * 0          ;  .         .
                                      ;  .         .
                                      .pp P6x, 64 * 0          ;  .         .
                                      .pp P6y, 64 * 0          ;  P7...P8...P3
                                      ;  .         .
                                      .pp P7x, 64 * OFFSET_16SEG / 2;  .         .
                                      .pp P7y, 64 * HEIGHT_16SEG / 2;  .         .
                                      ;  P6...P5...P4

                                      .pp P8x, 64 * OFFSET_16SEG / 2 + WIDTH_16SEG / 2
                                      .pp P8y, 64 * HEIGHT_16SEG / 2


                                      ; // and this array gives sixteen starting points and delta for each line
                                      ; // segment in the 16-segment display character.

                      seg_tab_startp:
@2203:002204                          .word seg00x

@2204:001000                  seg00x: .word P0x                ;   {P0, P1}
@2205:011000                  seg00y: .word P0y
@2206:030000                  seg00d: .word HORIZ_RIGHT

@2207:004000                  seg01x: .word P1x                ;   {P1, P2},
@2210:011000                  seg01y: .word P1y
@2211:030000                  seg01d: .word HORIZ_RIGHT

@2212:007000                  seg02x: .word P2x                ;   {P2, P3},
@2213:011000                  seg02y: .word P2y
@2214:172267                  seg02d: .word DOWN_LEFT

@2215:006400                  seg03x: .word P3x                ;   {P3, P4},
@2216:004400                  seg03y: .word P3y
@2217:172267                  seg03d: .word DOWN_LEFT

@2220:003000                  seg04x: .word P5x                ;   {P4, P5},
@2221:000000                  seg04y: .word P5y
@2222:030000                  seg04d: .word HORIZ_RIGHT

@2223:000000                  seg05x: .word P6x                ;   {P5, P6},
@2224:000000                  seg05y: .word P6y
@2225:030000                  seg05d: .word HORIZ_RIGHT

@2226:000000                  seg06x: .word P6x                ;   {P6, P7},
@2227:000000                  seg06y: .word P6y
@2230:005110                  seg06d: .word UP_RIGHT

@2231:000400                  seg07x: .word P7x                ;   {P7, P0},
@2232:004400                  seg07y: .word P7y
@2233:005110                  seg07d: .word UP_RIGHT

@2234:001000                  seg08x: .word P0x                ;   {P0, P8},
@2235:011000                  seg08y: .word P0y
@2236:024267                  seg08d: .word DOWN_RIGHT_DIAG

@2237:004000                  seg09x: .word P1x                ;   {P1, P8},
@2240:011000                  seg09y: .word P1y
@2241:172267                  seg09d: .word DOWN_LEFT

@2242:003400                  seg10x: .word P8x                ;   {P2, P8},
@2243:004400                  seg10y: .word P8y
@2244:034110                  seg10d: .word UP_RIGHT_DIAG

@2245:003400                  seg11x: .word P8x                ;   {P3, P8},
@2246:004400                  seg11y: .word P8y
@2247:030000                  seg11d: .word HORIZ_RIGHT

@2250:003400                  seg12x: .word P8x                ;   {P4, P8},
@2251:004400                  seg12y: .word P8y
@2252:024267                  seg12d: .word DOWN_RIGHT_DIAG

@2253:003400                  seg13x: .word P8x                ;   {P5, P8},
@2254:004400                  seg13y: .word P8y
@2255:172267                  seg13d: .word DOWN_LEFT

@2256:000000                  seg14x: .word P6x                ;   {P6, P8},
@2257:000000                  seg14y: .word P6y
@2260:034110                  seg14d: .word UP_RIGHT_DIAG

@2261:000400                  seg15x: .word P7x                ;   {P7, P8},
@2262:004400                  seg15y: .word P7y
@2263:030000                  seg15d: .word HORIZ_RIGHT

                        seg_tab_endp:
@2264:002261                          .word seg15x             ; @@ReadBy a2275
                        char_spacing:
@2265:007400                          .word SPACING_16SEG      ; @@ReadBy a2073


                                      ; Draw a Flexo character passed in to this routine in the ACC
                                      ; First, find the segment map for a given character.  Input is a Flexo-coded character.
                                      ; The routine returns a 16-bit int where each bit represents one stroke in the character.  If the
                                      ; bit is one, draw the stroke; if not, don't draw.
                                      ; Character position is given by the args d16c_argx, d16c_argy.
                     draw_16seg_char:
@2266:052335                          ta d16c_ret              ; @@JumpedToBy a2065

@2267:112102                          ad SixteenSegmentFlexop  ; add the table start addr to the offset in ACC
@2270:046271                          td d16c_rd
                             d16c_rd:
@2271:100000                          ca 0                     ; fetch the bit map @@WrittenBy a2270
@2272:042340                          ts d16c_lcl_seg_map

                                      ; draw the sixteen segments, starting with the most significant bit
@2273:104002                          cs c_15                  ; prep for 16 times around the loop
@2274:042341                          ts d16c_lcl_loop_cnt
@2275:102264                          ca seg_tab_endp          ; walk the segment table back to front
@2276:046331                          td d16c_read_seg_tabx    ; first table entry
                                      ;        td tmp_tabx
@2277:110001                          ad one
@2300:046326                          td d16c_read_seg_taby    ; second table entry
                                      ;        td tmp_taby
@2301:110001                          ad one
@2302:046333                          td d16c_read_seg_tabdxy  ; third table entry

                                      ; I've commented out a bit of debug code here to draw dots at each of the junction points in the
                                      ; 16-segment figure.  Use this to verify that the line segments are the right length...
                           d16s_loop:
                                      ; this strip draws dots at the intersection points
@2303:100000                          ca 0                     ; no op @@JumpedToBy a2324
                                      ;tmp_taby:
                                      ;        ca 0
@2304:000677                          si scope_point           ; ; Auto-Annotate I/O: Display Points
                                      ;tmp_tabx:
                                      ;        ca 0
                                      ;        rc 0
                                      ; end of debug hack
@2305:102340                          ca d16c_lcl_seg_map
@2306:072326                          cp d16c_draw_seg         ; branch if most significant bit is on

                  d16s_loop_continue:
@2307:102340                          ca d16c_lcl_seg_map      ; @@JumpedToBy a2334
@2310:170001                          clc 1                    ; shift AC left by one bit
@2311:042340                          ts d16c_lcl_seg_map
@2312:102331                          ca d16c_read_seg_tabx
@2313:115130                          su c_3
@2314:046331                          td d16c_read_seg_tabx
                                      ;        td tmp_tabx
@2315:102326                          ca d16c_read_seg_taby
@2316:115130                          su c_3
@2317:046326                          td d16c_read_seg_taby
                                      ;        td tmp_taby
@2320:102333                          ca d16c_read_seg_tabdxy
@2321:115130                          su c_3
@2322:046333                          td d16c_read_seg_tabdxy
@2323:132341                          ao d16c_lcl_loop_cnt
@2324:072303                          cp d16s_loop
@2325:076335                          sp d16c_ret              ; bail out when count exhausted

                                      ; on entry to this code block, the three entries in the segment table should give:
                                      ;   _tab1 = X pos'n
                                      ;   _tab2 = Y pos'n
                                      ;   _tab3 = XY Delta vector
                       d16c_draw_seg:                          ; branch here if we're doing a segment, then return to the loop
                                      ; the SI uses the AC to set Y coord
                  d16c_read_seg_taby:
@2326:100000                          ca 0                     ; @@WrittenBy a2300 a2317 ReadBy a2315 JumpedToBy a2306
@2327:112337                          ad d16c_argy
@2330:001677                          si scope_vector          ; initialize vector gen with the y-coord in ACC ; Auto-Annotate I/O: Display Vectors

                                      ; the RC uses AC to set X coord and mem address for the vector length
                  d16c_read_seg_tabx:
@2331:100000                          ca 0                     ; @@WrittenBy a2276 a2314 ReadBy a2312
@2332:112336                          ad d16c_argx
                d16c_read_seg_tabdxy:
@2333:024000                          rc 0                     ; @@WrittenBy a2302 a2322 ReadBy a2320
@2334:076307                          sp d16s_loop_continue

                            d16c_ret:                          ;; Return from draw_16seg_char
@2335:074000                          sp 0                     ; @@WrittenBy a2266 JumpedToBy a2325

                           d16c_argx:
@2336:000000                          .word 0                  ; @@WrittenBy a2057 ReadBy a2332
                           d16c_argy:
@2337:000000                          .word 0                  ; @@WrittenBy a2061 ReadBy a2327
                    d16c_lcl_seg_map:
@2340:000000                          .word 0                  ; @@WrittenBy a2272 a2311 ReadBy a2305 a2307
                   d16c_lcl_loop_cnt:
@2341:000000                          .word 0                  ; @@WrittenBy a2274 a2323 ReadBy a2323





                                      ; Character Table license

                                      ; /*
                                      ;  *  Project     Segmented LED Display - ASCII Library
                                      ;  *  @author     David Madison
                                      ;  *  @link       github.com/dmadison/Segmented-LED-Display-ASCII
                                      ;  *  @license    MIT - Copyright (c) 2017 David Madison
                                      ;  *
                                      ;  * Permission is hereby granted, free of charge, to any person obtaining a copy
                                      ;  * of this software and associated documentation files (the "Software"), to deal
                                      ;  * in the Software without restriction, including without limitation the rights
                                      ;  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                                      ;  * copies of the Software, and to permit persons to whom the Software is
                                      ;  * furnished to do so, subject to the following conditions:
                                      ;  *
                                      ;  * The above copyright notice and this permission notice shall be included in
                                      ;  * all copies or substantial portions of the Software.
                                      ;  *
                                      ;  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                                      ;  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                                      ;  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                                      ;  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                                      ;  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                                      ;  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
                                      ;  * THE SOFTWARE.
                                      ;  *
                                      ;  */


                                      ; /*********************************************************************************************************
                                      ;   END FILE
                                      ; *********************************************************************************************************/

