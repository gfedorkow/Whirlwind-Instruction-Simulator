
                                      ; Tic Tac toe
                                      ; Guy Fedorkow
                                      ; Sep 26, 2024

                                      ; Simple game of tic-tac-toe written in Whirlwind assembly code.
                                      ; The game displays on the WW CRT, and can be played with the light gun
                                      ; (As of Sep 26, it's a two-person game, i.e., i alternates X and O plays)

                                      ; Geometry
                                      ; the basic game board is laid out on a 16x16 grid as follows:

                                      ;  cell 0   | cell 1   |  cell 2
                                      ;  @(4,12)  | @(8,12)  |  @(12,12)
                                      ; --------------------------------
                                      ;  cell 3   | cell 4   |  cell 5
                                      ;  @(4,8)   | @(8,8)   |  @(12,8)
                                      ; --------------------------------
                                      ;  cell 6   | cell 7   |  cell 8
                                      ;  @(4,4)   | @(8,4)   |  @(12,4)

                                      ;----------- old layout ----------
                                      ;  cell 6   | cell 7   |  cell 8
                                      ;  @(4,12)  | @(8,12)  |  @(12,12)
                                      ; --------------------------------
                                      ;  cell 3   | cell 4   |  cell 5
                                      ;  @(4,8)   | @(8,8)   |  @(12,8)
                                      ; --------------------------------
                                      ;  cell 0   | cell 1   |  cell 2
                                      ;  @(4,4)   | @(8,4)   |  @(12,4)
                                      ;-------------------------------

                                      .org 0
                                zero:
@0000:000000                 const_0: .word 0                  ; @@WrittenBy apc_table_ts upc_table_ts a0616 apm_copy_dst a0704 igb_table_ts a1426 a1461 a1664 a1701 a1726 a1744 a2010 a2016 ReadBy ca_addr a0156 dd_y_arg dd_x_arg dc_y_arg dc_x_arg dn_y_arg dn_x1_arg dw_y_arg dw_x_arg dt_y_arg dt_x_arg lgh_x1_arg lgh_y1_arg apc_ca0 upc_ca0 a0572 a0610 a0617 apm_copy_src a0636 a0646 a0655 a0705 a0722 itw_st_ca a0735 itw_cell_ts a0744 a0753 a0761 itw_inc_gb a1072 a1110 a1141 iML_bptr rd_brd1 rd_brd2 a1305 rd_brd3 a1315 a1331 a1347 a1365 a1375 a1400 a1425 a1460 a1612 a1617 a1627 a1640 a1647 a1660 a1665 a1711 a1722 a1727 a1752 a1753 a1776 a2004 a2063 a2067 a2270 a2302 a2325 a2330 JumpedToBy gb_state_sp a0161 a0331 a0346 a0370 a0411 a0433 a0452 a0471 a0501 light_gun_cell_hit_ret a0551 a0601 a0620 a0706 a0707 a1022 a1112 a1267 a1323 a1406 a1440 a1467 a1756 a2035 a2075 a2334
                                 one:
@0001:000001                 const_1: .word 1                  ; @@ReadBy a0052 a0114 a0116 a0120 a0510 a0547 a0642 a0720 a1257 a1264 a1266 a1322 a1327 a1356 a1417 a1447 a1452 a1666 a1670 a1700 a1730 a1732 a1743 a1772 a2012 a2015 a2276 a2300


                                      ; constants for SI graphics instruction
                                      .pp scope_vector, 0o1677 ; draw a vector on all scopes
                                      .pp scope_point, 0o0677  ; draw a point on all scopes



                                      .org 0o40


@0040:075071                    main: sp init_game_board       ; call the init subroutine
@0041:074046                          sp refresh_loop          ; branch to main display refresh loop

                                      ; constants
@0042:000017                    c_15: .word 15                 ; @@ReadBy a2272
@0043:000040                    c_32: .word 32
@0044:073300            c_scope_edge: .word 950 * 32           ; close to the edge of the scope screen @@ReadBy a0152 a2043
@0045:062000             c_msg_x_pos: .word 800 * 32           ; @@ReadBy a0154

@0046:074055            refresh_loop: sp draw_game_board       ; @@JumpedToBy a0041 a0050 a0054

@0047:100166                          ca light_gun_mailbox
@0050:070046                          cp refresh_loop
                                      .print "light gun hit at cell %d", light_gun_mailbox
@0051:074553                          sp user_play_cell        ; do something with the light gun hit!  ; this call is for person-vs-computer play
@0052:104001                          cs one
@0053:040166                          ts light_gun_mailbox     ; mark the mailbox as empty

@0054:074046                          sp refresh_loop



                                      ; ************* Refresh the game board display ********************
                                      ; draw the tic-tac-toe grid
                                      ; two horizontal lines first
                     draw_game_board:
@0055:050161                          ta draw_game_board_ret   ; @@JumpedToBy refresh_loop a2011
@0056:105115                          cs const_2
@0057:040167                          ts loop_count
@0060:101120                          ca const_6
@0061:040171                          ts y_arg
                         x_grid_loop:
@0062:101115                          ca const_2               ; @@JumpedToBy a0072
@0063:040170                          ts x_arg
@0064:105125                          cs const_11
@0065:040174                          ts n_segments            ; segment count should be negative, ie, we will incr the value until positive
@0066:074313                          sp draw_x_line

@0067:101124                          ca const_10
@0070:040171                          ts y_arg
@0071:130167                          ao loop_count
@0072:070062                          cp x_grid_loop

                                      ; two vertical lines next
@0073:105115                          cs const_2
@0074:040167                          ts loop_count
@0075:101120                          ca const_6
@0076:040170                          ts x_arg
                         y_grid_loop:
@0077:101115                          ca const_2               ; @@JumpedToBy a0107
@0100:040171                          ts y_arg
@0101:105125                          cs const_11
@0102:040174                          ts n_segments            ; segment count should be negative, ie, we will incr the value until positive
@0103:074332                          sp draw_y_line

@0104:101124                          ca const_10
@0105:040170                          ts x_arg
@0106:130167                          ao loop_count
@0107:070077                          cp y_grid_loop

                                      ; Draw the game_state, ie, dots, naughts, or crosses
                     draw_game_state:
@0110:105122                          cs const_8               ; nine passes; var should be 8; loop count is negative
@0111:040167                          ts loop_count
@0112:100257                          ca gb_table_start
@0113:040163                          ts next_x_addr
@0114:110001                          ad const_1
@0115:040164                          ts next_y_addr
@0116:110001                          ad const_1
@0117:040165                          ts next_gb_state_addr
@0120:104001                          cs one
@0121:040166                          ts light_gun_mailbox
                             gb_loop:
@0122:100163               gb_x_inst: ca next_x_addr           ; @@JumpedToBy a0145
@0123:040172                          ts x_addr_arg
@0124:100164               gb_y_inst: ca next_y_addr
@0125:040173                          ts y_addr_arg
@0126:100165              gb_gs_inst: ca next_gb_state_addr
@0127:044130                          td ca_addr
@0130:100000                 ca_addr: ca 0                     ; @@WrittenBy a0127
@0131:044132                          td gb_state_sp
@0132:074000             gb_state_sp: sp 0                     ; draw the X, O or dot; this call may have a side-effect of seeing a light-gun hit @@WrittenBy a0131

                                      ; increment pointers and loop count for the next pass
@0133:100163                          ca next_x_addr
@0134:111116                          ad const_3
@0135:040163                          ts next_x_addr
@0136:100164                          ca next_y_addr
@0137:111116                          ad const_3
@0140:040164                          ts next_y_addr
@0141:100165                          ca next_gb_state_addr
@0142:111116                          ad const_3
@0143:040165                          ts next_gb_state_addr
@0144:130167                          ao loop_count
@0145:070122                          cp gb_loop

                 draw_current_player:                          ; draw an alpha string at the bottom of the screen to show the state of the game
@0146:100176                          ca which_player          ; see definition for this number
@0147:175121                          md const_7               ; clear the sign bit in case of "Game Over"
@0150:110206                          ad state_msg_tablep
@0151:044156                          td dcp_ca_addr

@0152:104044                          cs c_scope_edge          ; set the location to draw a string
@0153:042100                          ts ds_argy
@0154:104045                          cs c_msg_x_pos
@0155:042077                          ts ds_argx
                         dcp_ca_addr:
@0156:100000                          ca 0                     ; get the pointer to the string into ACC @@WrittenBy a0151
@0157:076053                          sp draw_str              ; "print" the string on the screen

@0160:074472                          sp draw_reset_symbol     ; draw the symbol to call for a game reset

                 draw_game_board_ret:                          ; return from the 'board display' subroutine
@0161:074000                          sp 0                     ; @@WrittenBy a0055


                                      ; Global variables
@0162:000000             move_number: .word 0                  ; count the number of moves @@WrittenBy a0600 a1073 ReadBy a0571 a0600

                                      ; ephemeral loop state variables
@0163:000000             next_x_addr: .word 0                  ; @@WrittenBy a0113 a0135 ReadBy gb_x_inst a0133
@0164:000000             next_y_addr: .word 0                  ; @@WrittenBy a0115 a0140 ReadBy gb_y_inst a0136
@0165:000000      next_gb_state_addr: .word 0                  ; @@WrittenBy a0117 a0143 ReadBy gb_gs_inst a0141
@0166:177776       light_gun_mailbox: .word -1                 ; used to pass light-gun hits back from the drawing routine.  Negative means "no hit" @@WrittenBy a0053 a0121 a0524 ReadBy a0047

                          loop_count:                          ; used only in top-level routines for drawing the game board
@0167:000000                          .word 0                  ; @@WrittenBy a0057 a0071 a0074 a0106 a0111 a0144 a1100 a1106 ReadBy a0071 a0106 a0144 a1106


                                      ; Arguments to pass into routines
@0170:000000                   x_arg: .word 0                  ; @@WrittenBy a0063 a0076 a0105 a0322 a0326 ReadBy a0320 a0323 a0326 a0337
@0171:000000                   y_arg: .word 0                  ; @@WrittenBy a0061 a0070 a0100 a0343 ReadBy a0314 a0333 a0343
@0172:000000              x_addr_arg: .word 0                  ; pointer to x_addr @@WrittenBy a0123 ReadBy a0360 a0400 a0421 a0443 a0462 a0504
@0173:000000              y_addr_arg: .word 0                  ; @@WrittenBy a0125 ReadBy a0352 a0372 a0413 a0435 a0454 a0512
@0174:000000              n_segments: .word 0                  ; @@WrittenBy a0065 a0102 a0327 a0344 ReadBy a0327 a0344
@0175:000000            gb_state_arg: .word 0

                                      ;  Game Play State
                                      ; this var is zero or one to show which player is on-deck for the next move
                                      ; But it can also be set to negative to say "Game Over", or 2 to say Win, three to say Draw/Tie
                                      ; The var, less the sign bit, is used to index player_icon_table below
@0176:000000            which_player: .word 0                  ; @@WrittenBy a0550 a1002 a1005 a1021 a1111 ReadBy a0146 a0350 a0542 a0546 a0563

@0177:000007     player_state_x_addr: .word 7                  ; These two constants control where the X or O indicator lands on the screen
@0200:000001     player_state_y_addr: .word 1
@0201:000177      player_state_x_ptr: .word player_state_x_addr
@0202:000200      player_state_y_ptr: .word player_state_y_addr

                                      ; Static lookup table to find how to draw the current player state
                                      ; The table is a pointer to subroutine entry points
@0203:000204       player_icon_table: .word dct0               ; @@ReadBy a0541 a0562
@0204:000371                    dct0: .word draw_cross
@0205:000412                    dct1: .word draw_naught        ; @@ReadBy a0615 a0703
                                      ;dct2:       .word draw_win
                                      ;dct3:       .word draw_tie

@0206:000207        state_msg_tablep: .word state_msg_table    ; @@ReadBy a0150
                     state_msg_table:
@0207:000214                          .word msg_cross_play
@0210:000225                          .word msg_naught_play
@0211:000236                          .word msg_x_win
@0212:000244                          .word msg_o_win
@0213:000252                          .word msg_draw


                      msg_cross_play:
                                      ;            .flexl "PLAYER X"
@0214:000054                          .word 0o000054
@0215:000044                          .word 0o000044
@0216:000006                          .word 0o000006
@0217:000052                          .word 0o000052
@0220:000002                          .word 0o000002
@0221:000024                          .word 0o000024
@0222:000010                          .word 0o000010
@0223:000072                          .word 0o000072
@0224:177776                          .word -1

                     msg_naught_play:
                                      ;            .flexl "PLAYER O"
@0225:000054                          .word 0o054
@0226:000044                          .word 0o044
@0227:000006                          .word 0o006
@0230:000052                          .word 0o052
@0231:000002                          .word 0o002
@0232:000024                          .word 0o024
@0233:000010                          .word 0o010
@0234:000060                          .word 0o060
@0235:177776                          .word -1

                           msg_x_win:
                                      ;            .flexl "X WIN"
@0236:000072                          .word 0o072
@0237:000010                          .word 0o010
@0240:000046                          .word 0o046
@0241:000014                          .word 0o014
@0242:000030                          .word 0o030
@0243:177776                          .word -1

                           msg_o_win:
                                      ;            .flexl "O WIN"
@0244:000060                          .word 0o060
@0245:000010                          .word 0o010
@0246:000046                          .word 0o046
@0247:000014                          .word 0o014
@0250:000030                          .word 0o030
@0251:177776                          .word -1

                            msg_draw:
                                      ;            .flexl "DRAW"
@0252:000022                          .word 0o022
@0253:000024                          .word 0o024
@0254:000006                          .word 0o006
@0255:000046                          .word 0o046
@0256:177776                          .word -1



                                      ; Game State Variables
                                      ; The Game Table is a nine-entry array that has one entry for each cell of the game board.
                                      ; The position of each cell on the game board is static, but the "state" var shows
                                      ; whether the cell contains a dot, a naught or a cross
@0257:000260          gb_table_start: .word gb0_x              ; @@ReadBy a0112 a0536 a0557 a0612 a0624 a0701 a0732 a1074
                                      ; Game Board State
@0260:000004                   gb0_x: .word 4
@0261:000014                   gb0_y: .word 12
@0262:000347               gb0_state: .word draw_dot
@0263:000010                   gb1_x: .word 8
@0264:000014                   gb1_y: .word 12
@0265:000347               gb1_state: .word draw_dot
@0266:000014                   gb2_x: .word 12
@0267:000014                   gb2_y: .word 12
@0270:000347               gb2_state: .word draw_dot
@0271:000004                   gb3_x: .word 4
@0272:000010                   gb3_y: .word 8
@0273:000347               gb3_state: .word draw_dot
@0274:000010                   gb4_x: .word 8
@0275:000010                   gb4_y: .word 8
@0276:000347               gb4_state: .word draw_dot
@0277:000014                   gb5_x: .word 12
@0300:000010                   gb5_y: .word 8
@0301:000347               gb5_state: .word draw_dot
@0302:000004                   gb6_x: .word 4
@0303:000004                   gb6_y: .word 4
@0304:000347               gb6_state: .word draw_dot
@0305:000010                   gb7_x: .word 8
@0306:000004                   gb7_y: .word 4
@0307:000347               gb7_state: .word draw_dot
@0310:000014                   gb8_x: .word 12
@0311:000004                   gb8_y: .word 4
@0312:000347               gb8_state: .word draw_dot



                                      ; subroutine to draw a horizontal line
                         draw_x_line:
@0313:050331                          ta draw_x_line_ret       ; save the return address @@JumpedToBy a0066
@0314:100171                          ca y_arg
@0315:115122                          su const_8               ; shift from 0-15 axis to -8 to +7
@0316:154014                          slr 12                   ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@0317:001677                          si scope_vector          ; initialize vector gen ; Auto-Annotate I/O: Display Vectors
@0320:100170                          ca x_arg
@0321:115122                          su const_8               ; shift from 0-15 axis to -8 to +7
@0322:040170                          ts x_arg
                          next_x_seg:
@0323:100170                          ca x_arg                 ; re-fetch the next x_arg @@JumpedToBy a0330
@0324:154014                          slr 12                   ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0

@0325:025133                          rc horiz_line_seg        ; Draw a segment with x=ACC
@0326:130170                          ao x_arg
@0327:130174                          ao n_segments            ; increment the segment counter
@0330:070323                          cp next_x_seg
                     draw_x_line_ret:
@0331:074000                          sp 0                     ; @@WrittenBy a0313

                                      ; subroutine to draw a vertical line
                         draw_y_line:
@0332:050346                          ta draw_y_line_ret       ; save the return address @@JumpedToBy a0103
                          next_y_seg:
@0333:100171                          ca y_arg                 ; @@JumpedToBy a0345
@0334:115122                          su const_8               ; shift from 0-15 axis to -8 to +7
@0335:154014                          slr 12                   ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@0336:001677                          si scope_vector          ; initialize vector gen with the y-coord in ACC ; Auto-Annotate I/O: Display Vectors
@0337:100170                          ca x_arg
@0340:115122                          su const_8               ; shift from 0-15 axis to -8 to +7
@0341:154014                          slr 12                   ; gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0

@0342:025134                          rc vert_line_seg         ; Draw a segment with x=ACC
@0343:130171                          ao y_arg
@0344:130174                          ao n_segments            ; increment the segment counter
@0345:070333                          cp next_y_seg
                     draw_y_line_ret:
@0346:074000                          sp 0                     ; @@WrittenBy a0332




                                      ; subroutine to draw a light-gun dot in an unplayed game cell
                                      ; the args into this routine are addresses of x and y locations, not
                                      ; the locations themselves
                            draw_dot:
@0347:050370                          ta draw_dot_ret          ; save return address
@0350:100176                          ca which_player          ; test to see if there's another move allowed
@0351:070370                          cp draw_dot_ret          ; if the var is negative, we're done playing

@0352:100173                          ca y_addr_arg            ; assuming the game's not over, we continue to draw
@0353:044354                          td dd_y_arg
@0354:100000                dd_y_arg: ca 0                     ; @@WrittenBy a0353
@0355:115122                          su const_8
@0356:154014                          slr 12                   ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@0357:000677                          si scope_point           ; initialize point gen with the y-coord in ACC ; Auto-Annotate I/O: Display Points
@0360:100172                          ca x_addr_arg
@0361:044362                          td dd_x_arg
@0362:100000                dd_x_arg: ca 0                     ; @@WrittenBy a0361
@0363:115122                          su const_8               ; shift from 0-15 axis to -8 to +7
@0364:154014                          slr 12                   ; gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@0365:024000                          rc 0                     ; Draw a pont with x=ACC
@0366:014000                          rd 0                     ; read the light gun
@0367:070502                          cp light_gun_cell_hit    ; call a subroutine to handle the light gun.  The gun number is in ACC
                        draw_dot_ret:
@0370:074000                          sp 0                     ; @@WrittenBy a0347 JumpedToBy a0351


                                      ; draw an "X" centered on the screen at the position of the x and y args
                                      ; args are passed as addresses
                          draw_cross:
@0371:050411                          ta draw_cross_ret

@0372:100173                          ca y_addr_arg
@0373:044374                          td dc_y_arg
@0374:100000                dc_y_arg: ca 0                     ; @@WrittenBy a0373
@0375:115122                          su const_8               ; shift from 0-15 axis to -8 to +7
@0376:154014                          slr 12                   ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@0377:001677                          si scope_vector          ; initialize vector gen with the y-coord in ACC ; Auto-Annotate I/O: Display Vectors
@0400:100172                          ca x_addr_arg
@0401:044402                          td dc_x_arg
@0402:100000                dc_x_arg: ca 0                     ; @@WrittenBy a0401
@0403:115122                          su const_8               ; shift from 0-15 axis to -8 to +7
@0404:154014                          slr 12                   ; gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0

@0405:025135                          rc diag_up_right_seg     ; Draw a segment with x=ACC
@0406:025136                          rc diag_dn_left_seg      ; Draw a segment with x=ACC
@0407:025140                          rc diag_up_left_seg      ; Draw a segment with x=ACC
@0410:025137                          rc diag_dn_right_seg     ; Draw a segment with x=ACC
                      draw_cross_ret:
@0411:074000                          sp 0                     ; @@WrittenBy a0371

                                      ; draw an "naught" (i.e. a diamond) centered on the screen at the position of the x and y args
                                      ; args are passed as addresses
                         draw_naught:
@0412:050433                          ta draw_naught_ret

@0413:100173                          ca y_addr_arg
@0414:044415                          td dn_y_arg
@0415:100000                dn_y_arg: ca 0                     ; @@WrittenBy a0414
@0416:115122                          su const_8               ; shift from 0-15 axis to -8 to +7
@0417:154014                          slr 12                   ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@0420:001677                          si scope_vector          ; initialize vector gen with the y-coord in ACC ; Auto-Annotate I/O: Display Vectors
@0421:100172                          ca x_addr_arg
@0422:044423                          td dn_x1_arg
@0423:100000               dn_x1_arg: ca 0                     ; @@WrittenBy a0422
@0424:115123                          su const_9               ; shift from 0-15 axis to -8 to +7; plus an offset
@0425:154014                          slr 12                   ; gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0

@0426:025135                          rc diag_up_right_seg     ; Draw a segment with x=ACC
@0427:025137                          rc diag_dn_right_seg     ; Draw a segment with x=ACC

@0430:111127                          ad const_2_cell          ; shift the x-pos two cells right
@0431:025140                          rc diag_up_left_seg      ; Draw a segment with x=ACC
@0432:025136                          rc diag_dn_left_seg      ; Draw a segment with x=ACC

                     draw_naught_ret:
@0433:074000                          sp 0                     ; @@WrittenBy a0412

                                      ; placeholder to draw a Win symbol centered on the screen at the position of the x and y args
                                      ; args are passed as addresses
                            draw_win:
@0434:050452                          ta draw_win_ret

@0435:100173                          ca y_addr_arg
@0436:044437                          td dw_y_arg
@0437:100000                dw_y_arg: ca 0                     ; @@WrittenBy a0436
@0440:115122                          su const_8               ; shift from 0-15 axis to -8 to +7
@0441:154014                          slr 12                   ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@0442:001677                          si scope_vector          ; initialize vector gen with the y-coord in ACC ; Auto-Annotate I/O: Display Vectors
@0443:100172                          ca x_addr_arg
@0444:044445                          td dw_x_arg
@0445:100000                dw_x_arg: ca 0                     ; @@WrittenBy a0444
@0446:115122                          su const_8               ; shift from 0-15 axis to -8 to +7
@0447:154014                          slr 12                   ; gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0

@0450:025135                          rc diag_up_right_seg     ; Draw a segment with x=ACC
                                      ;          rc diag_dn_left_seg   ; Draw a segment with x=ACC
@0451:025140                          rc diag_up_left_seg      ; Draw a segment with x=ACC
                                      ;          rc diag_dn_right_seg  ; Draw a segment with x=ACC
                        draw_win_ret:
@0452:074000                          sp 0                     ; @@WrittenBy a0434

                                      ; placeholder to draw a Tie symbol centered on the screen at the position of the x and y args
                                      ; args are passed as addresses
                            draw_tie:
@0453:050471                          ta draw_tie_ret

@0454:100173                          ca y_addr_arg
@0455:044456                          td dt_y_arg
@0456:100000                dt_y_arg: ca 0                     ; @@WrittenBy a0455
@0457:115122                          su const_8               ; shift from 0-15 axis to -8 to +7
@0460:154014                          slr 12                   ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@0461:001677                          si scope_vector          ; initialize vector gen with the y-coord in ACC ; Auto-Annotate I/O: Display Vectors
@0462:100172                          ca x_addr_arg
@0463:044464                          td dt_x_arg
@0464:100000                dt_x_arg: ca 0                     ; @@WrittenBy a0463
@0465:115122                          su const_8               ; shift from 0-15 axis to -8 to +7
@0466:154014                          slr 12                   ; gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0

                                      ;          rc diag_up_right_seg  ; Draw a segment with x=ACC
@0467:025136                          rc diag_dn_left_seg      ; Draw a segment with x=ACC
                                      ;          rc diag_up_left_seg   ; Draw a segment with x=ACC
@0470:025137                          rc diag_dn_right_seg     ; Draw a segment with x=ACC
                        draw_tie_ret:
@0471:074000                          sp 0                     ; @@WrittenBy a0453


                   draw_reset_symbol:
@0472:050501                          ta draw_reset_symbol_ret ; @@JumpedToBy a0160
@0473:105121                          cs const_7               ; put the point at game-board coord (1, 1)
@0474:154014                          slr 12
                                      ; ACC contains the coord; use the same number for x and y
@0475:000677                          si scope_point           ; initialize point gen with the y-coord in ACC ; Auto-Annotate I/O: Display Points
@0476:024000                          rc 0                     ; Draw a pont with x=ACC
@0477:014000                          rd 0                     ; read the light gun
@0500:071071                          cp init_game_board       ; call a subroutine to handle the light gun.

               draw_reset_symbol_ret:
@0501:074000                          sp 0                     ; @@WrittenBy a0472



                                      ; ***************************  User Interaction ***********************

                                      ; Handle a user light_gun hit on one of the game cells
                                      ; Remember that this is called only from the routine that draws a
                                      ; dot in the middle of a cell on the game grid.
                                      ; This routine converts the y_address from screen polarity (more positive is up)
                                      ; to Game Board polarity (numbered from top=0 to bottom=2) by subtracting the
                                      ; light gun coord from three.
                                      ; The light gun number is passed to this routine in ACC
                  light_gun_cell_hit:
@0502:050526                          ta light_gun_cell_hit_ret; @@JumpedToBy a0367

@0503:040531                          ts lcl_gun_num
@0504:100172                          ca x_addr_arg
@0505:044506                          td lgh_x1_arg
@0506:100000              lgh_x1_arg: ca 0                     ; load the x value of the cell's address in the grid @@WrittenBy a0505
@0507:160002                          srr 2                    ; divide the cell x address by four to get 1, 2, or 3
@0510:114001                          su const_1               ; change from one-base to zero-base
@0511:040527                          ts lcl_cell_x

@0512:100173                          ca y_addr_arg            ; repeat the process for the y coordinate
@0513:044514                          td lgh_y1_arg
@0514:100000              lgh_y1_arg: ca 0                     ; load the y value of the cell's address in the grid @@WrittenBy a0513
@0515:160002                          srr 2                    ; divide the cell y address by four to get 1, 2, or 3
@0516:031114                          sd const_0n              ; invert to get negative number
@0517:111116                          ad const_3               ; change from one-base to zero-base and invert order
@0520:040530                          ts lcl_cell_y
@0521:155001                          slh 1                    ; multiply y by three, i.e., double then address
@0522:110530                          ad lcl_cell_y
@0523:110527                          ad lcl_cell_x            ; add x to get the cell number in the range 0-8

                                      .print "light gun %o hit x=%o, y=%o, cell=%ao", lcl_gun_num, lcl_cell_x, lcl_cell_y

                                      ; the cell number of thie hit is passed below in ACC
                                      ; sp alternate_play_cell   ; do something with the light gun hit!; this call is for two-person play
@0524:040166                          ts light_gun_mailbox
                                      ; sp user_play_cell   ; do something with the light gun hit!  ; this call is for person-vs-computer play

@0525:074713                          sp is_there_winner       ; test to see if it's Game Over

@0526:074000  light_gun_cell_hit_ret: sp 0                     ; @@WrittenBy a0502

                                      ; temp vars for figuring the cell number in light_gun_cell_hit
@0527:000000              lcl_cell_x: .word 0                  ; @@WrittenBy a0511 ReadBy a0523
@0530:000000              lcl_cell_y: .word 0                  ; @@WrittenBy a0520 ReadBy a0522
@0531:000000             lcl_gun_num: .word 0                  ; @@WrittenBy a0503


                                      ; "Play" a cell
                                      ; This routine does a simple two-person-style play; each light gun hit simply alternates
                                      ; between X and O
                                      ; The Cell Number to play is passed in the ACC
                                      ; Note that this routine can only be called on a previously-unplayed cell, 'cause those
                                      ; are the only ones with dots in them, and that's all the light gun can see
                 alternate_play_cell:
@0532:050551                          ta alternate_play_cell_ret

@0533:040552                          ts lcl_aplay_cell_num    ; figure the pointer to the first cell draw function in game table
@0534:155001                          slh 1                    ;  thats table_start + 3*cwll_num + 2
@0535:110552                          ad lcl_aplay_cell_num    ; multiply cell number by three for a table offset
@0536:110257                          ad gb_table_start
@0537:111115                          ad const_2
@0540:044545                          td apc_table_ts

@0541:100203                          ca player_icon_table     ; figure out what the new cell should be
@0542:110176                          ad which_player
@0543:044544                          td apc_ca0
@0544:100000                 apc_ca0: ca 0                     ; ACC should now contain the address of the X or O display routine @@WrittenBy a0543
@0545:040000            apc_table_ts: ts 0                     ; store the display routine to the game state table @@WrittenBy a0540

                                      ; now switch to the other player for the next move
@0546:100176                          ca which_player
@0547:030001                          sd const_1               ; xor a 1 into the LSB; i.e. 0->1 or 1->0
@0550:040176                          ts which_player

             alternate_play_cell_ret:
@0551:074000                          sp 0                     ; @@WrittenBy a0532
@0552:000000      lcl_aplay_cell_num: .word 0                  ; @@WrittenBy a0533 ReadBy a0535



                                      ; This routine plays person against computer; each light gun hit plays an Cross,
                                      ; then the machine plays Naught
                                      ; Note that this routine can only be called on a previously-unplayed cell, 'cause those
                                      ; are the only ones with dots in them, and that's all the light gun can see.
                                      ; The number of the cell being played is in ACC
                      user_play_cell:
@0553:050601                          ta user_play_cell_ret    ; @@JumpedToBy a0051

@0554:040602                          ts lcl_uplay_cell_num    ; figure the pointer to the first cell draw function in game table
@0555:155001                          slh 1                    ;  thats table_start + 3*cell_num + 2
@0556:110602                          ad lcl_uplay_cell_num    ; multiply cell number by three for a table offset
@0557:110257                          ad gb_table_start
@0560:111115                          ad const_2
@0561:044566                          td upc_table_ts

@0562:100203                          ca player_icon_table     ; figure out what the new cell should be
@0563:110176                          ad which_player
@0564:044565                          td upc_ca0
@0565:100000                 upc_ca0: ca 0                     ; ACC should now contain the address of the X or O display routine @@WrittenBy a0564
@0566:040000            upc_table_ts: ts 0                     ; store the display routine to the game state table @@WrittenBy a0561

@0567:074713                          sp is_there_winner       ; check to see if this user move ended the game
@0570:070600                          cp upc_cleanup           ; negative means it's a tie; no more moves

                                      ; now switch to the other player for the next move
                                      ; table_play_move is used to optimize the first move by a simple table lookup
                                      ; auto_play_move calls minimax to figure the best move, then makes the move
                                      ; by updating the icon on the game board.
@0571:100162                          ca move_number
@0572:134000                          dm 0                     ; test if this is Move Zero, i.e., the first user move
@0573:070576                          cp upc_move_zero         ; branch for first move, fall through for subsequent moves

@0574:074623                          sp auto_play_move
@0575:074600                          sp upc_cleanup

                       upc_move_zero:
@0576:100602                          ca lcl_uplay_cell_num    ; @@JumpedToBy a0573
@0577:074603                          sp table_play_move

                         upc_cleanup:
@0600:130162                          ao move_number           ; @@JumpedToBy a0570 a0575
                  user_play_cell_ret:
@0601:074000                          sp 0                     ; @@WrittenBy a0553
@0602:000000      lcl_uplay_cell_num: .word 0                  ; @@WrittenBy a0554 ReadBy a0556 a0576


                                      ; The first move is optimized to avoid MinMax. by using a Table lookup
                                      ; AC contains the cell number of the first human move
                     table_play_move:
@0603:050620                          ta table_play_move_ret   ; @@JumpedToBy a0577
@0604:040621                          ts lcl_tpm_user_move     ; stash the arg

@0605:101057                          ca first_move_table_start
@0606:110621                          ad lcl_tpm_user_move
@0607:044610                          td tpm_fetch_move_table
                tpm_fetch_move_table:
@0610:100000                          ca 0                     ; fetch the offset of the computer move that will be used to respond @@WrittenBy a0607
@0611:040622                          ts lcl_tpm_table_move
@0612:110257                          ad gb_table_start
@0613:111143                          ad c_2
@0614:044616                          td tpm_store_move
@0615:100205                          ca dct1                  ; this is wired to have the machine move Naught
                      tpm_store_move:
@0616:040000                          ts 0                     ; update the game state table @@WrittenBy a0614
                                      .print "User move to cell %d; Table-driven move to cell offset %d / 3, ts 0o%o 0o%ao", lcl_tpm_user_move, lcl_tpm_table_move, tpm_store_move
@0617:030000                          sd zero                  ; no-op for Print

                 table_play_move_ret:
@0620:074000                          sp 0                     ; @@WrittenBy a0603

                   lcl_tpm_user_move:
@0621:000000                          .word 0                  ; @@WrittenBy a0604 ReadBy a0606
                  lcl_tpm_table_move:
@0622:000000                          .word 0                  ; @@WrittenBy a0611



                                      ; set up to call findBestMove
                      auto_play_move:
@0623:050706                          ta apm_ret               ; @@JumpedToBy a0574
@0624:100257                          ca gb_table_start
@0625:111115                          ad const_2               ; the game piece is offset three from the table start
@0626:044633                          td apm_copy_src
@0627:101247                          ca boardp
@0630:044661                          td apm_copy_dst
@0631:105122                          cs const_8
@0632:040710                          ts lcl_apm_copy_count

@0633:100000            apm_copy_src: ca 0                     ; @@WrittenBy a0626 a0663 a0664 a0665 ReadBy a0663 a0664 a0665 JumpedToBy a0667
@0634:040711                          ts lcl_apm_cell_state

@0635:135033            apm_test_dot: dm dot_fn_addr           ; test if it's a Dot
@0636:134000                          dm 0
@0637:070641                          cp apm_its_a_dot
@0640:074644                          sp apm_test_naught
@0641:131027           apm_its_a_dot: ao lcl_dot_count         ; @@JumpedToBy a0637
@0642:104001                          cs one                   ; store -1 for "unplayed"
@0643:074661                          sp apm_copy_dst

@0644:100711         apm_test_naught: ca lcl_apm_cell_state    ; retrieve the cell state @@JumpedToBy a0640
@0645:135035                          dm naught_fn_addr        ; test if it's an X
@0646:134000                          dm 0
@0647:070651                          cp apm_its_a_naught
@0650:074653                          sp apm_test_cross
@0651:101153        apm_its_a_naught: ca c_oh                  ; load the value for a Naught @@JumpedToBy a0647
@0652:074661                          sp apm_copy_dst

@0653:100711          apm_test_cross: ca lcl_apm_cell_state    ; @@JumpedToBy a0650
@0654:135034                          dm cross_fn_addr         ; test if it's an X
@0655:134000                          dm 0
@0656:070660                          cp apm_its_a_cross
@0657:074707                          sp apm_panic             ; huh, it's not a dot, cross or naught
@0660:101152         apm_its_a_cross: ca c_XX                  ; load value for a cross @@JumpedToBy a0656
                                      ; fall through to finish the copy step

@0661:040000            apm_copy_dst: ts 0                     ; @@WrittenBy a0630 a0662 ReadBy a0662 JumpedToBy a0643 a0652
@0662:130661                          ao apm_copy_dst          ; step the destination once
@0663:130633                          ao apm_copy_src          ; step the source three times
@0664:130633                          ao apm_copy_src
@0665:130633                          ao apm_copy_src
@0666:130710                          ao lcl_apm_copy_count
@0667:070633                          cp apm_copy_src          ; around the loop again
                                      ; finished copying

                                      ; this ought to test who's playing whom, but the code below has the
                                      ; human player wired as Cross, the computer plays Nought
@0670:101153                          ca c_oh
@0671:041154                          ts player
@0672:101152                          ca c_XX
@0673:041155                          ts opponent
                                      ; .exec print_board(cm, rl("boardp"), rl("push_lcl_depth"), rl("player"), "calling findBestMove")
@0674:075767                          sp findBestMove          ; return the cell number for the Best Move in ACC
@0675:040712                          ts lcl_cell_for_move

                                      ; prepare to make the suggested move permanent in the game board
@0676:154001                          slr 1                    ; multiply cell number by three
@0677:110712                          ad lcl_cell_for_move
@0700:111143                          ad c_2                   ; point to cell state in game board table
@0701:110257                          ad gb_table_start
@0702:044704                          td apm_store_move

                                      ; ca player           ;  "player" is (1, 2) for (X, O); offset for player_tab (0, 1) for (X, O)
                                      ; su one
                                      ; ad player_icon_table  ; form a pointer to the icon table
                                      ; td apm_fetch_icon_fn
                                      ; ca dct1                 ; the code above should be "put back" to compute the right icon
                                      ; td apm_fetch_icon_fn

                                      .exec print_experiment(cm, cb, "move game board player %d to cell %d, function 0o%o to gb offset 0o%o", ("player", "lcl_cell_for_move", "apm_fetch_icon_fn", "apm_store_move"), 0)

                   apm_fetch_icon_fn:
@0703:100205                          ca dct1                  ; this address should be dynamically set, not fixed to "naught"
                      apm_store_move:
@0704:040000                          ts 0                     ; @@WrittenBy a0702
@0705:030000                          sd zero                  ; for debug

                             apm_ret:
@0706:074000                          sp 0                     ; @@WrittenBy a0623

                           apm_panic:
                                      .print "not dot, cross or naught in auto_play_move: lcl_apm_cell_state=0o%o", lcl_apm_cell_state
@0707:074000                          sp 0                     ; @@JumpedToBy a0657

                  lcl_apm_copy_count:
@0710:000000                          .word 0                  ; @@WrittenBy a0632 a0666 ReadBy a0666
                  lcl_apm_cell_state:
@0711:000000                          .word 0                  ; @@WrittenBy a0634 ReadBy apm_test_naught apm_test_cross
                   lcl_cell_for_move:
@0712:000000                          .word 0                  ; @@WrittenBy a0675 ReadBy a0677

                                      ;;;;;;;;;;;;;;;;;

                                      ; Analyze game for a winner
                                      ; This is done by counting X and O in each horiz & vert row, plus the two diagonals.
                                      ; The routine is controlled by a table giving the start cell and increment.  For each
                                      ; table entry, we count three cells in the game_board state array
                                      ; This routing contains two nested loops, the outer one that walks the analysis table,
                                      ; and the inner one that counts three cells
                                      ; This long subroutine goes in two parts
                                      ;   a) count what's in each cell on each row, column and diagonal (eight in all)
                                      ;   b) then see if anyone won
                                      ;   [future part c might determine if anyone could win on the next round]
                                      ; The second part also can determine if the game is tied, i.e., no open cells left to play
                     is_there_winner:
@0713:051022                          ta is_there_winner_ret   ; @@JumpedToBy a0525 a0567
                                      ; set up the outer loop
@0714:105121                          cs const_7
@0715:041023                          ts lcl_tb_loop_count
@0716:101036                          ca analysis_table_start  ; prepare pointers into the analysis table
@0717:044726                          td itw_st_ca
@0720:110001                          ad const_1
@0721:044766                          td itw_inc_gb
@0722:104000                          cs const_0               ; initialize with negative zero to simply zero-detect later
@0723:041030                          ts lcl_total_dots        ; count all the unplayed cells

                                      ; set up the inner loop
@0724:105115          itw_outer_loop: cs const_2               ; @@JumpedToBy a1014
@0725:041024                          ts lcl_cell_loop_count
@0726:100000               itw_st_ca: ca 0                     ; load the starting cell number from the table @@WrittenBy a0717 a1007 a1010 ReadBy a1007 a1010
@0727:041031                          ts lcl_cell_number
@0730:155001                          slh 1
@0731:111031                          ad lcl_cell_number
@0732:110257                          ad gb_table_start
@0733:111115                          ad const_2               ; move to the gb_state val in gb table
@0734:044741                          td itw_cell_ts           ; pointer to first entry for this try in the gb table

@0735:100000                          ca const_0
@0736:041025                          ts lcl_naught_count
@0737:041026                          ts lcl_cross_count
@0740:041027                          ts lcl_dot_count

                      itw_inner_loop:
@0741:100000             itw_cell_ts: ca 0                     ; fetch whatever is in this cell @@WrittenBy a0734 a0767 ReadBy a0765 JumpedToBy a0771
@0742:041032                          ts lcl_cell_state
@0743:135033                test_dot: dm dot_fn_addr           ; test if it's a Dot
@0744:134000                          dm 0
@0745:070747                          cp its_a_dot
@0746:074751                          sp test_naught
@0747:131027               its_a_dot: ao lcl_dot_count         ; @@JumpedToBy a0745
@0750:131030                          ao lcl_total_dots

@0751:101032             test_naught: ca lcl_cell_state        ; retrieve the cell state @@JumpedToBy a0746
@0752:135035                          dm naught_fn_addr        ; test if it's an X
@0753:134000                          dm 0
@0754:070756                          cp its_a_naught
@0755:074757                          sp test_cross
@0756:131025            its_a_naught: ao lcl_naught_count      ; @@JumpedToBy a0754

@0757:101032              test_cross: ca lcl_cell_state        ; @@JumpedToBy a0755
@0760:135034                          dm cross_fn_addr         ; test if it's an X
@0761:134000                          dm 0
@0762:070764                          cp its_a_cross
@0763:074765                          sp itw_inner_loop_test_end
@0764:131026             its_a_cross: ao lcl_cross_count       ; @@JumpedToBy a0762

             itw_inner_loop_test_end:
                                      ; move to next cell in the inner loop
@0765:100741                          ca itw_cell_ts           ; @@JumpedToBy a0763
@0766:110000              itw_inc_gb: ad 0                     ; add whatever the analysis table says is the increment @@WrittenBy a0721 a1011 a1012 ReadBy a1011 a1012
@0767:040741                          ts itw_cell_ts
@0770:131024                          ao lcl_cell_loop_count
@0771:070741                          cp itw_inner_loop        ; end of inner loop

                                      ; .print "analysis loop %o, dots=%o, crosses=%o, naughts=%o", lcl_tb_loop_count, lcl_dot_count, lcl_cross_count, lcl_naught_count
                                      ; test to see if there's a winner
@0772:101116                          ca const_3
@0773:135025                          dm lcl_naught_count
@0774:071001                          cp naught_win
@0775:101116                          ca const_3
@0776:135026                          dm lcl_cross_count
@0777:071004                          cp cross_win
@1000:075007                          sp itw_next_outer_loop

@1001:101131              naught_win: ca const_o_win           ; 02 with the sign bit @@JumpedToBy a0774
@1002:040176                          ts which_player          ; mark the game as "over" and a Win
                                      .print "naught win"
@1003:075007                          sp itw_next_outer_loop

@1004:101130               cross_win: ca const_x_win           ; @@JumpedToBy a0777
@1005:040176                          ts which_player          ; mark the game as "over" and a Win
                                      .print "cross win"
@1006:075007                          sp itw_next_outer_loop

                                      ; now move to next entry in outer loop
                 itw_next_outer_loop:
@1007:130726                          ao itw_st_ca             ; @@JumpedToBy a1000 a1003 a1006
@1010:130726                          ao itw_st_ca
@1011:130766                          ao itw_inc_gb
@1012:130766                          ao itw_inc_gb
@1013:131023                          ao lcl_tb_loop_count
@1014:070724                          cp itw_outer_loop

                                      .print "unplayed cells=0o%o", lcl_total_dots
@1015:101030                          ca lcl_total_dots
@1016:071020                          cp its_a_tie             ; negative zero means its a tie (i.e., zero dots found)
@1017:075022                          sp is_there_winner_ret   ; so if it's not negative, we're done

@1020:101132               its_a_tie: ca const_draw            ; table offset 04 with the sign bit @@JumpedToBy a1016
                                      .print "game tie"
@1021:040176                          ts which_player          ; mark the game as "over" and a Draw

                 is_there_winner_ret:
@1022:074000                          sp 0                     ; @@WrittenBy a0713 JumpedToBy a1017


                                      ; local variables
@1023:000000       lcl_tb_loop_count: .word 0                  ; @@WrittenBy a0715 a1013 ReadBy a1013
@1024:000000     lcl_cell_loop_count: .word 0                  ; @@WrittenBy a0725 a0770 ReadBy a0770
@1025:000000        lcl_naught_count: .word 0                  ; @@WrittenBy a0736 its_a_naught ReadBy its_a_naught a0773
@1026:000000         lcl_cross_count: .word 0                  ; @@WrittenBy a0737 its_a_cross ReadBy its_a_cross a0776
@1027:000000           lcl_dot_count: .word 0                  ; @@WrittenBy apm_its_a_dot a0740 its_a_dot ReadBy apm_its_a_dot its_a_dot
@1030:000000          lcl_total_dots: .word 0                  ; @@WrittenBy a0723 a0750 ReadBy a0750 a1015
@1031:000000         lcl_cell_number: .word 0                  ; @@WrittenBy a0727 ReadBy a0731
@1032:000000          lcl_cell_state: .word 0                  ; @@WrittenBy a0742 ReadBy test_naught test_cross

                                      ; static addresses
@1033:000347             dot_fn_addr: .word draw_dot           ; @@ReadBy apm_test_dot test_dot
@1034:000371           cross_fn_addr: .word draw_cross         ; @@ReadBy a0654 a0760
@1035:000412          naught_fn_addr: .word draw_naught        ; @@ReadBy a0645 a0752


                                      ; This table gives the instructions for analyzing each horizontal, vertical
                                      ; or diagonal possible win combinations.
                analysis_table_start:
@1036:001037                          .word analysis_table     ; @@ReadBy a0716
                      analysis_table:
@1037:000000                     at0: .word 0                  ; start cell  ; horizontal cells
@1040:000003                          .word 1 * 3              ; increment
@1041:000003                     at1: .word 3                  ; start cell
@1042:000003                          .word 1 * 3              ; increment
@1043:000006                     at2: .word 6                  ; start cell
@1044:000003                          .word 1 * 3              ; increment
@1045:000000                     at3: .word 0                  ; start cell  ; vertical cells
@1046:000011                          .word 3 * 3              ; increment
@1047:000001                     at4: .word 1                  ; start cell
@1050:000011                          .word 3 * 3              ; increment
@1051:000002                     at5: .word 2                  ; start cell
@1052:000011                          .word 3 * 3              ; increment
@1053:000000                     at6: .word 0                  ; start cell  ; up-right diagonal
@1054:000014                          .word 4 * 3              ; increment
@1055:000002                     at7: .word 2                  ; start cell  ; up-left diagonal
@1056:000006                          .word 2 * 3              ; increment


                                      ; This table identifies a pre-computed machine response
                                      ; to each of the possible first player moves
                                      ; i.e., if the player puts a cross in cell zero, respond
                                      ; with a naught in cell 4.
                                      ; Cell numbers are multiplied by three so they can be used to
                                      ; directly index the game state table.
              first_move_table_start:
@1057:001060                          .word first_move_table   ; @@ReadBy a0605
                    first_move_table:
@1060:000014                          .word 4 * 3              ;  0
@1061:000000                          .word 0 * 3              ;  1
@1062:000014                          .word 4 * 3              ;  2
@1063:000000                          .word 0 * 3              ;  3
@1064:000000                          .word 0 * 3              ;  4
@1065:000006                          .word 2 * 3              ;  5
@1066:000014                          .word 4 * 3              ;  6
@1067:000003                          .word 1 * 3              ;  7
@1070:000014                          .word 4 * 3              ;  8


                                      ;;;;;;;;;;;;;;;;
                                      ; Set all the game board cells to "unplayed"
                                      ; Initialize the game state
                     init_game_board:
@1071:051112                          ta init_game_board_ret   ; @@JumpedToBy main a0500

@1072:100000                          ca zero                  ; Reset the Move Counter to Zero
@1073:040162                          ts move_number

@1074:100257                          ca gb_table_start        ; calculate the offset into the game state table for this cell
@1075:111115                          ad const_2               ; offset to third table entry
@1076:045102                          td igb_table_ts          ; store the pointer to the first entry

@1077:105122                          cs const_8               ; nine passes; var should be 8; loop count is negative
@1100:040167                          ts loop_count
@1101:101113                igb_loop: ca lcl_init_val          ; fetch the address to use for the initial function pointer for each cell @@JumpedToBy a1107
@1102:040000            igb_table_ts: ts 0                     ; set a table entry to the default pointer @@WrittenBy a1076 a1105 ReadBy a1103
@1103:101102                          ca igb_table_ts          ; advance the pointer to the next entry
@1104:111116                          ad const_3
@1105:041102                          ts igb_table_ts
@1106:130167                          ao loop_count
@1107:071101                          cp igb_loop              ; around the loop until we've hit all nine entries

@1110:100000                          ca const_0
@1111:040176                          ts which_player

                                      ;;;;;
                                      ; debug - pre-populate two moves
                                      ;            ca dct0  ; X icon
                                      ;            ts gb0_state
                                      ;            ca dct1  ; O icon
                                      ;            ts gb1_state
                                      ;            ca dct1  ; O icon
                                      ;            ts gb2_state
                                      ;            ca dct0  ; X icon
                                      ;            ts gb3_state
                                      ;            ca dct1  ; O icon
                                      ;            ts gb4_state
                                      ;            ca dct0  ; X icon
                                      ;            ts gb7_state

                                      ;;;;;;
                 init_game_board_ret:
@1112:074000                          sp 0                     ; @@WrittenBy a1071
@1113:000347            lcl_init_val: .word draw_dot           ; @@ReadBy igb_loop

                                      ; ****************************************


                                      ; Constants
@1114:177777                const_0n: .word 0o177777           ; @@ReadBy a0516
@1115:000002                 const_2: .word 2                  ; @@ReadBy a0056 a0062 a0073 a0077 a0537 a0560 a0625 itw_outer_loop a0733 a1075
@1116:000003                 const_3: .word 3                  ; @@ReadBy a0134 a0137 a0142 a0517 a0772 a0775 a1104
@1117:000004                 const_4: .word 4
@1120:000006                 const_6: .word 6                  ; @@ReadBy a0060 a0075
@1121:000007                 const_7: .word 7                  ; @@ReadBy a0147 a0473 a0714
@1122:000010                 const_8: .word 8                  ; @@ReadBy a0110 a0315 a0321 a0334 a0340 a0355 a0363 a0375 a0403 a0416 a0440 a0446 a0457 a0465 a0631 a1077
@1123:000011                 const_9: .word 9                  ; @@ReadBy a0424
@1124:000012                const_10: .word 10                 ; @@ReadBy a0067 a0104
@1125:000013                const_11: .word 11                 ; loop counter for 12 iterations @@ReadBy a0064 a0101
@1126:000014                const_12: .word 12
@1127:020000            const_2_cell: .word 8192               ; decimal value of screen coord corresponding to two cells in width @@ReadBy a0430

@1130:100002             const_x_win: .word 0o100002           ; two plus sign bit @@ReadBy cross_win
@1131:100003             const_o_win: .word 0o100003           ; two plus sign bit @@ReadBy naught_win
@1132:100004              const_draw: .word 0o100004           ; three plus sign bit @@ReadBy its_a_tie


                                      ; these two constants give the delta values to draw a "maximum short vector"
@1133:076000          horiz_line_seg: .word 0o174 * 0o400      ; +32 in the top half of the word
@1134:000174           vert_line_seg: .word 0o174              ; +32 in the bottom half of the word
@1135:076174       diag_up_right_seg: .word 0o174 * 0o400 + 0o174
@1136:100200        diag_dn_left_seg: .word 0o200 * 0o400 + 0o200
@1137:076200       diag_dn_right_seg: .word 0o174 * 0o400 + 0o200
@1140:100174        diag_up_left_seg: .word 0o200 * 0o400 + 0o174


                                      ; ---------------------------------------

                          panic_stop:
@1141:100000                          ca 0                     ; @@JumpedToBy a1415
                                      .print "panic stop"
@1142:000000                          si 0                     ; ; Auto-Annotate I/O: unknown i/o device


                                      ; ;these are the values to be placed in a cell on the board to show
                                      ; who's playing which position
                                      .pp XX, 1
                                      .pp Oh, 2
                                      .pp None, -1

                                      ; Constants
@1143:000002                     c_2: .word 2                  ; @@ReadBy a0613 a0700 a1370 a1372
@1144:177775                    c_2n: .word -2                 ; for a loop of three @@ReadBy a1333 a1351
@1145:000003                     c_3: .word 3                  ; @@ReadBy a1340 a1345 a2312 a2315 a2320
@1146:000004                     c_4: .word 4                  ; @@ReadBy a1363
@1147:177767                    c_8n: .word -8                 ; for a loop of nine passes @@ReadBy a1253 a1651 a1713 a1774
@1150:000012                    c_10: .word 10                 ; @@ReadBy a1402 a1404 a1616 a1626
@1151:001750                  c_1000: .word 1000               ; BigNum @@ReadBy a1645 a1707 a1770
@1152:000001                    c_XX: .word XX                 ; @@ReadBy apm_its_a_cross a0672
@1153:000002                    c_oh: .word Oh                 ; @@ReadBy apm_its_a_naught a0670

                                      ; Global Variables
                                      ;Default state to start the game: player = 'x', opponent = 'o';
@1154:000001                  player: .word XX                 ; @@WrittenBy a0671 ReadBy a1377 a1663 a2007
@1155:000002                opponent: .word Oh                 ; @@WrittenBy a0673 ReadBy a1725



                                      ;#define GAME1
                                      ;#ifdef GAME1
                                      ;    char board[3][3] =
                                      ;     {
                                      ;         { '_', 'o', 'x' },
                                      ;         { 'x', 'o', '_' },
                                      ;         { '_', '_', '_' }
                                      ;     };
                                      ; #endif
                                      ; #ifdef GAME2
                                      ;    // X should win this game in one move, but it will try every possible alternative before figuring it out
                                      ;    char board[3][3] =
                                      ;    {
                                      ;        { '_', 'o', 'x' },
                                      ;        { '_', 'o', 'x' },
                                      ;        { '_', '_', '_' }
                                      ;    };
                                      ; #endif


                                      ; pointers - yuck :-(  This cell points to the first of several board layouts
@1156:000011                BRD_SIZE: .word board3 - board2    ; nine words per each boar layouts
                                      ; BRDS_COUNT: .word -5    ; six test board layouts (so far!)
                                      ; BRDS_COUNT: .word (first_boardp - boardp) / (board3 - board2) + 1    ; six test board layouts (so far!)
@1157:000001              BRDS_COUNT: .word 1                  ; set the count to do just one board


                                      ; Board Layout
                                      ;   0  1  2
                                      ;   3  4  5
                                      ;   6  7  8

@1160:001161            first_boardp: .word board2

                                      ;        { 'x', 'o', 'o' },
                                      ;        { 'x', 'o', 'x' },
                                      ;        { '_', '_', '_' }
@1161:000001                  board2: .word XX                 ; 0
@1162:000002                          .word Oh
@1163:000002                          .word Oh
@1164:000001                          .word XX                 ; 3
@1165:000002                          .word Oh
@1166:000001                          .word XX
@1167:177776                          .word None               ; 6
@1170:177776                          .word None
@1171:177776                          .word None

                                      ; X plays next, but Oh wins in one move
                                      ;        { '_', 'o', 'o' },
                                      ;        { 'x', 'o', 'x' },
                                      ;        { '_', '_', '_' }
@1172:177776                  board3: .word None               ; 0
@1173:000002                          .word Oh
@1174:000002                          .word Oh
@1175:000001                          .word XX                 ; 3
@1176:000002                          .word Oh
@1177:000001                          .word XX
@1200:177776                          .word None               ; 6
@1201:177776                          .word None
@1202:177776                          .word None

                                      ; Test evaluate_board, Rows
                                      ; First row is Not a Win, second row should detect a win by X
                                      ;        { '_', 'o', 'o' },
                                      ;        { 'x', 'x', 'x' },
                                      ;        { 'o', '_', '_' }
                     board_row_x_win:
@1203:177776                          .word None               ; 0
@1204:000002                          .word Oh
@1205:000002                          .word Oh
@1206:000001                          .word XX                 ; 3
@1207:000001                          .word XX
@1210:000001                          .word XX
@1211:000002                          .word Oh                 ; 6
@1212:177776                          .word None
@1213:177776                          .word None

                                      ; Test evaluate_board, Cols
                                      ; First col is Not a Win, second col should detect a win by 0
                                      ;        { '_', 'o', 'x' },
                                      ;        { 'x', 'o', 'x' },
                                      ;        { 'o', 'o', '_' }
                     board_col_o_win:
@1214:177776                          .word None               ; 0
@1215:000002                          .word Oh
@1216:000001                          .word XX
@1217:000001                          .word XX                 ; 3
@1220:000002                          .word Oh
@1221:000001                          .word XX
@1222:000002                          .word Oh                 ; 6
@1223:000002                          .word Oh
@1224:177776                          .word None

                                      ; Test evaluate_board, 2-4-6 diagonal
                                      ;        { '_', 'o', 'x' },
                                      ;        { 'o', 'x', 'o' },
                                      ;        { 'x', 'o', '_' }
                board_2_4_6_diagonal:
@1225:177776                          .word None               ; 0
@1226:000002                          .word Oh
@1227:000001                          .word XX
@1230:000002                          .word Oh                 ; 3
@1231:000001                          .word XX
@1232:000002                          .word Oh
@1233:000001                          .word XX                 ; 6
@1234:000002                          .word Oh
@1235:177776                          .word None

                                      ; X plays next, and 'should' play cell 8
                                      ;        { 'o', 'x', '_' },
                                      ;        { '_', 'o', '_' },
                                      ;        { '_', '_', '_' }
@1236:000002                  board4: .word Oh                 ; 0
@1237:000001                          .word XX
@1240:177776                          .word None
@1241:177776                          .word None               ; 3
@1242:000002                          .word Oh
@1243:177776                          .word None
@1244:177776                          .word None               ; 6
@1245:177776                          .word None
@1246:177776                          .word None


@1247:001236                  boardp: .word board4             ; board2 to scan all the games @@ReadBy a0627 a1251 a1273 a1653 a1715 a2000

                                      ; // This function returns true if there are moves
                                      ; // remaining on the board. It returns false if
                                      ; // there are no moves left to play.
                                      ; bool isMovesLeft()
                                      ; {
                                      ;     for (int i = 0; i<3; i++)
                                      ;         for (int j = 0; j<3; j++)
                                      ;             if (board[i][j]=='_')
                                      ;                 return true;
                                      ;     //printf("IsMovesLeft --> false\n");
                                      ;     return false;
                                      ; }
                                      ; IsMovesLeft returns positive if there are more moves, negative if there
                                      ; are no empty cells
                         isMovesLeft:
@1250:051267                          ta isMovesLeftRet        ; @@JumpedToBy a1635
@1251:101247                          ca boardp
@1252:045255                          td iML_bptr              ; store a pointer to the start of the game board
@1253:101147                          ca c_8n
@1254:041270                          ts iML_cnt
@1255:100000                iML_bptr: ca 0                     ; read the cell under test; If the cell is empty, there are move moves, we can stop @@WrittenBy a1252 a1261 ReadBy a1261 JumpedToBy a1263
@1256:071266                          cp iML_empty             ; branch if the cell is empty, ie, neither X or O.

@1257:100001                          ca one                   ; non-empty cell; prepare to return positive
@1260:041271                          ts iML_ret
@1261:131255                          ao iML_bptr              ; update the pointer to the next cell
@1262:131270                  iML_lp: ao iML_cnt               ; increment the loop count
@1263:071255                          cp iML_bptr              ; branch if not done yet

@1264:104001                          cs one                   ; no empty cells; return -1
@1265:075267                          sp isMovesLeftRet

                           iML_empty:
@1266:100001                          ca one                   ; return One for more moves left @@JumpedToBy a1256

                      isMovesLeftRet:
@1267:074000                          sp 0                     ; @@WrittenBy a1250 JumpedToBy a1265

                                      ; local variables
@1270:000000                 iML_cnt: .word 0                  ; loop counter @@WrittenBy a1254 iML_lp ReadBy iML_lp
@1271:000000                 iML_ret: .word 0                  ; return code @@WrittenBy a1260


                                      ; Helper routine for Evaluate_Board
                                      ; Check three adjacent cells to determine if they have the same player identifier
                                      ; Return the negative of the value if it's the same, or +1 if different (or if all three are -1, unoccupied)
                                      ; The offset from the start of the table is in ACC, the stride is in the "local"
                                      ; variable equ3_arg_stride
                                      ; The return value in the AC is inverted to make the test one level up a step
                                      ; simpler...  -1 or -2 means the row contains all X's or O's, +1 means they're not all
                                      ; the same.  The caller can then branch on negative to determine if the search for
                                      ; a winner is complete.
                                equ3:
@1272:051323                          ta equ3_ret              ; @@JumpedToBy a1336 a1354 a1366 a1373
@1273:111247                          ad boardp                ; add base pointer to the board array to offset
@1274:045275                          td rd_brd1
@1275:100000                 rd_brd1: ca 0                     ; read the first element @@WrittenBy a1274 ReadBy a1300
@1276:071322                          cp equ3_ret_not_equal
@1277:041325                          ts equ3_lcl_first_read   ; remember what's in the first cell

@1300:101275                          ca rd_brd1               ; calculate address for second cell by adding stride
@1301:111324                          ad equ3_arg_stride
@1302:045303                          td rd_brd2
@1303:100000                 rd_brd2: ca 0                     ; read the second element @@WrittenBy a1302 ReadBy a1310
@1304:115325                          su equ3_lcl_first_read   ; compare it to the first element read
@1305:134000                          dm zero
@1306:071310                          cp equ3_brd3             ; negative zero means they're the same; so test the third cell
@1307:075322                          sp equ3_ret_not_equal    ; otherwise, bail out

                           equ3_brd3:
@1310:101303                          ca rd_brd2               ; @@JumpedToBy a1306
@1311:111324                          ad equ3_arg_stride
@1312:045313                          td rd_brd3
@1313:100000                 rd_brd3: ca 0                     ; @@WrittenBy a1312
@1314:115325                          su equ3_lcl_first_read
@1315:134000                          dm zero
@1316:071320                          cp equ3_ret_equal        ; negative zero means they're the same
@1317:075322                          sp equ3_ret_not_equal

                      equ3_ret_equal:
@1320:105325                          cs equ3_lcl_first_read   ; return negative one or two @@JumpedToBy a1316
@1321:075323                          sp equ3_ret

                  equ3_ret_not_equal:
@1322:100001                          ca one                   ; @@JumpedToBy a1276 a1307 a1317
                                      ; fall through to equ3_ret

                            equ3_ret:
@1323:074000                          sp 0                     ; @@WrittenBy a1272 JumpedToBy a1321
                                      ; local vars and arguments
                     equ3_arg_stride:
@1324:000000                          .word 0                  ; @@WrittenBy a1330 a1346 a1364 a1371 ReadBy a1301 a1311
                 equ3_lcl_first_read:
@1325:000000                          .word 0                  ; @@WrittenBy a1277 ReadBy a1304 a1314 a1320




                                      ; // This is the evaluation function as discussed
                                      ; // in the previous article ( http://goo.gl/sJgv68 )
                                      ; int evaluate() {

                                      ;     // Checking for Rows for X or O victory.
                                      ;     for (int row = 0; row<3; row++)
                                      ;     {
                                      ;         if (board[row][0]==board[row][1] &&   // stride = +1
                                      ;             board[row][1]==board[row][2])
                                      ;         {
                                      ;             if (board[row][0]==player)
                                      ;                 return +10;
                                      ;             else if (board[row][0]==opponent)
                                      ;                 return -10;
                                      ;         }
                                      ;     }

                                      ;     // Checking for Columns for X or O victory.
                                      ;     for (int col = 0; col<3; col++)
                                      ;     {
                                      ;         if (board[0][col]==board[1][col] &&  // stride = +3
                                      ;             board[1][col]==board[2][col])
                                      ;         {
                                      ;             if (board[0][col]==player)
                                      ;                 return +10;
                                      ;             else if (board[0][col]==opponent)
                                      ;                 return -10;
                                      ;         }
                                      ;     }

                                      ;     // Checking for Diagonals for X or O victory.
                                      ;     if (board[0][0]==board[1][1] && board[1][1]==board[2][2])  // stride = +4
                                      ;     {
                                      ;         if (board[0][0]==player)
                                      ;             return +10;
                                      ;         else if (board[0][0]==opponent)
                                      ;             return -10;
                                      ;     }

                                      ;     if (board[0][2]==board[1][1] && board[1][1]==board[2][0])   // stride = +2
                                      ;     {
                                      ;         if (board[0][2]==player)
                                      ;             return +10;
                                      ;         else if (board[0][2]==opponent)
                                      ;             return -10;
                                      ;     }

                                      ;     // Else if none of them have won then return 0
                                      ;     return 0;
                                      ; }

                                      ; Evaluate the current board for win, lose or incomplete
                                      ; If it's a Win for the Player, return +10; if it's a Lose for the Player, return -10
                                      ; If the game is undecided, return zero
                                      ; This routine takes no input arguments
                      evaluate_board:
@1326:051406                          ta eval_ret              ; @@JumpedToBy a1613
                        eval_chk_row:
                                      ; check rows for a win; stride of three, starting at zero
@1327:100001                          ca one
@1330:041324                          ts equ3_arg_stride       ; set the equ3 stride to one, i.e., three adjacent horizontal cells
@1331:100000                          ca zero                  ; set the equ3 starting cell to row zero
@1332:041407                          ts eval_lcl_nxt_cell
@1333:101144                          ca c_2n                  ; initialize loop counter; prepare to go around the loop three times
@1334:041410                          ts eval_lcl_loop_count
                       eval_row_loop:
@1335:101407                          ca eval_lcl_nxt_cell     ; place offset of first cell to check in AC @@JumpedToBy a1344
@1336:075272                          sp equ3                  ; check one row
@1337:071377                          cp eval_score_players    ; match -- figure out who won

                    eval_chk_nxt_row:
@1340:101145                          ca c_3                   ; next row is three cells forward
@1341:111407                          ad eval_lcl_nxt_cell     ; compute the first cell of the next row
@1342:041407                          ts eval_lcl_nxt_cell
@1343:131410                          ao eval_lcl_loop_count
@1344:071335                          cp eval_row_loop         ; branch if there's another row to check, fall through if we've checked three rows

                                      ; no one won on rows, so go on to check columns

                        eval_chk_col:
                                      ; check cols for a win; stride of three, starting at zero
@1345:101145                          ca c_3
@1346:041324                          ts equ3_arg_stride       ; set the equ3 stride to three, i.e., three adjacent vertical cells
@1347:100000                          ca zero                  ; set the equ3 starting cell to col zero
@1350:041407                          ts eval_lcl_nxt_cell
@1351:101144                          ca c_2n                  ; initialize loop counter; prepare to go around the loop three times
@1352:041410                          ts eval_lcl_loop_count
                       eval_col_loop:
@1353:101407                          ca eval_lcl_nxt_cell     ; place offset of first cell to check in AC @@JumpedToBy a1362
@1354:075272                          sp equ3                  ; check one row
@1355:071377                          cp eval_score_players    ; match -- figure out who won

                    eval_chk_nxt_col:
@1356:100001                          ca one                   ; next col is one cell forward
@1357:111407                          ad eval_lcl_nxt_cell     ; compute the first cell of the next row
@1360:041407                          ts eval_lcl_nxt_cell
@1361:131410                          ao eval_lcl_loop_count
@1362:071353                          cp eval_col_loop         ; branch if there's another row to check, fall through if we've checked three rows

                                      ; there are only two diagonals, no loops here; just test 0, 4, 8 then 2, 4, 6
                  eval_chk_diagonal0:
@1363:101146                          ca c_4
@1364:041324                          ts equ3_arg_stride       ; set the equ3 stride to four, i.e., 0, 4, 8 diagonal cells
@1365:100000                          ca zero                  ; set the equ3 starting cell to col zero
@1366:075272                          sp equ3                  ; check one row
@1367:071377                          cp eval_score_players    ; match -- figure out who won

                  eval_chk_diagonal1:
@1370:101143                          ca c_2
@1371:041324                          ts equ3_arg_stride       ; set the equ3 stride to two, i.e., 2, 4, 6 diagonal cells
@1372:101143                          ca c_2                   ; set the equ3 starting cell to cell 2
@1373:075272                          sp equ3                  ; check one row
@1374:071377                          cp eval_score_players    ; match -- figure out who won

                                      ; nobody won; return 0
@1375:100000                          ca zero
@1376:075406                          sp eval_ret

                                      ; somebody won; check if it's the Player or Opponent
                                      ; The winner cell is -1 or -2 in AC; convert that to a score (recall equ3 results are inverted)
                                      ; depending on whether who's Player and who's Opponent at the moment
                  eval_score_players:
@1377:111154                          ad player                ; test to see if the current Player is the one that was found to have three winning cells @@JumpedToBy a1337 a1355 a1367 a1374
@1400:134000                          dm zero
@1401:071404                          cp eval_player_win

                        eval_opp_win:
@1402:105150                          cs c_10                  ; score an opponent win as -10
@1403:075406                          sp eval_ret

                     eval_player_win:
@1404:101150                          ca c_10                  ; score a Player win as +10 @@JumpedToBy a1401
@1405:075406                          sp eval_ret

                            eval_ret:
                                      ; .print "  Evaluate_Score returns %ad"
@1406:074000                          sp 0                     ; @@WrittenBy a1326 JumpedToBy a1376 a1403 a1405
                   eval_lcl_nxt_cell:
@1407:000000                          .word 0                  ; @@WrittenBy a1332 a1342 a1350 a1360 ReadBy a1335 a1341 a1353 a1357
                 eval_lcl_loop_count:
@1410:000000                          .word 0                  ; @@WrittenBy a1334 a1343 a1352 a1361 ReadBy a1343 a1361


                                      ; ================  MINIMAX Section =====================

                                      ; Two helper functions to save state for recursive calls
                                      ; to "push" onto the stack, we copy all the local minimax variables to
                                      ; where ever the stack pointer is pointing, then increment the stack
                                      ; pointer by the size of the frame
                         push_minmax:
@1411:051440                          ta push_ret              ; @@JumpedToBy a1611
@1412:041471                          ts push_pop_lcl_acc_stash; stash the AC
@1413:101475                          ca stack_size
@1414:115470                          su push_lcl_depth        ; test to be sure we're not running over the allocated space
@1415:071141                          cp panic_stop            ; branch if overflow

@1416:105473                          cs frame_size
@1417:110001                          ad one
@1420:041472                          ts push_pop_word_count   ; initialize the loop counter
@1421:101474                          ca minimax_retp          ; fetch the "source pointer"
@1422:045425                          td push_src
@1423:101476                          ca stackp                ; fetch the "destination pointer"
@1424:045426                          td push_dst

                            push_src:                          ; copy loop
@1425:100000                          ca 0                     ; filled in above @@WrittenBy a1422 a1427 ReadBy a1427 JumpedToBy a1432
                            push_dst:
@1426:040000                          ts 0                     ; @@WrittenBy a1424 a1430 ReadBy a1430
@1427:131425                          ao push_src
@1430:131426                          ao push_dst
@1431:131472                          ao push_pop_word_count
@1432:071425                          cp push_src              ; around the loop until the entire stack frame is copied

@1433:101476                          ca stackp                ; update the stack pointer for next time
@1434:111473                          ad frame_size
@1435:045476                          td stackp
@1436:131470                          ao push_lcl_depth

@1437:101471                          ca push_pop_lcl_acc_stash; retrieve the AC
                            push_ret:
@1440:074000                          sp 0                     ; subroutine return @@WrittenBy a1411


                          pop_minmax:
@1441:051467                          ta pop_ret               ; @@JumpedToBy a1755
@1442:041471                          ts push_pop_lcl_acc_stash; stash the AC
@1443:101476                          ca stackp                ; back up the stack pointer
@1444:115473                          su frame_size
@1445:045476                          td stackp
@1446:101470                          ca push_lcl_depth
@1447:114001                          su one
@1450:041470                          ts push_lcl_depth

@1451:105473                          cs frame_size
@1452:110001                          ad one
@1453:041472                          ts push_pop_word_count   ; initialize the loop counter
@1454:101474                          ca minimax_retp          ; fetch the "destination pointer"
@1455:045461                          td pop_dst
@1456:101476                          ca stackp                ; fetch the "source pointer"
@1457:045460                          td pop_src

                             pop_src:                          ; copy loop
@1460:100000                          ca 0                     ; filled in above @@WrittenBy a1457 a1462 ReadBy a1462 JumpedToBy a1465
                             pop_dst:
@1461:040000                          ts 0                     ; @@WrittenBy a1455 a1463 ReadBy a1463
@1462:131460                          ao pop_src
@1463:131461                          ao pop_dst
@1464:131472                          ao push_pop_word_count
@1465:071460                          cp pop_src               ; around the loop until the entire stack frame is copied

@1466:101471                          ca push_pop_lcl_acc_stash; retrieve the AC
                             pop_ret:
@1467:074000                          sp 0                     ; @@WrittenBy a1441

                      push_lcl_depth:
@1470:000000                          .word 0                  ; @@WrittenBy a1436 a1450 ReadBy a1414 a1436 a1446
              push_pop_lcl_acc_stash:
@1471:000000                          .word 0                  ; @@WrittenBy a1412 a1442 ReadBy a1437 a1466
                 push_pop_word_count:                          ; this var is the copy-word counter for push and pop
@1472:000000                          .word 0                  ; @@WrittenBy a1420 a1431 a1453 a1464 ReadBy a1431 a1464

                                      ; calculate the size of a single push on the stack
@1473:000007              frame_size: .word minmax_lcl_data_end - minmax_ret; @@ReadBy a1416 a1434 a1444 a1451
                        minimax_retp:                          ; Here's the address of the minimax local data to be pushed onto stack
@1474:001756                          .word minmax_ret         ; @@ReadBy a1421 a1454
                          stack_size:
@1475:000012                          .word 10                 ; I've allocated ten frames below for use of the stack @@ReadBy a1413


@1476:001477                  stackp: .word stack0             ; @@WrittenBy a1435 a1445 ReadBy a1423 a1433 a1443 a1456
@1477:000000                  stack0: .word 0                  ; frame 0
@1500:000000                          .word 0
@1501:000000                          .word 0
@1502:000000                          .word 0
@1503:000000                          .word 0
@1504:000000                          .word 0
@1505:000000                          .word 0
@1506:000000                          .word 0                  ; frame 1
@1507:000000                          .word 0
@1510:000000                          .word 0
@1511:000000                          .word 0
@1512:000000                          .word 0
@1513:000000                          .word 0
@1514:000000                          .word 0
@1515:000000                          .word 0                  ; frame 2
@1516:000000                          .word 0
@1517:000000                          .word 0
@1520:000000                          .word 0
@1521:000000                          .word 0
@1522:000000                          .word 0
@1523:000000                          .word 0
@1524:000000                          .word 0                  ; frame 3
@1525:000000                          .word 0
@1526:000000                          .word 0
@1527:000000                          .word 0
@1530:000000                          .word 0
@1531:000000                          .word 0
@1532:000000                          .word 0
@1533:000000                          .word 0                  ; frame 4
@1534:000000                          .word 0
@1535:000000                          .word 0
@1536:000000                          .word 0
@1537:000000                          .word 0
@1540:000000                          .word 0
@1541:000000                          .word 0
@1542:000000                          .word 0                  ; frame 5
@1543:000000                          .word 0
@1544:000000                          .word 0
@1545:000000                          .word 0
@1546:000000                          .word 0
@1547:000000                          .word 0
@1550:000000                          .word 0
@1551:000000                          .word 0                  ; frame 6
@1552:000000                          .word 0
@1553:000000                          .word 0
@1554:000000                          .word 0
@1555:000000                          .word 0
@1556:000000                          .word 0
@1557:000000                          .word 0
@1560:000000                          .word 0                  ; frame 7
@1561:000000                          .word 0
@1562:000000                          .word 0
@1563:000000                          .word 0
@1564:000000                          .word 0
@1565:000000                          .word 0
@1566:000000                          .word 0
@1567:000000                          .word 0                  ; frame 8
@1570:000000                          .word 0
@1571:000000                          .word 0
@1572:000000                          .word 0
@1573:000000                          .word 0
@1574:000000                          .word 0
@1575:000000                          .word 0
@1576:000000                          .word 0                  ; frame 9
@1577:000000                          .word 0
@1600:000000                          .word 0
@1601:000000                          .word 0
@1602:000000                          .word 0
@1603:000000                          .word 0
@1604:000000                          .word 0
@1605:000000                     eos: .word 0                  ; end of stack
@1606:001605              stack_endp: .word eos




                                      ; // This is the minimax function. It considers all
                                      ; // the possible ways the game can go and returns
                                      ; // the value of the board
                                      ; int minimax(int depth, bool isMax)
                                      ; {
                                      ;     int score = evaluate(board);
                                      ;     int m;
                                      ;     int best;

                                      ;     ; printf("%sMinimax Start\n", indent[depth+1]);
                                      ;     // If Maximizer has won the game return his/her
                                      ;     // evaluated score
                                      ;     if (score == 10) {
                                      ;         return score;
                                      ;         ; printf("%sMaximizer wins\n", indent[depth+1]);
                                      ;     }

                                      ;     // If Minimizer has won the game return his/her
                                      ;     // evaluated score
                                      ;     if (score == -10) {
                                      ;         ; printf("%sMinimizer Wins\n", indent[depth+1]);
                                      ;         return score;
                                      ;     }

                                      ;     // If there are no more moves and no winner then
                                      ;     // it is a tie
                                      ;     if (isMovesLeft(board)==false) {
                                      ;         ; printf("%sMinimax: No More Moves\n", indent[depth+1] );
                                      ;         return 0;
                                      ;     }

                                      ;     // If this maximizer's move
                                      ;     if (isMax)
                                      ;     {
                                      ;         best = -1000;

                                      ;         // Traverse all cells
                                      ;         for (int i = 0; i<3; i++)
                                      ;         {
                                      ;             for (int j = 0; j<3; j++)
                                      ;            {
                                      ;                // Check if cell is empty
                                      ;                if (board[i][j]=='_')
                                      ;                {
                                      ;                    // Make the move
                                      ;                    board[i][j] = player;

                                      ;                    // Call minimax recursively and choose
                                      ;                    // the maximum value
                                      ;                    //best = max( best,
                                      ;                    //    minimax(board, depth+1, !isMax) );
                                      ;                    m = minimax(depth+1, !isMax);
                                      ;                    //added by guy:
                                      ;                    m -= depth;
                                      ;                    ; printf("%sminimax isMAX=%d returned score %d  ", indent[depth+1], isMax, m);
                                      ;                    if (m > best) {
                                      ;                        best = m;
                                      ;                        ; printf("%sBest Higher\n", indent[depth+1]);
                                      ;                    } else {
                                      ;                        ; printf("\n");
                                      ;                    }
                                      ;                    ; print_board(depth);

                                      ;                    // Undo the move
                                      ;                    board[i][j] = '_';
                                      ;                }
                                      ;            }
                                      ;         }
                                      ;         return best;
                                      ;     }

                                      ;     // If this minimizer's move
                                      ;     else
                                      ;     {
                                      ;         best = 1000;

                                      ;         // Traverse all cells
                                      ;         for (int i = 0; i<3; i++)
                                      ;         {
                                      ;             for (int j = 0; j<3; j++)
                                      ;             {
                                      ;                 // Check if cell is empty
                                      ;                 if (board[i][j]=='_')
                                      ;                 {
                                      ;                     // Make the move
                                      ;                     board[i][j] = opponent;

                                      ;                     // Call minimax recursively and choose
                                      ;                     // the minimum value
                                      ;                     // best = min(best,
                                      ;                     //       minimax(depth+1, !isMax));
                                      ;                     m = minimax(depth+1, !isMax);
                                      ;                     ; for (int s = 0; s < depth; s++) printf("  ");
                                      ;                    //added by guy:
                                      ;                     m += depth;
                                      ;                     ; printf("    minimax isMAX=%d returned score %d  ", isMax, m);
                                      ;                      if (m < best) {
                                      ;                         best = m;
                                      ;                         ; printf("Best Lower\n");
                                      ;                     } else {
                                      ;                         ; printf("\n");
                                      ;                     }
                                      ;                     ; print_board(depth);

                                      ;                     // Undo the move
                                      ;                     board[i][j] = '_';
                                      ;                 }
                                      ;             }
                                      ;         }
                                      ;         return best;
                                      ;     }
                                      ; }


                                      ; This is the recursive module that tries all the combinations to find the
                                      ; best move.
                                      ; The routine takes one arg to say if we're trying to do Max or Min; Max is +1
                                      ; Min is -1, passed in AC
                             minimax:
@1607:051756                          ta minmax_ret            ; @@JumpedToBy a1667 a1731 a2013
@1610:041757                          ts minmax_lcl_isMax
@1611:075411                          sp push_minmax           ; store state on "the stack"
                                      ; .exec print_indent(cm, "Starting minimax: IsMax:%d, player: %d opponent %d, depth: %d" % (cm.rd(rl("minmax_lcl_isMax")), cm.rd(rl("player")), cm.rd(rl("opponent")), cm.rd(rl("push_lcl_depth"))), rl("push_lcl_depth"))
@1612:030000                          sd zero                  ; no-op
                                      ; .exec print_board(cm, rl("boardp"), rl("push_lcl_depth"), rl("player"), "Starting Minimax")
@1613:075326                          sp evaluate_board        ; figure out how we're doing
@1614:041760                          ts minmax_lcl_score

                     minmax_test_max:                          ; test if Maximizer has won
@1615:101760                          ca minmax_lcl_score
@1616:115150                          su c_10
@1617:134000                          dm 0                     ; test to see if score is +10
@1620:071622                          cp minmax_max_won        ; branch if yes
@1621:075625                          sp minmax_test_min

                      minmax_max_won:
                                      ; .print "Maximizer Won, score %d", minmax_lcl_score
@1622:101760                          ca minmax_lcl_score      ; @@JumpedToBy a1620
@1623:041763                          ts minmax_lcl_best       ; set up the return code
@1624:075752                          sp minmax_exit           ; all done

                     minmax_test_min:
@1625:101760                          ca minmax_lcl_score      ; @@JumpedToBy a1621
@1626:111150                          ad c_10
@1627:134000                          dm 0                     ; test to see if score is -10
@1630:071632                          cp minmax_min_won        ; branch if yes
@1631:075635                          sp minmax_test_tie

                      minmax_min_won:
                                      ; .print "Minimizer Won, score %d", minmax_lcl_score
@1632:101760                          ca minmax_lcl_score      ; @@JumpedToBy a1630
@1633:041763                          ts minmax_lcl_best       ; set up the return code
@1634:075752                          sp minmax_exit           ; all done

                     minmax_test_tie:
@1635:075250                          sp isMovesLeft           ; test if there are more moves to go @@JumpedToBy a1631
                                      ;.print "minmax_test_tie: isMovesLeft = %ad"
@1636:071640                          cp minmax_tie            ; Negative means "no more empty cells"
@1637:075643                          sp minmax_prepare_scan

                          minmax_tie:
@1640:100000                          ca zero                  ; @@JumpedToBy a1636
                                      ;.print "Minimax Tie"
@1641:041763                          ts minmax_lcl_best       ; set up the return code
@1642:075752                          sp minmax_exit           ; bail out

                 minmax_prepare_scan:
@1643:101757                          ca minmax_lcl_isMax      ; @@JumpedToBy a1637
@1644:071707                          cp minmax_not_isMax      ; branch if isMax == False

                                      ; ======== This section is "isMax == True" =============
                        minmax_isMax:
@1645:105151                          cs c_1000
@1646:041763                          ts minmax_lcl_best       ; initialize to Most Negative
@1647:100000                          ca zero                  ; prepare to scan all cells starting w/zero
@1650:041761                          ts minmax_lcl_next_cell
@1651:101147                          ca c_8n                  ; loop nine times
@1652:041762                          ts minmax_lcl_loop_cnt
                        minmax_loop1:
@1653:101247                          ca boardp                ; get the base board ptr to read the next cell @@JumpedToBy a1704
@1654:111761                          ad minmax_lcl_next_cell
@1655:045660                          td minmax_rd1
@1656:045664                          td minmax_wr1
@1657:045764                          td minmax_lcl_undo_move  ; this is only used _after_ the recursive call, and will need to be restored from stack
                          minmax_rd1:
@1660:100000                          ca 0                     ; fetch the next cell @@WrittenBy a1655
@1661:071663                          cp minmax_empty_cell1    ; continue if the cell is empty
@1662:075702                          sp minmax_loop1_end      ; go to the next loop step if the cell is not empty

                  minmax_empty_cell1:                          ; here, we know the cell we tested is empty, and a candidate for analysis
@1663:101154                          ca player                ; fetch the Player marker @@JumpedToBy a1661
                          minmax_wr1:
@1664:040000                          ts 0                     ; ... and write it into the cell @@WrittenBy a1656
                                      .exec print_experiment(cm, cb, "Trying  game piece %d to cell %d, count %d, isMax==True", ("player", "minmax_lcl_next_cell", "minmax_lcl_loop_cnt"), "push_lcl_depth")
@1665:030000                          sd zero                  ; no-op

                                      ;        cs zero                 ; load negative zero, i.e. all ones
                                      ;        sd minmax_lcl_isMax     ; Sum Digits, i.e., xor, will reverse isMax
@1666:104001                          cs one                   ; load -1 to signal isMax should be False
                                      ; here begins the recursion
                                      ; .exec print_indent(cm, "starting recursive call to minimax: isMax==True-branch, cell at %d, depth: %d, loop_count: %d" % (cm.rd(rl("minmax_lcl_next_cell")), cm.rd(rl("push_lcl_depth")), cm.rd(rl("minmax_lcl_loop_cnt"))), rl("push_lcl_depth"))
@1667:075607                          sp minimax
                                      ; the following adjustment probably shouldn't be done if the answer is Zero
@1670:114001                          su one                   ; push_lcl_depth       ; reduce the score by the calling depth
@1671:041766                          ts mm_lcl_ret_val        ; very local storage for the minimax return call
                                      ; .exec print_indent(cm, "finished recursive call to minimax: isMax==True-branch, cell at %d, depth: %d, loop_count: %d, score: 0o%o" % (cm.rd(rl("minmax_lcl_next_cell")), cm.rd(rl("push_lcl_depth")), cm.rd(rl("minmax_lcl_loop_cnt")), cm.rd(rl("mm_lcl_ret_val"))), rl("push_lcl_depth"))
@1672:115763                          su minmax_lcl_best       ; determine if this was the "best" score so far
@1673:071676                          cp minmax_not_best0      ; branch if we've seen a better score already

@1674:101766                          ca mm_lcl_ret_val        ; save this result as the Best Score So Far
@1675:041763                          ts minmax_lcl_best

                    minmax_not_best0:
@1676:101764                          ca minmax_lcl_undo_move  ; remember that modified instruction addresses are effectively local variables, so restore this one from the stack @@JumpedToBy a1673
                                      ;.exec print_experiment(cm, cb, "Undoing game piece %d in cell %d at 0o%o, isMax==True", ("player", "minmax_lcl_next_cell", "minmax_lcl_undo_move"), "push_lcl_depth")
@1677:045701                          td minmax_undo_move0
@1700:104001                          cs one                   ; undo the trial move
                   minmax_undo_move0:
@1701:040000                          ts 0                     ; @@WrittenBy a1677

                    minmax_loop1_end:                          ; get ready for the next cell iteration
@1702:131761                          ao minmax_lcl_next_cell  ; @@JumpedToBy a1662
@1703:131762                          ao minmax_lcl_loop_cnt
                                      ; .print "decrement loop count to %ad, depth: %d, isMax==True-branch", push_lcl_depth
@1704:071653                          cp minmax_loop1          ; go around again if the loop cnt is not exhausted

@1705:101763                          ca minmax_lcl_best       ; return the best score found in AC
@1706:075752                          sp minmax_exit           ; all done with this pass of isMax == True



                                      ; ======== This section is "isMax == False" =============
                    minmax_not_isMax:
@1707:101151                          ca c_1000                ; @@JumpedToBy a1644
@1710:041763                          ts minmax_lcl_best       ; initialize to Most Positive
@1711:100000                          ca zero                  ; prepare to scan all cells starting w/zero
@1712:041761                          ts minmax_lcl_next_cell
@1713:101147                          ca c_8n                  ; loop nine times
@1714:041762                          ts minmax_lcl_loop_cnt
                        minmax_loop2:
@1715:101247                          ca boardp                ; get the base board ptr to read the next cell @@JumpedToBy a1747
@1716:111761                          ad minmax_lcl_next_cell
@1717:045722                          td minmax_rd2
@1720:045726                          td minmax_wr2
@1721:045764                          td minmax_lcl_undo_move  ; store this address on the 'stack' for now
                          minmax_rd2:
@1722:100000                          ca 0                     ; fetch the next cell @@WrittenBy a1717
@1723:071725                          cp minmax_empty_cell2    ; continue if the cell is empty
@1724:075745                          sp minmax_loop2_end      ; go to the next loop step if the cell is not empty

                  minmax_empty_cell2:                          ; here, we know the cell we tested is empty, and a candidate for analysis
@1725:101155                          ca opponent              ; fetch the Opponent marker @@JumpedToBy a1723
                          minmax_wr2:
@1726:040000                          ts 0                     ; ... and write it into the cell @@WrittenBy a1720
                                      ; .exec print_experiment(cm, cb, "Trying  game piece %d in cell %d, count %d, isMax==False", ("opponent", "minmax_lcl_next_cell", "minmax_lcl_loop_cnt"), "push_lcl_depth")
@1727:030000                          sd zero                  ; no-op
                                      ;        cs zero                 ; load negative zero, i.e. all ones
                                      ;        sd minmax_lcl_isMax     ; Sum Digits, i.e., xor, will reverse isMax
@1730:100001                          ca one                   ; load -1 to signal isMax should be True
                                      ; here begins the recursion
                                      ; .exec print_indent(cm, "starting recursive call to minimax: isMax==False-branch, cell at %d, depth: %d, loop_count: %d" % (cm.rd(rl("minmax_lcl_next_cell")), cm.rd(rl("push_lcl_depth")), cm.rd(rl("minmax_lcl_loop_cnt"))), rl("push_lcl_depth"))
@1731:075607                          sp minimax
                                      ; the following adjustment probably shouldn't be done if the answer is Zero
@1732:110001                          ad one                   ;  push_lcl_depth       ; increase the (negative) score by the calling depth
@1733:041766                          ts mm_lcl_ret_val        ; very local storage for the minimax return value
                                      ; .exec print_indent(cm, "finished recursive call to minimax: isMax==False-branch, cell at %d, depth: %d, loop_count: %d, score: 0o%o" % (cm.rd(rl("minmax_lcl_next_cell")), cm.rd(rl("push_lcl_depth")), cm.rd(rl("minmax_lcl_loop_cnt")), cm.rd(rl("mm_lcl_ret_val"))), rl("push_lcl_depth"))


@1734:115763                          su minmax_lcl_best       ; determine if this was the "best" score so far
@1735:071737                          cp minmax_best2
@1736:075741                          sp minmax_not_best2      ; branch if we've seen a better score already

                        minmax_best2:
@1737:101766                          ca mm_lcl_ret_val        ; save this result as the Best Score So Far @@JumpedToBy a1735
@1740:041763                          ts minmax_lcl_best

                    minmax_not_best2:

@1741:101764                          ca minmax_lcl_undo_move  ; remember that modified instruction addresses are effectively local variables, so restore this one from the stack @@JumpedToBy a1736
                                      ; .exec print_experiment(cm, cb, "Undoing game piece %d in cell %d at 0o%o, isMax==False", ("player", "minmax_lcl_next_cell", "minmax_lcl_undo_move"), "push_lcl_depth")
@1742:045744                          td minmax_undo_move2
@1743:104001                          cs one                   ; undo the trial move
                   minmax_undo_move2:
@1744:040000                          ts 0                     ; @@WrittenBy a1742

                    minmax_loop2_end:                          ; get ready for the next cell iteration
@1745:131761                          ao minmax_lcl_next_cell  ; @@JumpedToBy a1724
@1746:131762                          ao minmax_lcl_loop_cnt
@1747:071715                          cp minmax_loop2          ; go around again if the loop cnt is not exhausted

@1750:101763                          ca minmax_lcl_best       ; return the best score found in AC
@1751:075752                          sp minmax_exit           ; all done with this pass of isMax == False


                         minmax_exit:
@1752:030000                          sd zero                  ; no-op for .exec @@JumpedToBy a1624 a1634 a1642 a1706 a1751
                                      ; .exec print_indent(cm, "Exiting minimax: IsMax:%d, depth: %d, score: %d" % (cm.rd(rl("minmax_lcl_isMax")), cm.rd(rl("push_lcl_depth")), cm.rd(rl("minmax_lcl_best"))), rl("push_lcl_depth"))
@1753:030000                          sd zero                  ; this is a no-op
                                      ; .exec print_board(cm, rl("boardp"), rl("push_lcl_depth"), rl("player") )
@1754:101763                          ca minmax_lcl_best

                                      ; note that we stash and retrieve the AC during PoP
@1755:075441                          sp pop_minmax
                          minmax_ret:
@1756:074000                          sp 0                     ; @@WrittenBy a1607

                                      ; the 'local data' for minmax must be copied/retrieved from the "stack" for recursion
                                      ; a "stack frame" must store from minmax_ret to minmax_lcl_data_end
@1757:000000        minmax_lcl_isMax: .word 0                  ; @@WrittenBy a1610 ReadBy a1643
@1760:000000        minmax_lcl_score: .word 0                  ; @@WrittenBy a1614 ReadBy a1615 a1622 a1625 a1632
@1761:000000    minmax_lcl_next_cell: .word 0                  ; @@WrittenBy a1650 a1702 a1712 a1745 ReadBy a1654 a1702 a1716 a1745
@1762:000000     minmax_lcl_loop_cnt: .word 0                  ; @@WrittenBy a1652 a1703 a1714 a1746 ReadBy a1703 a1746
@1763:000000         minmax_lcl_best: .word 0                  ; @@WrittenBy a1623 a1633 a1641 a1646 a1675 a1710 a1740 ReadBy a1672 a1705 a1734 a1750 a1754
@1764:000000    minmax_lcl_undo_move: .word 0                  ; @@WrittenBy a1657 a1721 ReadBy a1676 a1741
@1765:000000     minmax_lcl_data_end: .word 0                  ; this is just a marker for the end of data to be pushed

@1766:000000          mm_lcl_ret_val: .word 0                  ; @@WrittenBy a1671 a1733 ReadBy a1674 a1737



                                      ; // This will return the best possible move for the player
                                      ; // This routine used to return row and move with a single pointer to a struct.
                                      ; // Not a WW Kind of Thing, so I changed it to return two ints via args
                                      ; // struct Move findBestMove)
                                      ; void findBestMove(int *move_row, int *move_col)
                                      ; {
                                      ;     int bestVal = -1000;
                                      ;     int bestMove_row = -1;
                                      ;     int bestMove_col = -1;

                                      ;     // Traverse all cells, evaluate minimax function for
                                      ;     // all empty cells. And return the cell with optimal
                                      ;     // value.
                                      ;     for (int i = 0; i<3; i++)
                                      ;     {
                                      ;         for (int j = 0; j<3; j++)
                                      ;         {
                                      ;             // Check if cell is empty
                                      ;             if (board[i][j]=='_')
                                      ;             {
                                      ;                 // Make the move
                                      ;                 board[i][j] = player;

                                      ;                 // compute evaluation function for this
                                      ;                 // move.
                                      ;                 int moveVal = minimax(0, false);

                                      ;                 // Undo the move
                                      ;                 board[i][j] = '_';

                                      ;                 // If the value of the current move is
                                      ;                 // more than the best value, then update
                                      ;                 // best/
                                      ;                 printf("minimax returned %d  ", moveVal);
                                      ;                 if (moveVal > bestVal)
                                      ;                 {
                                      ;                     bestMove_row = i;
                                      ;                     bestMove_col = j;
                                      ;                     bestVal = moveVal;
                                      ;                     printf("Best\n");
                                      ;                 }
                                      ;                 else {
                                      ;                     printf("\n");
                                      ;                 }
                                      ;             }
                                      ;         }
                                      ;     }

                                      ;     printf("The value of the best Move for Player %c is : %d\n",
                                      ;             player, bestVal);

                                      ;     *move_row = bestMove_row;
                                      ;     *move_col = bestMove_col;
                                      ;     // return // bestMove;
                                      ; }


                                      ; findBestMove cycles through the board to find the move that results
                                      ; in the best score for the current Player
                                      ; The routine takes no explicit argument, but assumes that Player is the
                                      ; one we're trying to advance
                                      ; the assumption on calling this routine is that there's at least one move available to be tried
                        findBestMove:
@1767:052035                          ta fBM_ret               ; @@JumpedToBy a0674

                                      ; initialize the 'best stuff' detector
@1770:105151                          cs c_1000
@1771:042036                          ts fBM_lcl_best_value
                                      ; .print "Starting findBestMove, player=%d, opponent=%d", player, opponent
@1772:104001                          cs one
@1773:042037                          ts fBM_lcl_best_move
@1774:101147                          ca c_8n
@1775:042040                          ts fBM_lcl_loop_count
@1776:100000                          ca zero
@1777:042041                          ts fBM_lcl_current_cell
@2000:101247                          ca boardp                ; we always start from cell zero`
@2001:046004                          td fBM_fetch_cell
@2002:046010                          td fBM_set_cell
@2003:046016                          td fBM_clear_cell

                                      ; we start the loop here, but the first test will bypass the rest of the loop if the cell is already spoken for
                      fBM_fetch_cell:
@2004:100000                          ca 0                     ; read the current cell into AC @@WrittenBy a2001 a2026 ReadBy a2026 JumpedToBy a2033
@2005:072007                          cp fBM_try_move          ; if the cell is empty, go on to try out a move
@2006:076026                          sp fBM_next_loop         ; take a pass on this non-empty cell, go on to the next one

                        fBM_try_move:
@2007:101154                          ca player                ; @@JumpedToBy a2005
                                      ; try out a move on this cell
                                      .print "fBM: try  empty cell %d, player=%d", fBM_lcl_current_cell, player
                        fBM_set_cell:
@2010:040000                          ts 0                     ; @@WrittenBy a2002 a2027 ReadBy a2027
@2011:074055                          sp draw_game_board       ; this doesn't work yet -- unintended recursion...

@2012:104001                          cs one                   ; tell Minimax to try for a Min score on this cell
                                      ; .print "fBM: call minimax, player=%d, IsMax=%ad", player
@2013:075607                          sp minimax               ; call the optimizer; best-score comes back in AC
                                      ;.print "fBM: minimax returned %ad"
@2014:042042                          ts fBM_lcl_tmp_score     ; stash the score for now

@2015:104001                          cs one                   ; undo the trial move, then evaluate the results of minimax
                      fBM_clear_cell:
@2016:040000                          ts 0                     ; @@WrittenBy a2003 a2030 ReadBy a2030

                                      ; see if we bested a previous score
@2017:102042                          ca fBM_lcl_tmp_score     ; compare the new result with previous best
@2020:116036                          su fBM_lcl_best_value    ; branch if the old one was better; i.e., skip updating the eval_score_players
@2021:072026                          cp fBM_next_loop

@2022:102042                          ca fBM_lcl_tmp_score
@2023:042036                          ts fBM_lcl_best_value    ; save the New Best Score
@2024:102041                          ca fBM_lcl_current_cell  ; and remember how we got here, i.e., which cell we tried
                                      .print "fBM new Best Move: score %d, cell %d, loop: %d", fBM_lcl_tmp_score, fBM_lcl_current_cell, fBM_lcl_loop_count
@2025:042037                          ts fBM_lcl_best_move

                       fBM_next_loop:
@2026:132004                          ao fBM_fetch_cell        ; @@JumpedToBy a2006 a2021
@2027:132010                          ao fBM_set_cell
@2030:132016                          ao fBM_clear_cell
@2031:132041                          ao fBM_lcl_current_cell
@2032:132040                          ao fBM_lcl_loop_count
@2033:072004                          cp fBM_fetch_cell        ; go 'round the loop again

                                      ; when we're done with the loop, return the best move found (not the score, the cell that played best)
@2034:102037                          ca fBM_lcl_best_move
                                      .print "fBM findBestMove for player %d returns move to cell %ad, score=%d", player, fBM_lcl_best_value
                             fBM_ret:
@2035:074000                          sp 0                     ; @@WrittenBy a1767
                  fBM_lcl_best_value:                          ; best score found so far
@2036:000000                          .word 0                  ; @@WrittenBy a1771 a2023 ReadBy a2020
                   fBM_lcl_best_move:                          ; remember the move that resulted in the best score
@2037:000000                          .word 0                  ; @@WrittenBy a1773 a2025 ReadBy a2034
                  fBM_lcl_loop_count:
@2040:000000                          .word 0                  ; @@WrittenBy a1775 a2032 ReadBy a2032
                fBM_lcl_current_cell:
@2041:000000                          .word 0                  ; @@WrittenBy a1777 a2031 ReadBy a2024 a2031
                   fBM_lcl_tmp_score:
@2042:000000                          .word 0                  ; @@WrittenBy a2014 ReadBy a2017 a2022


                                      ;=====================================================================================

                                      ; /* 16-segment character generator, originally in Core Memory Clock
                                      ;  *
                                      ;  * Guy Fedorkow, Feb 22, 2025
                                      ;  *  originally for Arduino Mega
                                      ;  *
                                      ;  */



                      unit_test_main:
@2043:104044                          cs c_scope_edge          ; @@JumpedToBy a2050
@2044:042077                          ts ds_argx
@2045:042100                          ts ds_argy
@2046:102051                          ca msgp
@2047:076053                          sp draw_str
                                      ;si 0
@2050:076043                          sp unit_test_main


@2051:002052                    msgp: .word msg                ; @@ReadBy a2046
@2052:000030                     msg: .flexl "N"
@2052:000060                          .flexl "O"
@2052:000046                          .flexl "W"
@2052:000010                          .flexl " "
@2052:000014                          .flexl "I"
@2052:000012                          .flexl "S"
@2052:000010                          .flexl " "
@2052:000040                          .flexl "T"
@2052:000050                          .flexl "H"
@2052:000002                          .flexl "E"
@2052:000010                          .flexl " "
@2052:000040                          .flexl "T"
@2052:000014                          .flexl "I"
@2052:000070                          .flexl "M"
@2052:000002                          .flexl "E"
@2052:177776                          .word -1


                                      ; -----------------------------------------
                                      ; draw a character string on the CRT
                                      ; AC contains a pointer to the string, terminated by the first negative 'character'
                                      ; ds_argx and ds_argy give the initial (x, y) location
                            draw_str:
@2053:052075                          ta ds_ret                ; @@JumpedToBy a0157 a2047
@2054:046076                          td ds_lcl_charp          ; save the character pointer passed in the ACC
                             ds_loop:
@2055:102077                          ca ds_argx               ; @@JumpedToBy a2074
@2056:042335                          ts d16c_argx
@2057:102100                          ca ds_argy
@2060:042336                          ts d16c_argy
@2061:102076                          ca ds_lcl_charp          ; walk the string from start to finish
@2062:046063                          td ds_get_char
                         ds_get_char:
@2063:100000                          ca 0                     ; fetch the next character in the string @@WrittenBy a2062
@2064:076265                          sp draw_16seg_char       ; actually draw the character!

@2065:132076                          ao ds_lcl_charp          ; prepare for next char in loop
@2066:046067                          td ds_test_str_end
                     ds_test_str_end:
@2067:100000                          ca 0                     ; @@WrittenBy a2066
@2070:072075                          cp ds_ret                ; test for a negative number as the marker for the string end; branch out if done

@2071:102077                          ca ds_argx
@2072:112264                          ad char_spacing
@2073:042077                          ts ds_argx
@2074:076055                          sp ds_loop

                              ds_ret:
@2075:074000                          sp 0                     ; @@WrittenBy a2053 JumpedToBy a2070

@2076:000000            ds_lcl_charp: .word 0                  ; pointer to the next character to display @@WrittenBy a2054 a2065 ReadBy a2061 a2065
@2077:000000                 ds_argx: .word 0                  ; @@WrittenBy a0155 a2044 a2073 ReadBy a2055 a2071
@2100:000000                 ds_argy: .word 0                  ; @@WrittenBy a0153 a2045 ReadBy a2057

                                      ; ---------------------------

                                      ; The following table, indexed by ASCII character, gives a bit map of which of the 16
                                      ; segments should be lit for each symbol.
                SixteenSegmentFlexop:
@2101:002102                          .word SixteenSegmentFlexo; @@ReadBy a2266
                 SixteenSegmentFlexo:
                         flexo_ucase:
@2102:125074                          .word 0o125074           ; /* # */
@2103:125074                          .word 0o125074           ; /* # */
@2104:100363                          .word 0o100363           ; /* E */
@2105:104377                          .word 0o104377           ; /* 8 */
@2106:125074                          .word 0o125074           ; /* # */
@2107:000060                          .word 0o000060           ; /* _ */
@2110:104317                          .word 0o104317           ; /* A */
@2111:004077                          .word 0o004077           ; /* 3 */
@2112:000000                          .word 0o000000           ; /* (space) */
@2113:021000                          .word 0o021000           ; /* : */
@2114:104273                          .word 0o104273           ; /* S */
@2115:104214                          .word 0o104214           ; /* 4 */
@2116:021063                          .word 0o021063           ; /* I */
@2117:042000                          .word 0o042000           ; /* / */
@2120:000374                          .word 0o000374           ; /* U */
@2121:104167                          .word 0o104167           ; /* 2 */
@2122:177777                          .word 0o177777           ; /* (del) */
@2123:040400                          .word 0o040400           ; /* ) */
@2124:021077                          .word 0o021077           ; /* D */
@2125:110263                          .word 0o110263           ; /* 5 */
@2126:114307                          .word 0o114307           ; /* R */
@2127:002014                          .word 0o002014           ; /* 1 */
@2130:000174                          .word 0o000174           ; /* J */
@2131:000017                          .word 0o000017           ; /* 7 */
@2132:010714                          .word 0o010714           ; /* N */
@2133:012000                          .word 0o012000           ; /* ( */
@2134:100303                          .word 0o100303           ; /* F */
@2135:104373                          .word 0o104373           ; /* 6 */
@2136:000363                          .word 0o000363           ; /* C */
@2137:104000                          .word 0o104000           ; /* - */
@2140:112300                          .word 0o112300           ; /* K */
@2141:125074                          .word 0o125074           ; /* # */
@2142:021003                          .word 0o021003           ; /* T */
@2143:125074                          .word 0o125074           ; /* # */
@2144:042063                          .word 0o042063           ; /* Z */
@2145:177777                          .word 0o177777           ; /* (del) */
@2146:000360                          .word 0o000360           ; /* L */
@2147:000000                          .word 0o000000           ; /* (space) */
@2150:050314                          .word 0o050314           ; /* W */
@2151:125074                          .word 0o125074           ; /* # */
@2152:104314                          .word 0o104314           ; /* H */
@2153:000000                          .word 0o000000           ; /* (space) */
@2154:104274                          .word 0o104274           ; /* Y */
@2155:125074                          .word 0o125074           ; /* # */
@2156:104307                          .word 0o104307           ; /* P */
@2157:125074                          .word 0o125074           ; /* # */
@2160:010377                          .word 0o010377           ; /* Q */
@2161:125074                          .word 0o125074           ; /* # */
@2162:000377                          .word 0o000377           ; /* O */
@2163:177777                          .word 0o177777           ; /* (del) */
@2164:025077                          .word 0o025077           ; /* B */
@2165:125074                          .word 0o125074           ; /* # */
@2166:004373                          .word 0o004373           ; /* G */
@2167:125074                          .word 0o125074           ; /* # */
@2170:104277                          .word 0o104277           ; /* 9 */
@2171:125074                          .word 0o125074           ; /* # */
@2172:002714                          .word 0o002714           ; /* M */
@2173:177777                          .word 0o177777           ; /* (del) */
@2174:052400                          .word 0o052400           ; /* X */
@2175:125074                          .word 0o125074           ; /* # */
@2176:042300                          .word 0o042300           ; /* V */
@2177:177777                          .word 0o177777           ; /* (del) */
@2200:042377                          .word 0o042377           ; /* 0 */
@2201:177777                          .word 0o177777           ; /* (del) */


                                      ; Lower Case not used yet
                                      ;flexo_lcase:
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o140140   ; /* e */
                                      ;        .word 0o104377   ; /* 8 */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o021000   ; /* | */
                                      ;        .word 0o120160   ; /* a */
                                      ;        .word 0o004077   ; /* 3 */
                                      ;        .word 0o000000   ; /* (space) */
                                      ;        .word 0o104060   ; /* = */
                                      ;        .word 0o120241   ; /* s */
                                      ;        .word 0o104214   ; /* 4 */
                                      ;        .word 0o020000   ; /* i */
                                      ;        .word 0o125000   ; /* + */
                                      ;        .word 0o020140   ; /* u */
                                      ;        .word 0o104167   ; /* 2 */
                                      ;        .word 0o177777   ; /* (del) */
                                      ;        .word 0o010000   ; /* . */
                                      ;        .word 0o024034   ; /* d */
                                      ;        .word 0o110263   ; /* 5 */
                                      ;        .word 0o100100   ; /* r */
                                      ;        .word 0o002014   ; /* 1 */
                                      ;        .word 0o021140   ; /* j */
                                      ;        .word 0o000017   ; /* 7 */
                                      ;        .word 0o120100   ; /* n */
                                      ;        .word 0o040000   ; /* , */
                                      ;        .word 0o125002   ; /* f */
                                      ;        .word 0o104373   ; /* 6 */
                                      ;        .word 0o100140   ; /* c */
                                      ;        .word 0o104000   ; /* - */
                                      ;        .word 0o033000   ; /* k */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o100340   ; /* t */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o140040   ; /* z */
                                      ;        .word 0o177777   ; /* (del) */
                                      ;        .word 0o000300   ; /* l */
                                      ;        .word 0o000000   ; /* (space) */
                                      ;        .word 0o050110   ; /* w */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o120300   ; /* h */
                                      ;        .word 0o000000   ; /* (space) */
                                      ;        .word 0o005034   ; /* y */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o101301   ; /* p */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o121201   ; /* q */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o120140   ; /* o */
                                      ;        .word 0o177777   ; /* (del) */
                                      ;        .word 0o120340   ; /* b */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o121241   ; /* g */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o104277   ; /* 9 */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o124110   ; /* m */
                                      ;        .word 0o177777   ; /* (del) */
                                      ;        .word 0o052400   ; /* x */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o040100   ; /* v */
                                      ;        .word 0o177777   ; /* (del) */
                                      ;        .word 0o042377   ; /* 0 */
                                      ;        .word 0o177777   ; /* (del) */


                                      ; // size of 16-segment characters
                                      .pp WIDTH_16SEG, 0o60
                                      .pp HEIGHT_16SEG, 0o110
                                      .pp OFFSET_16SEG, 0o10   ; 0d08
                                      .pp SPACING_16SEG, (WIDTH_16SEG + WIDTH_16SEG / 4) * 64

                                      ; Delta word for vectors
                                      ;  Left 8 bits are horizontal, right 8 are vertical
                                      ;  Of each, only the six left bits are used

                                      .pp DOWN_LEFT, ((127 - (OFFSET_16SEG - 3)) * 256 * 2) + (255 - HEIGHT_16SEG)
                                      .pp UP_RIGHT, (OFFSET_16SEG - 3) * 256 * 2 + HEIGHT_16SEG
                                      .pp HORIZ_RIGHT, WIDTH_16SEG * 256

                                      .pp UP_RIGHT_DIAG, ((OFFSET_16SEG + WIDTH_16SEG) * 256) + HEIGHT_16SEG
                                      .pp DOWN_RIGHT_DIAG, ((WIDTH_16SEG - OFFSET_16SEG) * 256) + (255 - HEIGHT_16SEG)


                                      ; // these defines give the relative offsets for the points
                                      ; // that make up a 16-segment display
                                      .pp P0x, 64 * OFFSET_16SEG
                                      .pp P0y, 64 * HEIGHT_16SEG

                                      .pp P1x, 64 * (OFFSET_16SEG + WIDTH_16SEG / 2)
                                      .pp P1y, 64 * HEIGHT_16SEG

                                      .pp P2x, 64 * (OFFSET_16SEG + WIDTH_16SEG)
                                      .pp P2y, 64 * HEIGHT_16SEG

                                      .pp P3x, 64 * (OFFSET_16SEG / 2 + WIDTH_16SEG)
                                      .pp P3y, 64 * HEIGHT_16SEG / 2

                                      .pp P4x, 64 * WIDTH_16SEG
                                      .pp P4y, 64 * 0

                                      .pp P5x, 64 * WIDTH_16SEG / 2;  P0...P1...P2
                                      .pp P5y, 64 * 0          ;  .         .
                                      ;  .         .
                                      .pp P6x, 64 * 0          ;  .         .
                                      .pp P6y, 64 * 0          ;  P7...P8...P3
                                      ;  .         .
                                      .pp P7x, 64 * OFFSET_16SEG / 2;  .         .
                                      .pp P7y, 64 * HEIGHT_16SEG / 2;  .         .
                                      ;  P6...P5...P4

                                      .pp P8x, 64 * (OFFSET_16SEG / 2 + WIDTH_16SEG / 2)
                                      .pp P8y, 64 * HEIGHT_16SEG / 2


                                      ; // and this array gives sixteen starting points and delta for each line
                                      ; // segment in the 16-segment display character.

                      seg_tab_startp:
@2202:002203                          .word seg00x

@2203:001000                  seg00x: .word P0x                ;   {P0, P1}
@2204:011000                  seg00y: .word P0y
@2205:030000                  seg00d: .word HORIZ_RIGHT

@2206:004000                  seg01x: .word P1x                ;   {P1, P2},
@2207:011000                  seg01y: .word P1y
@2210:030000                  seg01d: .word HORIZ_RIGHT

@2211:007000                  seg02x: .word P2x                ;   {P2, P3},
@2212:011000                  seg02y: .word P2y
@2213:172267                  seg02d: .word DOWN_LEFT

@2214:006400                  seg03x: .word P3x                ;   {P3, P4},
@2215:004400                  seg03y: .word P3y
@2216:172267                  seg03d: .word DOWN_LEFT

@2217:003000                  seg04x: .word P5x                ;   {P4, P5},
@2220:000000                  seg04y: .word P5y
@2221:030000                  seg04d: .word HORIZ_RIGHT

@2222:000000                  seg05x: .word P6x                ;   {P5, P6},
@2223:000000                  seg05y: .word P6y
@2224:030000                  seg05d: .word HORIZ_RIGHT

@2225:000000                  seg06x: .word P6x                ;   {P6, P7},
@2226:000000                  seg06y: .word P6y
@2227:005110                  seg06d: .word UP_RIGHT

@2230:000400                  seg07x: .word P7x                ;   {P7, P0},
@2231:004400                  seg07y: .word P7y
@2232:005110                  seg07d: .word UP_RIGHT

@2233:001000                  seg08x: .word P0x                ;   {P0, P8},
@2234:011000                  seg08y: .word P0y
@2235:024267                  seg08d: .word DOWN_RIGHT_DIAG

@2236:004000                  seg09x: .word P1x                ;   {P1, P8},
@2237:011000                  seg09y: .word P1y
@2240:172267                  seg09d: .word DOWN_LEFT

@2241:003400                  seg10x: .word P8x                ;   {P2, P8},
@2242:004400                  seg10y: .word P8y
@2243:034110                  seg10d: .word UP_RIGHT_DIAG

@2244:003400                  seg11x: .word P8x                ;   {P3, P8},
@2245:004400                  seg11y: .word P8y
@2246:030000                  seg11d: .word HORIZ_RIGHT

@2247:003400                  seg12x: .word P8x                ;   {P4, P8},
@2250:004400                  seg12y: .word P8y
@2251:024267                  seg12d: .word DOWN_RIGHT_DIAG

@2252:003400                  seg13x: .word P8x                ;   {P5, P8},
@2253:004400                  seg13y: .word P8y
@2254:172267                  seg13d: .word DOWN_LEFT

@2255:000000                  seg14x: .word P6x                ;   {P6, P8},
@2256:000000                  seg14y: .word P6y
@2257:034110                  seg14d: .word UP_RIGHT_DIAG

@2260:000400                  seg15x: .word P7x                ;   {P7, P8},
@2261:004400                  seg15y: .word P7y
@2262:030000                  seg15d: .word HORIZ_RIGHT

                        seg_tab_endp:
@2263:002260                          .word seg15x             ; @@ReadBy a2274
                        char_spacing:
@2264:007400                          .word SPACING_16SEG      ; @@ReadBy a2072


                                      ; Draw a Flexo character passed in to this routine in the ACC
                                      ; First, find the segment map for a given character.  Input is a Flexo-coded character.
                                      ; The routine returns a 16-bit int where each bit represents one stroke in the character.  If the
                                      ; bit is one, draw the stroke; if not, don't draw.
                                      ; Character position is given by the args d16c_argx, d16c_argy.
                     draw_16seg_char:
@2265:052334                          ta d16c_ret              ; @@JumpedToBy a2064

@2266:112101                          ad SixteenSegmentFlexop  ; add the table start addr to the offset in ACC
@2267:046270                          td d16c_rd
                             d16c_rd:
@2270:100000                          ca 0                     ; fetch the bit map @@WrittenBy a2267
@2271:042337                          ts d16c_lcl_seg_map

                                      ; draw the sixteen segments, starting with the most significant bit
@2272:104042                          cs c_15                  ; prep for 16 times around the loop
@2273:042340                          ts d16c_lcl_loop_cnt
@2274:102263                          ca seg_tab_endp          ; walk the segment table back to front
@2275:046330                          td d16c_read_seg_tabx    ; first table entry
                                      ;        td tmp_tabx
@2276:110001                          ad one
@2277:046325                          td d16c_read_seg_taby    ; second table entry
                                      ;        td tmp_taby
@2300:110001                          ad one
@2301:046332                          td d16c_read_seg_tabdxy  ; third table entry

                                      ; I've commented out a bit of debug code here to draw dots at each of the junction points in the
                                      ; 16-segment figure.  Use this to verify that the line segments are the right length...
                           d16s_loop:
                                      ; this strip draws dots at the intersection points
@2302:100000                          ca 0                     ; no op @@JumpedToBy a2323
                                      ;tmp_taby:
                                      ;        ca 0
@2303:000677                          si scope_point           ; ; Auto-Annotate I/O: Display Points
                                      ;tmp_tabx:
                                      ;        ca 0
                                      ;        rc 0
                                      ; end of debug hack
@2304:102337                          ca d16c_lcl_seg_map
@2305:072325                          cp d16c_draw_seg         ; branch if most significant bit is on

                  d16s_loop_continue:
@2306:102337                          ca d16c_lcl_seg_map      ; @@JumpedToBy a2333
@2307:170001                          clc 1                    ; shift AC left by one bit
@2310:042337                          ts d16c_lcl_seg_map
@2311:102330                          ca d16c_read_seg_tabx
@2312:115145                          su c_3
@2313:046330                          td d16c_read_seg_tabx
                                      ;        td tmp_tabx
@2314:102325                          ca d16c_read_seg_taby
@2315:115145                          su c_3
@2316:046325                          td d16c_read_seg_taby
                                      ;        td tmp_taby
@2317:102332                          ca d16c_read_seg_tabdxy
@2320:115145                          su c_3
@2321:046332                          td d16c_read_seg_tabdxy
@2322:132340                          ao d16c_lcl_loop_cnt
@2323:072302                          cp d16s_loop
@2324:076334                          sp d16c_ret              ; bail out when count exhausted

                                      ; on entry to this code block, the three entries in the segment table should give:
                                      ;   _tab1 = X pos'n
                                      ;   _tab2 = Y pos'n
                                      ;   _tab3 = XY Delta vector
                       d16c_draw_seg:                          ; branch here if we're doing a segment, then return to the loop
                                      ; the SI uses the AC to set Y coord
                  d16c_read_seg_taby:
@2325:100000                          ca 0                     ; @@WrittenBy a2277 a2316 ReadBy a2314 JumpedToBy a2305
@2326:112336                          ad d16c_argy
@2327:001677                          si scope_vector          ; initialize vector gen with the y-coord in ACC ; Auto-Annotate I/O: Display Vectors

                                      ; the RC uses AC to set X coord and mem address for the vector length
                  d16c_read_seg_tabx:
@2330:100000                          ca 0                     ; @@WrittenBy a2275 a2313 ReadBy a2311
@2331:112335                          ad d16c_argx
                d16c_read_seg_tabdxy:
@2332:024000                          rc 0                     ; @@WrittenBy a2301 a2321 ReadBy a2317
@2333:076306                          sp d16s_loop_continue

                            d16c_ret:                          ;; Return from draw_16seg_char
@2334:074000                          sp 0                     ; @@WrittenBy a2265 JumpedToBy a2324

                           d16c_argx:
@2335:000000                          .word 0                  ; @@WrittenBy a2056 ReadBy a2331
                           d16c_argy:
@2336:000000                          .word 0                  ; @@WrittenBy a2060 ReadBy a2326
                    d16c_lcl_seg_map:
@2337:000000                          .word 0                  ; @@WrittenBy a2271 a2310 ReadBy a2304 a2306
                   d16c_lcl_loop_cnt:
@2340:000000                          .word 0                  ; @@WrittenBy a2273 a2322 ReadBy a2322





                                      ; Character Table license

                                      ; /*
                                      ;  *  Project     Segmented LED Display - ASCII Library
                                      ;  *  @author     David Madison
                                      ;  *  @link       github.com/dmadison/Segmented-LED-Display-ASCII
                                      ;  *  @license    MIT - Copyright (c) 2017 David Madison
                                      ;  *
                                      ;  * Permission is hereby granted, free of charge, to any person obtaining a copy
                                      ;  * of this software and associated documentation files (the "Software"), to deal
                                      ;  * in the Software without restriction, including without limitation the rights
                                      ;  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                                      ;  * copies of the Software, and to permit persons to whom the Software is
                                      ;  * furnished to do so, subject to the following conditions:
                                      ;  *
                                      ;  * The above copyright notice and this permission notice shall be included in
                                      ;  * all copies or substantial portions of the Software.
                                      ;  *
                                      ;  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                                      ;  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                                      ;  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                                      ;  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                                      ;  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                                      ;  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
                                      ;  * THE SOFTWARE.
                                      ;  *
                                      ;  */


                                      ; /*********************************************************************************************************
                                      ;   END FILE
                                      ; *********************************************************************************************************/

