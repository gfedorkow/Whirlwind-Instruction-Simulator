
                                      ; Tic Tac toe
                                      ; Guy Fedorkow
                                      ; Sep 26, 2024

                                      ; Simple game of tic-tac-toe written in Whirlwind assembly code.
                                      ; The game displays on the WW CRT, and can be played with the light gun
                                      ; (As of Sep 26, it's a two-person game, i.e., i alternates X and O plays)

                                      ; Geometry
                                      ; the basic game board is laid out on a 16x16 grid as follows:

                                      ;  cell 0   | cell 1   |  cell 2
                                      ;  @(4,12)  | @(8,12)  |  @(12,12)
                                      ; --------------------------------
                                      ;  cell 3   | cell 4   |  cell 5
                                      ;  @(4,8)   | @(8,8)   |  @(12,8)
                                      ; --------------------------------
                                      ;  cell 6   | cell 7   |  cell 8
                                      ;  @(4,4)   | @(8,4)   |  @(12,4)

                                      ;----------- old layout ----------
                                      ;  cell 6   | cell 7   |  cell 8
                                      ;  @(4,12)  | @(8,12)  |  @(12,12)
                                      ; --------------------------------
                                      ;  cell 3   | cell 4   |  cell 5
                                      ;  @(4,8)   | @(8,8)   |  @(12,8)
                                      ; --------------------------------
                                      ;  cell 0   | cell 1   |  cell 2
                                      ;  @(4,4)   | @(8,4)   |  @(12,4)
                                      ;-------------------------------

                                      .org 0
                                zero:
@0000:000000                 const_0: .word 0                  ; @@WrittenBy apc_table_ts upc_table_ts a0632 apm_copy_dst a0720 igb_table_ts a1444 a1477 a1702 a1721 a1746 a1764 a2033 a2041 ReadBy a0053 ca_addr a0171 dd_y_arg dd_x_arg dc_y_arg dc_x_arg dn_y_arg dn_x1_arg dw_y_arg dw_x_arg dt_y_arg dt_x_arg lgh_x1_arg lgh_y1_arg apc_ca0 upc_ca0 a0606 a0624 a0633 apm_copy_src a0652 a0662 a0671 a0721 a0736 itw_st_ca a0751 itw_cell_ts a0760 a0767 a0775 itw_inc_gb a1106 a1124 a1157 iML_bptr rd_brd1 rd_brd2 a1323 rd_brd3 a1333 a1347 a1365 a1403 a1413 a1416 a1443 a1476 a1630 a1635 a1645 a1656 a1665 a1676 a1703 a1704 a1731 a1742 a1747 a1772 a1773 a2021 a2027 a2144 a2150 a2351 a2363 a2406 a2411 JumpedToBy gb_state_sp a0174 a0344 a0361 a0403 a0424 a0446 a0465 a0504 a0514 light_gun_cell_hit_ret a0564 a0615 a0634 a0722 a0723 a1036 a1127 a1305 a1341 a1424 a1456 a1505 a1776 a2063 a2156 a2415
                                 one:
@0001:000001                 const_1: .word 1                  ; @@ReadBy a0057 a0062 set_game_over a0127 a0131 a0133 a0523 a0562 a0656 a0734 a1275 a1302 a1304 a1340 a1345 a1374 a1435 a1465 a1470 a1706 a1710 a1720 a1750 a1752 a1763 a2011 a2015 a2035 a2040 a2060 a2357 a2361


                                      ; constants for SI graphics instruction
                                      .pp scope_vector, 0o1677 ; draw a vector on all scopes
                                      .pp scope_point, 0o0677  ; draw a point on all scopes



                                      .org 0o40


@0040:075105                    main: sp init_game_board       ; call the init subroutine
@0041:074046                          sp refresh_loop          ; branch to main display refresh loop

                                      ; constants
@0042:000017                    c_15: .word 15                 ; @@ReadBy a2353
@0043:000040                    c_32: .word 32
@0044:073300            c_scope_edge: .word 950 * 32           ; close to the edge of the scope screen @@ReadBy a0165 a2071
@0045:062000             c_msg_x_pos: .word 800 * 32           ; @@ReadBy a0167

@0046:074070            refresh_loop: sp draw_game_board       ; @@JumpedToBy a0041 a0050 a0060 a0064 a0067
@0047:101131                          ca g_game_over           ; negative value means "game over"
@0050:070046                          cp refresh_loop
@0051:074727                          sp is_there_winner       ; check to see if this user move ended the game
@0052:100211                          ca which_player          ; if which_player is not zero, then the game has ended
@0053:134000                          dm zero
@0054:070056                          cp rl_continue_game
@0055:074065                          sp set_game_over         ; negative means no more moves

                    rl_continue_game:
@0056:100201                          ca light_gun_mailbox     ; @@JumpedToBy a0054
@0057:110001                          ad one                   ; convert -0 (cell zero) into +1 before the next CP test, then discard the result
@0060:070046                          cp refresh_loop
                                      .print "light gun hit at cell %d", light_gun_mailbox
                                      ; user_play_cell goes straight to the mailbox to find the current cell number.
@0061:074566                          sp user_play_cell        ; do something with the light gun hit!  ; this call is for person-vs-computer play
@0062:104001                          cs one                   ; put -1 in the mailbox to indicate Empty
@0063:040201                          ts light_gun_mailbox     ; mark the mailbox as empty

@0064:074046                          sp refresh_loop

@0065:104001           set_game_over: cs one                   ; the game_over flag starts set to zero by init_game_board @@JumpedToBy a0055
@0066:041131                          ts g_game_over           ; But when the game is over, we set it to -1
@0067:074046                          sp refresh_loop



                                      ; ************* Refresh the game board display ********************
                                      ; draw the tic-tac-toe grid
                                      ; two horizontal lines first
                     draw_game_board:
@0070:050174                          ta draw_game_board_ret   ; @@JumpedToBy refresh_loop a2034
@0071:105133                          cs const_2
@0072:040202                          ts loop_count
@0073:101136                          ca const_6
@0074:040204                          ts y_arg
                         x_grid_loop:
@0075:101133                          ca const_2               ; @@JumpedToBy a0105
@0076:040203                          ts x_arg
@0077:105143                          cs const_11
@0100:040207                          ts n_segments            ; segment count should be negative, ie, we will incr the value until positive
@0101:074326                          sp draw_x_line

@0102:101142                          ca const_10
@0103:040204                          ts y_arg
@0104:130202                          ao loop_count
@0105:070075                          cp x_grid_loop

                                      ; two vertical lines next
@0106:105133                          cs const_2
@0107:040202                          ts loop_count
@0110:101136                          ca const_6
@0111:040203                          ts x_arg
                         y_grid_loop:
@0112:101133                          ca const_2               ; @@JumpedToBy a0122
@0113:040204                          ts y_arg
@0114:105143                          cs const_11
@0115:040207                          ts n_segments            ; segment count should be negative, ie, we will incr the value until positive
@0116:074345                          sp draw_y_line

@0117:101142                          ca const_10
@0120:040203                          ts x_arg
@0121:130202                          ao loop_count
@0122:070112                          cp y_grid_loop

                                      ; Draw the game_state, ie, dots, naughts, or crosses
                     draw_game_state:
@0123:105140                          cs const_8               ; nine passes; var should be 8; loop count is negative
@0124:040202                          ts loop_count
@0125:100272                          ca gb_table_start
@0126:040176                          ts next_x_addr
@0127:110001                          ad const_1
@0130:040177                          ts next_y_addr
@0131:110001                          ad const_1
@0132:040200                          ts next_gb_state_addr
@0133:104001                          cs one
@0134:040201                          ts light_gun_mailbox
                             gb_loop:
@0135:100176               gb_x_inst: ca next_x_addr           ; @@JumpedToBy a0160
@0136:040205                          ts x_addr_arg
@0137:100177               gb_y_inst: ca next_y_addr
@0140:040206                          ts y_addr_arg
@0141:100200              gb_gs_inst: ca next_gb_state_addr
@0142:044143                          td ca_addr
@0143:100000                 ca_addr: ca 0                     ; @@WrittenBy a0142
@0144:044145                          td gb_state_sp
@0145:074000             gb_state_sp: sp 0                     ; draw the X, O or dot; this call may have a side-effect of seeing a light-gun hit @@WrittenBy a0144

                                      ; increment pointers and loop count for the next pass
@0146:100176                          ca next_x_addr
@0147:111134                          ad const_3
@0150:040176                          ts next_x_addr
@0151:100177                          ca next_y_addr
@0152:111134                          ad const_3
@0153:040177                          ts next_y_addr
@0154:100200                          ca next_gb_state_addr
@0155:111134                          ad const_3
@0156:040200                          ts next_gb_state_addr
@0157:130202                          ao loop_count
@0160:070135                          cp gb_loop

                 draw_current_player:                          ; draw an alpha string at the bottom of the screen to show the state of the game
@0161:100211                          ca which_player          ; see definition for this number
@0162:175137                          md const_7               ; clear the sign bit in case of "Game Over"
@0163:110221                          ad state_msg_tablep
@0164:044171                          td dcp_ca_addr

@0165:104044                          cs c_scope_edge          ; set the location to draw a string
@0166:042161                          ts ds_argy
@0167:104045                          cs c_msg_x_pos
@0170:042160                          ts ds_argx
                         dcp_ca_addr:
@0171:100000                          ca 0                     ; get the pointer to the string into ACC @@WrittenBy a0164
@0172:076134                          sp draw_str              ; "print" the string on the screen

@0173:074505                          sp draw_reset_symbol     ; draw the symbol to call for a game reset

                 draw_game_board_ret:                          ; return from the 'board display' subroutine
@0174:074000                          sp 0                     ; @@WrittenBy a0070


                                      ; Global variables
@0175:000000             move_number: .word 0                  ; count the number of moves @@WrittenBy a0614 a1107 ReadBy a0605 a0614

                                      ; ephemeral loop state variables
@0176:000000             next_x_addr: .word 0                  ; @@WrittenBy a0126 a0150 ReadBy gb_x_inst a0146
@0177:000000             next_y_addr: .word 0                  ; @@WrittenBy a0130 a0153 ReadBy gb_y_inst a0151
@0200:000000      next_gb_state_addr: .word 0                  ; @@WrittenBy a0132 a0156 ReadBy gb_gs_inst a0154
@0201:177776       light_gun_mailbox: .word -1                 ; used to pass light-gun hits back from the drawing routine.  Negative means "no hit" @@WrittenBy a0063 a0134 a0537 ReadBy a0056 a0567

                          loop_count:                          ; used only in top-level routines for drawing the game board
@0202:000000                          .word 0                  ; @@WrittenBy a0072 a0104 a0107 a0121 a0124 a0157 a1114 a1122 ReadBy a0104 a0121 a0157 a1122


                                      ; Arguments to pass into routines
@0203:000000                   x_arg: .word 0                  ; @@WrittenBy a0076 a0111 a0120 a0335 a0341 ReadBy a0333 a0336 a0341 a0352
@0204:000000                   y_arg: .word 0                  ; @@WrittenBy a0074 a0103 a0113 a0356 ReadBy a0327 a0346 a0356
@0205:000000              x_addr_arg: .word 0                  ; pointer to x_addr @@WrittenBy a0136 ReadBy a0373 a0413 a0434 a0456 a0475 a0517
@0206:000000              y_addr_arg: .word 0                  ; @@WrittenBy a0140 ReadBy a0365 a0405 a0426 a0450 a0467 a0525
@0207:000000              n_segments: .word 0                  ; @@WrittenBy a0100 a0115 a0342 a0357 ReadBy a0342 a0357
@0210:000000            gb_state_arg: .word 0

                                      ;  Game Play State
                                      ; this var is zero or one to show which player is on-deck for the next move
                                      ; But it can also be set to negative to say "Game Over", or 2 to say Win, three to say Draw/Tie
                                      ; The var, less the sign bit, is used to index player_icon_table below
@0211:000000            which_player: .word 0                  ; @@WrittenBy a0563 a1016 a1021 a1035 a1125 a2012 a2061 ReadBy a0052 a0161 a0363 a0555 a0561 a0577 a2010 a2057

@0212:000007     player_state_x_addr: .word 7                  ; These two constants control where the X or O indicator lands on the screen
@0213:000001     player_state_y_addr: .word 1
@0214:000212      player_state_x_ptr: .word player_state_x_addr
@0215:000213      player_state_y_ptr: .word player_state_y_addr

                                      ; Static lookup table to find how to draw the current player state
                                      ; The table is a pointer to subroutine entry points
@0216:000217       player_icon_table: .word dct0               ; @@ReadBy a0554 a0576
@0217:000404                    dct0: .word draw_cross
@0220:000425                    dct1: .word draw_naught        ; @@ReadBy a0631 a0717
                                      ;dct2:       .word draw_win
                                      ;dct3:       .word draw_tie

@0221:000222        state_msg_tablep: .word state_msg_table    ; @@ReadBy a0163
                     state_msg_table:
@0222:000227                          .word msg_cross_play
@0223:000240                          .word msg_naught_play
@0224:000251                          .word msg_x_win
@0225:000257                          .word msg_o_win
@0226:000265                          .word msg_draw


                      msg_cross_play:
                                      ;            .flexl "PLAYER X"
@0227:000054                          .word 0o000054
@0230:000044                          .word 0o000044
@0231:000006                          .word 0o000006
@0232:000052                          .word 0o000052
@0233:000002                          .word 0o000002
@0234:000024                          .word 0o000024
@0235:000010                          .word 0o000010
@0236:000072                          .word 0o000072
@0237:177776                          .word -1

                     msg_naught_play:
                                      ;            .flexl "PLAYER O"
@0240:000054                          .word 0o054
@0241:000044                          .word 0o044
@0242:000006                          .word 0o006
@0243:000052                          .word 0o052
@0244:000002                          .word 0o002
@0245:000024                          .word 0o024
@0246:000010                          .word 0o010
@0247:000060                          .word 0o060
@0250:177776                          .word -1

                           msg_x_win:
                                      ;            .flexl "X WIN"
@0251:000072                          .word 0o072
@0252:000010                          .word 0o010
@0253:000046                          .word 0o046
@0254:000014                          .word 0o014
@0255:000030                          .word 0o030
@0256:177776                          .word -1

                           msg_o_win:
                                      ;            .flexl "O WIN"
@0257:000060                          .word 0o060
@0260:000010                          .word 0o010
@0261:000046                          .word 0o046
@0262:000014                          .word 0o014
@0263:000030                          .word 0o030
@0264:177776                          .word -1

                            msg_draw:
                                      ;            .flexl "DRAW"
@0265:000022                          .word 0o022
@0266:000024                          .word 0o024
@0267:000006                          .word 0o006
@0270:000046                          .word 0o046
@0271:177776                          .word -1



                                      ; Game State Variables
                                      ; The Game Table is a nine-entry array that has one entry for each cell of the game board.
                                      ; The position of each cell on the game board is static, but the "state" var shows
                                      ; whether the cell contains a dot, a naught or a cross
@0272:000273          gb_table_start: .word gb0_x              ; @@ReadBy a0125 a0551 a0573 a0626 a0640 a0715 a0746 a1110
                                      ; Game Board State
@0273:000004                   gb0_x: .word 4
@0274:000014                   gb0_y: .word 12
@0275:000362               gb0_state: .word draw_dot
@0276:000010                   gb1_x: .word 8
@0277:000014                   gb1_y: .word 12
@0300:000362               gb1_state: .word draw_dot
@0301:000014                   gb2_x: .word 12
@0302:000014                   gb2_y: .word 12
@0303:000362               gb2_state: .word draw_dot
@0304:000004                   gb3_x: .word 4
@0305:000010                   gb3_y: .word 8
@0306:000362               gb3_state: .word draw_dot
@0307:000010                   gb4_x: .word 8
@0310:000010                   gb4_y: .word 8
@0311:000362               gb4_state: .word draw_dot
@0312:000014                   gb5_x: .word 12
@0313:000010                   gb5_y: .word 8
@0314:000362               gb5_state: .word draw_dot
@0315:000004                   gb6_x: .word 4
@0316:000004                   gb6_y: .word 4
@0317:000362               gb6_state: .word draw_dot
@0320:000010                   gb7_x: .word 8
@0321:000004                   gb7_y: .word 4
@0322:000362               gb7_state: .word draw_dot
@0323:000014                   gb8_x: .word 12
@0324:000004                   gb8_y: .word 4
@0325:000362               gb8_state: .word draw_dot



                                      ; subroutine to draw a horizontal line
                         draw_x_line:
@0326:050344                          ta draw_x_line_ret       ; save the return address @@JumpedToBy a0101
@0327:100204                          ca y_arg
@0330:115140                          su const_8               ; shift from 0-15 axis to -8 to +7
@0331:154014                          slr 12                   ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@0332:001677                          si scope_vector          ; initialize vector gen ; Auto-Annotate I/O: Display Vectors
@0333:100203                          ca x_arg
@0334:115140                          su const_8               ; shift from 0-15 axis to -8 to +7
@0335:040203                          ts x_arg
                          next_x_seg:
@0336:100203                          ca x_arg                 ; re-fetch the next x_arg @@JumpedToBy a0343
@0337:154014                          slr 12                   ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0

@0340:025151                          rc horiz_line_seg        ; Draw a segment with x=ACC
@0341:130203                          ao x_arg
@0342:130207                          ao n_segments            ; increment the segment counter
@0343:070336                          cp next_x_seg
                     draw_x_line_ret:
@0344:074000                          sp 0                     ; @@WrittenBy a0326

                                      ; subroutine to draw a vertical line
                         draw_y_line:
@0345:050361                          ta draw_y_line_ret       ; save the return address @@JumpedToBy a0116
                          next_y_seg:
@0346:100204                          ca y_arg                 ; @@JumpedToBy a0360
@0347:115140                          su const_8               ; shift from 0-15 axis to -8 to +7
@0350:154014                          slr 12                   ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@0351:001677                          si scope_vector          ; initialize vector gen with the y-coord in ACC ; Auto-Annotate I/O: Display Vectors
@0352:100203                          ca x_arg
@0353:115140                          su const_8               ; shift from 0-15 axis to -8 to +7
@0354:154014                          slr 12                   ; gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0

@0355:025152                          rc vert_line_seg         ; Draw a segment with x=ACC
@0356:130204                          ao y_arg
@0357:130207                          ao n_segments            ; increment the segment counter
@0360:070346                          cp next_y_seg
                     draw_y_line_ret:
@0361:074000                          sp 0                     ; @@WrittenBy a0345




                                      ; subroutine to draw a light-gun dot in an unplayed game cell
                                      ; the args into this routine are addresses of x and y locations, not
                                      ; the locations themselves
                            draw_dot:
@0362:050403                          ta draw_dot_ret          ; save return address
@0363:100211                          ca which_player          ; test to see if there's another move allowed
@0364:070403                          cp draw_dot_ret          ; if the var is negative, we're done playing

@0365:100206                          ca y_addr_arg            ; assuming the game's not over, we continue to draw
@0366:044367                          td dd_y_arg
@0367:100000                dd_y_arg: ca 0                     ; @@WrittenBy a0366
@0370:115140                          su const_8
@0371:154014                          slr 12                   ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@0372:000677                          si scope_point           ; initialize point gen with the y-coord in ACC ; Auto-Annotate I/O: Display Points
@0373:100205                          ca x_addr_arg
@0374:044375                          td dd_x_arg
@0375:100000                dd_x_arg: ca 0                     ; @@WrittenBy a0374
@0376:115140                          su const_8               ; shift from 0-15 axis to -8 to +7
@0377:154014                          slr 12                   ; gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@0400:024000                          rc 0                     ; Draw a pont with x=ACC
@0401:014000                          rd 0                     ; read the light gun
@0402:070515                          cp light_gun_cell_hit    ; call a subroutine to handle the light gun.  The gun number is in ACC
                        draw_dot_ret:
@0403:074000                          sp 0                     ; @@WrittenBy a0362 JumpedToBy a0364


                                      ; draw an "X" centered on the screen at the position of the x and y args
                                      ; args are passed as addresses
                          draw_cross:
@0404:050424                          ta draw_cross_ret

@0405:100206                          ca y_addr_arg
@0406:044407                          td dc_y_arg
@0407:100000                dc_y_arg: ca 0                     ; @@WrittenBy a0406
@0410:115140                          su const_8               ; shift from 0-15 axis to -8 to +7
@0411:154014                          slr 12                   ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@0412:001677                          si scope_vector          ; initialize vector gen with the y-coord in ACC ; Auto-Annotate I/O: Display Vectors
@0413:100205                          ca x_addr_arg
@0414:044415                          td dc_x_arg
@0415:100000                dc_x_arg: ca 0                     ; @@WrittenBy a0414
@0416:115140                          su const_8               ; shift from 0-15 axis to -8 to +7
@0417:154014                          slr 12                   ; gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0

@0420:025153                          rc diag_up_right_seg     ; Draw a segment with x=ACC
@0421:025154                          rc diag_dn_left_seg      ; Draw a segment with x=ACC
@0422:025156                          rc diag_up_left_seg      ; Draw a segment with x=ACC
@0423:025155                          rc diag_dn_right_seg     ; Draw a segment with x=ACC
                      draw_cross_ret:
@0424:074000                          sp 0                     ; @@WrittenBy a0404

                                      ; draw an "naught" (i.e. a diamond) centered on the screen at the position of the x and y args
                                      ; args are passed as addresses
                         draw_naught:
@0425:050446                          ta draw_naught_ret

@0426:100206                          ca y_addr_arg
@0427:044430                          td dn_y_arg
@0430:100000                dn_y_arg: ca 0                     ; @@WrittenBy a0427
@0431:115140                          su const_8               ; shift from 0-15 axis to -8 to +7
@0432:154014                          slr 12                   ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@0433:001677                          si scope_vector          ; initialize vector gen with the y-coord in ACC ; Auto-Annotate I/O: Display Vectors
@0434:100205                          ca x_addr_arg
@0435:044436                          td dn_x1_arg
@0436:100000               dn_x1_arg: ca 0                     ; @@WrittenBy a0435
@0437:115141                          su const_9               ; shift from 0-15 axis to -8 to +7; plus an offset
@0440:154014                          slr 12                   ; gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0

@0441:025153                          rc diag_up_right_seg     ; Draw a segment with x=ACC
@0442:025155                          rc diag_dn_right_seg     ; Draw a segment with x=ACC

@0443:111145                          ad const_2_cell          ; shift the x-pos two cells right
@0444:025156                          rc diag_up_left_seg      ; Draw a segment with x=ACC
@0445:025154                          rc diag_dn_left_seg      ; Draw a segment with x=ACC

                     draw_naught_ret:
@0446:074000                          sp 0                     ; @@WrittenBy a0425

                                      ; placeholder to draw a Win symbol centered on the screen at the position of the x and y args
                                      ; args are passed as addresses
                            draw_win:
@0447:050465                          ta draw_win_ret

@0450:100206                          ca y_addr_arg
@0451:044452                          td dw_y_arg
@0452:100000                dw_y_arg: ca 0                     ; @@WrittenBy a0451
@0453:115140                          su const_8               ; shift from 0-15 axis to -8 to +7
@0454:154014                          slr 12                   ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@0455:001677                          si scope_vector          ; initialize vector gen with the y-coord in ACC ; Auto-Annotate I/O: Display Vectors
@0456:100205                          ca x_addr_arg
@0457:044460                          td dw_x_arg
@0460:100000                dw_x_arg: ca 0                     ; @@WrittenBy a0457
@0461:115140                          su const_8               ; shift from 0-15 axis to -8 to +7
@0462:154014                          slr 12                   ; gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0

@0463:025153                          rc diag_up_right_seg     ; Draw a segment with x=ACC
                                      ;          rc diag_dn_left_seg   ; Draw a segment with x=ACC
@0464:025156                          rc diag_up_left_seg      ; Draw a segment with x=ACC
                                      ;          rc diag_dn_right_seg  ; Draw a segment with x=ACC
                        draw_win_ret:
@0465:074000                          sp 0                     ; @@WrittenBy a0447

                                      ; placeholder to draw a Tie symbol centered on the screen at the position of the x and y args
                                      ; args are passed as addresses
                            draw_tie:
@0466:050504                          ta draw_tie_ret

@0467:100206                          ca y_addr_arg
@0470:044471                          td dt_y_arg
@0471:100000                dt_y_arg: ca 0                     ; @@WrittenBy a0470
@0472:115140                          su const_8               ; shift from 0-15 axis to -8 to +7
@0473:154014                          slr 12                   ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@0474:001677                          si scope_vector          ; initialize vector gen with the y-coord in ACC ; Auto-Annotate I/O: Display Vectors
@0475:100205                          ca x_addr_arg
@0476:044477                          td dt_x_arg
@0477:100000                dt_x_arg: ca 0                     ; @@WrittenBy a0476
@0500:115140                          su const_8               ; shift from 0-15 axis to -8 to +7
@0501:154014                          slr 12                   ; gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0

                                      ;          rc diag_up_right_seg  ; Draw a segment with x=ACC
@0502:025154                          rc diag_dn_left_seg      ; Draw a segment with x=ACC
                                      ;          rc diag_up_left_seg   ; Draw a segment with x=ACC
@0503:025155                          rc diag_dn_right_seg     ; Draw a segment with x=ACC
                        draw_tie_ret:
@0504:074000                          sp 0                     ; @@WrittenBy a0466


                   draw_reset_symbol:
@0505:050514                          ta draw_reset_symbol_ret ; @@JumpedToBy a0173
@0506:105137                          cs const_7               ; put the point at game-board coord (1, 1)
@0507:154014                          slr 12
                                      ; ACC contains the coord; use the same number for x and y
@0510:000677                          si scope_point           ; initialize point gen with the y-coord in ACC ; Auto-Annotate I/O: Display Points
@0511:024000                          rc 0                     ; Draw a pont with x=ACC
@0512:014000                          rd 0                     ; read the light gun
@0513:071105                          cp init_game_board       ; call a subroutine to handle the light gun.

               draw_reset_symbol_ret:
@0514:074000                          sp 0                     ; @@WrittenBy a0505



                                      ; ***************************  User Interaction ***********************

                                      ; Handle a user light_gun hit on one of the game cells
                                      ; Remember that this is called only from the routine that draws a
                                      ; dot in the middle of a cell on the game grid.
                                      ; This routine converts the y_address from screen polarity (more positive is up)
                                      ; to Game Board polarity (numbered from top=0 to bottom=2) by subtracting the
                                      ; light gun coord from three.
                                      ; The light gun number is passed to this routine in ACC
                  light_gun_cell_hit:
@0515:050541                          ta light_gun_cell_hit_ret; @@JumpedToBy a0402

@0516:040544                          ts lcl_gun_num
@0517:100205                          ca x_addr_arg
@0520:044521                          td lgh_x1_arg
@0521:100000              lgh_x1_arg: ca 0                     ; load the x value of the cell's address in the grid @@WrittenBy a0520
@0522:160002                          srr 2                    ; divide the cell x address by four to get 1, 2, or 3
@0523:114001                          su const_1               ; change from one-base to zero-base
@0524:040542                          ts lcl_cell_x

@0525:100206                          ca y_addr_arg            ; repeat the process for the y coordinate
@0526:044527                          td lgh_y1_arg
@0527:100000              lgh_y1_arg: ca 0                     ; load the y value of the cell's address in the grid @@WrittenBy a0526
@0530:160002                          srr 2                    ; divide the cell y address by four to get 1, 2, or 3
@0531:031132                          sd const_0n              ; invert to get negative number
@0532:111134                          ad const_3               ; change from one-base to zero-base and invert order
@0533:040543                          ts lcl_cell_y
@0534:155001                          slh 1                    ; multiply y by three, i.e., double then add address
@0535:110543                          ad lcl_cell_y
@0536:110542                          ad lcl_cell_x            ; add x to get the cell number in the range 0-8

                                      .print "light gun %o hit x=%o, y=%o, cell=%ao", lcl_gun_num, lcl_cell_x, lcl_cell_y

                                      ; the cell number of the hit is passed below in ACC
                                      ; sp alternate_play_cell   ; do something with the light gun hit!; this call is for two-person play
@0537:040201                          ts light_gun_mailbox

@0540:074727                          sp is_there_winner       ; test to see if it's Game Over

@0541:074000  light_gun_cell_hit_ret: sp 0                     ; @@WrittenBy a0515

                                      ; temp vars for figuring the cell number in light_gun_cell_hit
@0542:000000              lcl_cell_x: .word 0                  ; @@WrittenBy a0524 ReadBy a0536
@0543:000000              lcl_cell_y: .word 0                  ; @@WrittenBy a0533 ReadBy a0535
@0544:000000             lcl_gun_num: .word 0                  ; @@WrittenBy a0516


                                      ; "Play" a cell
                                      ; This routine does a simple two-person-style play; each light gun hit simply alternates
                                      ; between X and O
                                      ; The Cell Number to play is passed in the ACC
                                      ; Note that this routine can only be called on a previously-unplayed cell, 'cause those
                                      ; are the only ones with dots in them, and that's all the light gun can see
                 alternate_play_cell:
@0545:050564                          ta alternate_play_cell_ret

@0546:040565                          ts lcl_aplay_cell_num    ; figure the pointer to the first cell draw function in game table
@0547:155001                          slh 1                    ;  thats table_start + 3*cwll_num + 2
@0550:110565                          ad lcl_aplay_cell_num    ; multiply cell number by three for a table offset
@0551:110272                          ad gb_table_start
@0552:111133                          ad const_2
@0553:044560                          td apc_table_ts

@0554:100216                          ca player_icon_table     ; figure out what the new cell should be
@0555:110211                          ad which_player
@0556:044557                          td apc_ca0
@0557:100000                 apc_ca0: ca 0                     ; ACC should now contain the address of the X or O display routine @@WrittenBy a0556
@0560:040000            apc_table_ts: ts 0                     ; store the display routine to the game state table @@WrittenBy a0553

                                      ; now switch to the other player for the next move
@0561:100211                          ca which_player
@0562:030001                          sd const_1               ; xor a 1 into the LSB; i.e. 0->1 or 1->0
@0563:040211                          ts which_player

             alternate_play_cell_ret:
@0564:074000                          sp 0                     ; @@WrittenBy a0545
@0565:000000      lcl_aplay_cell_num: .word 0                  ; @@WrittenBy a0546 ReadBy a0550



                                      ; This routine plays person against computer; each light gun hit plays an Cross,
                                      ; then the machine plays Naught
                                      ; Note that this routine can only be called on a previously-unplayed cell, 'cause those
                                      ; are the only ones with dots in them, and that's all the light gun can see.
                                      ; The number of the cell being played (was) in ACC
                                      ; Modified Aug 2, 2025 to pick up the cell number of the last light gun hit directly
                                      ; from the mailbox
                      user_play_cell:
@0566:050615                          ta user_play_cell_ret    ; @@JumpedToBy a0061

@0567:100201                          ca light_gun_mailbox     ; fetch the cell number
@0570:040616                          ts lcl_uplay_cell_num    ; figure the pointer to the first cell draw function in game table
@0571:155001                          slh 1                    ;  thats table_start + 3*cell_num + 2
@0572:110616                          ad lcl_uplay_cell_num    ; multiply cell number by three for a table offset
@0573:110272                          ad gb_table_start
@0574:111133                          ad const_2
@0575:044602                          td upc_table_ts

@0576:100216                          ca player_icon_table     ; figure out what the new cell should be
@0577:110211                          ad which_player
@0600:044601                          td upc_ca0
@0601:100000                 upc_ca0: ca 0                     ; ACC should now contain the address of the X or O display routine @@WrittenBy a0600
@0602:040000            upc_table_ts: ts 0                     ; store the display routine to the game state table @@WrittenBy a0575

@0603:074727                          sp is_there_winner       ; check to see if this user move ended the game
@0604:070614                          cp upc_cleanup           ; negative means no more moves

                                      ; now switch to the other player for the next move
                                      ; table_play_move is used to optimize the first move by a simple table lookup
                                      ; auto_play_move calls minimax to figure the best move, then makes the move
                                      ; by updating the icon on the game board.
@0605:100175                          ca move_number
@0606:134000                          dm 0                     ; test if this is Move Zero, i.e., the first user move
@0607:070612                          cp upc_move_zero         ; branch for first move, fall through for subsequent moves

@0610:074637                          sp auto_play_move
@0611:074614                          sp upc_cleanup

                       upc_move_zero:
@0612:100616                          ca lcl_uplay_cell_num    ; @@JumpedToBy a0607
@0613:074617                          sp table_play_move

                         upc_cleanup:
@0614:130175                          ao move_number           ; @@JumpedToBy a0604 a0611
                  user_play_cell_ret:
@0615:074000                          sp 0                     ; @@WrittenBy a0566
@0616:000000      lcl_uplay_cell_num: .word 0                  ; @@WrittenBy a0570 ReadBy a0572 a0612


                                      ; The first move is optimized to avoid MinMax. by using a Table lookup
                                      ; AC contains the cell number of the first human move
                     table_play_move:
@0617:050634                          ta table_play_move_ret   ; @@JumpedToBy a0613
@0620:040635                          ts lcl_tpm_user_move     ; stash the arg

@0621:101073                          ca first_move_table_start
@0622:110635                          ad lcl_tpm_user_move
@0623:044624                          td tpm_fetch_move_table
                tpm_fetch_move_table:
@0624:100000                          ca 0                     ; fetch the offset of the computer move that will be used to respond @@WrittenBy a0623
@0625:040636                          ts lcl_tpm_table_move
@0626:110272                          ad gb_table_start
@0627:111161                          ad c_2
@0630:044632                          td tpm_store_move
@0631:100220                          ca dct1                  ; this is wired to have the machine move Naught
                      tpm_store_move:
@0632:040000                          ts 0                     ; update the game state table @@WrittenBy a0630
                                      .print "User move to cell %d; Table-driven move to cell offset %d / 3, ts 0o%o 0o%ao", lcl_tpm_user_move, lcl_tpm_table_move, tpm_store_move
@0633:030000                          sd zero                  ; no-op for Print

                 table_play_move_ret:
@0634:074000                          sp 0                     ; @@WrittenBy a0617

                   lcl_tpm_user_move:
@0635:000000                          .word 0                  ; @@WrittenBy a0620 ReadBy a0622
                  lcl_tpm_table_move:
@0636:000000                          .word 0                  ; @@WrittenBy a0625



                                      ; set up to call findBestMove
                      auto_play_move:
@0637:050722                          ta apm_ret               ; @@JumpedToBy a0610
@0640:100272                          ca gb_table_start
@0641:111133                          ad const_2               ; the game piece is offset three from the table start
@0642:044647                          td apm_copy_src
@0643:101265                          ca boardp
@0644:044675                          td apm_copy_dst
@0645:105140                          cs const_8
@0646:040724                          ts lcl_apm_copy_count

@0647:100000            apm_copy_src: ca 0                     ; @@WrittenBy a0642 a0677 a0700 a0701 ReadBy a0677 a0700 a0701 JumpedToBy a0703
@0650:040725                          ts lcl_apm_cell_state

@0651:135047            apm_test_dot: dm dot_fn_addr           ; test if it's a Dot
@0652:134000                          dm 0
@0653:070655                          cp apm_its_a_dot
@0654:074660                          sp apm_test_naught
@0655:131043           apm_its_a_dot: ao lcl_dot_count         ; @@JumpedToBy a0653
@0656:104001                          cs one                   ; store -1 for "unplayed"
@0657:074675                          sp apm_copy_dst

@0660:100725         apm_test_naught: ca lcl_apm_cell_state    ; retrieve the cell state @@JumpedToBy a0654
@0661:135051                          dm naught_fn_addr        ; test if it's an X
@0662:134000                          dm 0
@0663:070665                          cp apm_its_a_naught
@0664:074667                          sp apm_test_cross
@0665:101171        apm_its_a_naught: ca c_oh                  ; load the value for a Naught @@JumpedToBy a0663
@0666:074675                          sp apm_copy_dst

@0667:100725          apm_test_cross: ca lcl_apm_cell_state    ; @@JumpedToBy a0664
@0670:135050                          dm cross_fn_addr         ; test if it's an X
@0671:134000                          dm 0
@0672:070674                          cp apm_its_a_cross
@0673:074723                          sp apm_panic             ; huh, it's not a dot, cross or naught
@0674:101170         apm_its_a_cross: ca c_XX                  ; load value for a cross @@JumpedToBy a0672
                                      ; fall through to finish the copy step

@0675:040000            apm_copy_dst: ts 0                     ; @@WrittenBy a0644 a0676 ReadBy a0676 JumpedToBy a0657 a0666
@0676:130675                          ao apm_copy_dst          ; step the destination once
@0677:130647                          ao apm_copy_src          ; step the source three times
@0700:130647                          ao apm_copy_src
@0701:130647                          ao apm_copy_src
@0702:130724                          ao lcl_apm_copy_count
@0703:070647                          cp apm_copy_src          ; around the loop again
                                      ; finished copying

                                      ; this ought to test who's playing whom, but the code below has the
                                      ; human player wired as Cross, the computer plays Nought
@0704:101171                          ca c_oh
@0705:041172                          ts player
@0706:101170                          ca c_XX
@0707:041173                          ts opponent
                                      ; .exec print_board(cm, rl("boardp"), rl("push_lcl_depth"), rl("player"), "calling findBestMove")
@0710:076007                          sp findBestMove          ; return the cell number for the Best Move in ACC
@0711:040726                          ts lcl_cell_for_move

                                      ; prepare to make the suggested move permanent in the game board
@0712:154001                          slr 1                    ; multiply cell number by three
@0713:110726                          ad lcl_cell_for_move
@0714:111161                          ad c_2                   ; point to cell state in game board table
@0715:110272                          ad gb_table_start
@0716:044720                          td apm_store_move

                                      ; ca player           ;  "player" is (1, 2) for (X, O); offset for player_tab (0, 1) for (X, O)
                                      ; su one
                                      ; ad player_icon_table  ; form a pointer to the icon table
                                      ; td apm_fetch_icon_fn
                                      ; ca dct1                 ; the code above should be "put back" to compute the right icon
                                      ; td apm_fetch_icon_fn

                                      .exec print_experiment(cm, cb, "move game board player %d to cell %d, function 0o%o to gb offset 0o%o", ("player", "lcl_cell_for_move", "apm_fetch_icon_fn", "apm_store_move"), 0)

                   apm_fetch_icon_fn:
@0717:100220                          ca dct1                  ; this address should be dynamically set, not fixed to "naught"
                      apm_store_move:
@0720:040000                          ts 0                     ; @@WrittenBy a0716
@0721:030000                          sd zero                  ; for debug

                             apm_ret:
@0722:074000                          sp 0                     ; @@WrittenBy a0637

                           apm_panic:
                                      .print "APM_Panic Halt: not dot, cross or naught in auto_play_move: lcl_apm_cell_state=0o%o", lcl_apm_cell_state
@0723:074000                          sp 0                     ; @@JumpedToBy a0673

                  lcl_apm_copy_count:
@0724:000000                          .word 0                  ; @@WrittenBy a0646 a0702 ReadBy a0702
                  lcl_apm_cell_state:
@0725:000000                          .word 0                  ; @@WrittenBy a0650 ReadBy apm_test_naught apm_test_cross
                   lcl_cell_for_move:
@0726:000000                          .word 0                  ; @@WrittenBy a0711 ReadBy a0713

                                      ;;;;;;;;;;;;;;;;;

                                      ; Analyze game for a winner
                                      ; This is done by counting X and O in each horiz & vert row, plus the two diagonals.
                                      ; The routine is controlled by a table giving the start cell and increment.  For each
                                      ; table entry, we count three cells in the game_board state array
                                      ; This routing contains two nested loops, the outer one that walks the analysis table,
                                      ; and the inner one that counts three cells
                                      ; This long subroutine goes in two parts
                                      ;   a) count what's in each cell on each row, column and diagonal (eight in all)
                                      ;   b) then see if anyone won
                                      ;   [future part c might determine if anyone could win on the next round]
                                      ; The second part also can determine if the game is tied, i.e., no open cells left to play
                                      ;   [Use of this routine would be cleaner if it returned with +0 if there are more moves,
                                      ;     or -0 if it's 'game over']
                     is_there_winner:
@0727:051036                          ta is_there_winner_ret   ; @@JumpedToBy a0051 a0540 a0603
                                      ; set up the outer loop
@0730:105137                          cs const_7
@0731:041037                          ts lcl_tb_loop_count
@0732:101052                          ca analysis_table_start  ; prepare pointers into the analysis table
@0733:044742                          td itw_st_ca
@0734:110001                          ad const_1
@0735:045002                          td itw_inc_gb
@0736:104000                          cs const_0               ; initialize with negative zero to simplify zero-detect later
@0737:041044                          ts lcl_total_dots        ; count all the unplayed cells

                                      ; set up the inner loop
@0740:105133          itw_outer_loop: cs const_2               ; @@JumpedToBy a1030
@0741:041040                          ts lcl_cell_loop_count
@0742:100000               itw_st_ca: ca 0                     ; load the starting cell number from the table @@WrittenBy a0733 a1023 a1024 ReadBy a1023 a1024
@0743:041045                          ts lcl_cell_number
@0744:155001                          slh 1
@0745:111045                          ad lcl_cell_number
@0746:110272                          ad gb_table_start
@0747:111133                          ad const_2               ; move to the gb_state val in gb table
@0750:044755                          td itw_cell_ts           ; pointer to first entry for this try in the gb table

@0751:100000                          ca const_0
@0752:041041                          ts lcl_naught_count
@0753:041042                          ts lcl_cross_count
@0754:041043                          ts lcl_dot_count

                      itw_inner_loop:
@0755:100000             itw_cell_ts: ca 0                     ; fetch whatever is in this cell @@WrittenBy a0750 a1003 ReadBy a1001 JumpedToBy a1005
@0756:041046                          ts lcl_cell_state
@0757:135047                test_dot: dm dot_fn_addr           ; test if it's a Dot
@0760:134000                          dm 0
@0761:070763                          cp its_a_dot
@0762:074765                          sp test_naught
@0763:131043               its_a_dot: ao lcl_dot_count         ; @@JumpedToBy a0761
@0764:131044                          ao lcl_total_dots

@0765:101046             test_naught: ca lcl_cell_state        ; retrieve the cell state @@JumpedToBy a0762
@0766:135051                          dm naught_fn_addr        ; test if it's an X
@0767:134000                          dm 0
@0770:070772                          cp its_a_naught
@0771:074773                          sp test_cross
@0772:131041            its_a_naught: ao lcl_naught_count      ; @@JumpedToBy a0770

@0773:101046              test_cross: ca lcl_cell_state        ; @@JumpedToBy a0771
@0774:135050                          dm cross_fn_addr         ; test if it's an X
@0775:134000                          dm 0
@0776:071000                          cp its_a_cross
@0777:075001                          sp itw_inner_loop_test_end
@1000:131042             its_a_cross: ao lcl_cross_count       ; @@JumpedToBy a0776

             itw_inner_loop_test_end:
                                      ; move to next cell in the inner loop
@1001:100755                          ca itw_cell_ts           ; @@JumpedToBy a0777
@1002:110000              itw_inc_gb: ad 0                     ; add whatever the analysis table says is the increment @@WrittenBy a0735 a1025 a1026 ReadBy a1025 a1026
@1003:040755                          ts itw_cell_ts
@1004:131040                          ao lcl_cell_loop_count
@1005:070755                          cp itw_inner_loop        ; end of inner loop

                                      ; .print "analysis loop %o, dots=%o, crosses=%o, naughts=%o", lcl_tb_loop_count, lcl_dot_count, lcl_cross_count, lcl_naught_count
                                      ; test to see if there's a winner
@1006:101134                          ca const_3
@1007:135041                          dm lcl_naught_count
@1010:071015                          cp naught_win
@1011:101134                          ca const_3
@1012:135042                          dm lcl_cross_count
@1013:071020                          cp cross_win
@1014:075023                          sp itw_next_outer_loop

@1015:101147              naught_win: ca const_o_win           ; 02 with the sign bit @@JumpedToBy a1010
@1016:040211                          ts which_player          ; mark the game as "over" and a Win
                                      .print "naught win"
@1017:075023                          sp itw_next_outer_loop

@1020:101146               cross_win: ca const_x_win           ; @@JumpedToBy a1013
@1021:040211                          ts which_player          ; mark the game as "over" and a Win
                                      .print "cross win"
@1022:075023                          sp itw_next_outer_loop

                                      ; now move to next entry in outer loop
                 itw_next_outer_loop:
@1023:130742                          ao itw_st_ca             ; @@JumpedToBy a1014 a1017 a1022
@1024:130742                          ao itw_st_ca
@1025:131002                          ao itw_inc_gb
@1026:131002                          ao itw_inc_gb
@1027:131037                          ao lcl_tb_loop_count
@1030:070740                          cp itw_outer_loop

                                      ; .print "unplayed cells=0d%d", lcl_total_dots
@1031:101044                          ca lcl_total_dots
@1032:071034                          cp its_a_tie             ; negative zero means its a tie (i.e., zero dots found)
@1033:075036                          sp is_there_winner_ret   ; so if it's not negative, we're done

@1034:101150               its_a_tie: ca const_draw            ; table offset 04 with the sign bit @@JumpedToBy a1032
                                      .print "game tie"
@1035:040211                          ts which_player          ; mark the game as "over" and a Draw

                 is_there_winner_ret:
@1036:074000                          sp 0                     ; @@WrittenBy a0727 JumpedToBy a1033


                                      ; local variables
@1037:000000       lcl_tb_loop_count: .word 0                  ; @@WrittenBy a0731 a1027 ReadBy a1027
@1040:000000     lcl_cell_loop_count: .word 0                  ; @@WrittenBy a0741 a1004 ReadBy a1004
@1041:000000        lcl_naught_count: .word 0                  ; @@WrittenBy a0752 its_a_naught ReadBy its_a_naught a1007
@1042:000000         lcl_cross_count: .word 0                  ; @@WrittenBy a0753 its_a_cross ReadBy its_a_cross a1012
@1043:000000           lcl_dot_count: .word 0                  ; @@WrittenBy apm_its_a_dot a0754 its_a_dot ReadBy apm_its_a_dot its_a_dot
@1044:000000          lcl_total_dots: .word 0                  ; @@WrittenBy a0737 a0764 ReadBy a0764 a1031
@1045:000000         lcl_cell_number: .word 0                  ; @@WrittenBy a0743 ReadBy a0745
@1046:000000          lcl_cell_state: .word 0                  ; @@WrittenBy a0756 ReadBy test_naught test_cross

                                      ; static addresses
@1047:000362             dot_fn_addr: .word draw_dot           ; @@ReadBy apm_test_dot test_dot
@1050:000404           cross_fn_addr: .word draw_cross         ; @@ReadBy a0670 a0774
@1051:000425          naught_fn_addr: .word draw_naught        ; @@ReadBy a0661 a0766


                                      ; This table gives the instructions for analyzing each horizontal, vertical
                                      ; or diagonal possible win combinations.
                analysis_table_start:
@1052:001053                          .word analysis_table     ; @@ReadBy a0732
                      analysis_table:
@1053:000000                     at0: .word 0                  ; start cell  ; horizontal cells
@1054:000003                          .word 1 * 3              ; increment
@1055:000003                     at1: .word 3                  ; start cell
@1056:000003                          .word 1 * 3              ; increment
@1057:000006                     at2: .word 6                  ; start cell
@1060:000003                          .word 1 * 3              ; increment
@1061:000000                     at3: .word 0                  ; start cell  ; vertical cells
@1062:000011                          .word 3 * 3              ; increment
@1063:000001                     at4: .word 1                  ; start cell
@1064:000011                          .word 3 * 3              ; increment
@1065:000002                     at5: .word 2                  ; start cell
@1066:000011                          .word 3 * 3              ; increment
@1067:000000                     at6: .word 0                  ; start cell  ; up-right diagonal
@1070:000014                          .word 4 * 3              ; increment
@1071:000002                     at7: .word 2                  ; start cell  ; up-left diagonal
@1072:000006                          .word 2 * 3              ; increment


                                      ; This table identifies a pre-computed machine response
                                      ; to each of the possible first player moves
                                      ; i.e., if the player puts a cross in cell zero, respond
                                      ; with a naught in cell 4.
                                      ; Cell numbers are multiplied by three so they can be used to
                                      ; directly index the game state table.
              first_move_table_start:
@1073:001074                          .word first_move_table   ; @@ReadBy a0621
                    first_move_table:
@1074:000014                          .word 4 * 3              ;  0
@1075:000000                          .word 0 * 3              ;  1
@1076:000014                          .word 4 * 3              ;  2
@1077:000000                          .word 0 * 3              ;  3
@1100:000000                          .word 0 * 3              ;  4
@1101:000006                          .word 2 * 3              ;  5
@1102:000014                          .word 4 * 3              ;  6
@1103:000003                          .word 1 * 3              ;  7
@1104:000014                          .word 4 * 3              ;  8


                                      ;;;;;;;;;;;;;;;;
                                      ; Set all the game board cells to "unplayed"
                                      ; Initialize the game state
                     init_game_board:
@1105:051127                          ta init_game_board_ret   ; @@JumpedToBy main a0513

@1106:100000                          ca zero                  ; Reset the Move Counter to Zero
@1107:040175                          ts move_number

@1110:100272                          ca gb_table_start        ; calculate the offset into the game state table for this cell
@1111:111133                          ad const_2               ; offset to third table entry
@1112:045116                          td igb_table_ts          ; store the pointer to the first entry

@1113:105140                          cs const_8               ; nine passes; var should be 8; loop count is negative
@1114:040202                          ts loop_count
@1115:101130                igb_loop: ca lcl_init_val          ; fetch the address to use for the initial function pointer for each cell @@JumpedToBy a1123
@1116:040000            igb_table_ts: ts 0                     ; set a table entry to the default pointer @@WrittenBy a1112 a1121 ReadBy a1117
@1117:101116                          ca igb_table_ts          ; advance the pointer to the next entry
@1120:111134                          ad const_3
@1121:041116                          ts igb_table_ts
@1122:130202                          ao loop_count
@1123:071115                          cp igb_loop              ; around the loop until we've hit all nine entries

@1124:100000                          ca const_0
@1125:040211                          ts which_player
@1126:041131                          ts g_game_over           ; clear the "game over" flag

                                      ;;;;;
                                      ; debug - pre-populate two moves
                                      ;            ca dct0  ; X icon
                                      ;            ts gb0_state
                                      ;            ca dct1  ; O icon
                                      ;            ts gb1_state
                                      ;            ca dct1  ; O icon
                                      ;            ts gb2_state
                                      ;            ca dct0  ; X icon
                                      ;            ts gb3_state
                                      ;            ca dct1  ; O icon
                                      ;            ts gb4_state
                                      ;            ca dct0  ; X icon
                                      ;            ts gb7_state

                                      ;;;;;;
                 init_game_board_ret:
@1127:074000                          sp 0                     ; @@WrittenBy a1105
@1130:000362            lcl_init_val: .word draw_dot           ; @@ReadBy igb_loop
@1131:000000             g_game_over: .word 0                  ; @@WrittenBy a0066 a1126 ReadBy a0047

                                      ; ****************************************


                                      ; Constants
@1132:177777                const_0n: .word 0o177777           ; @@ReadBy a0531
@1133:000002                 const_2: .word 2                  ; @@ReadBy a0071 a0075 a0106 a0112 a0552 a0574 a0641 itw_outer_loop a0747 a1111
@1134:000003                 const_3: .word 3                  ; @@ReadBy a0147 a0152 a0155 a0532 a1006 a1011 a1120
@1135:000004                 const_4: .word 4
@1136:000006                 const_6: .word 6                  ; @@ReadBy a0073 a0110
@1137:000007                 const_7: .word 7                  ; @@ReadBy a0162 a0506 a0730
@1140:000010                 const_8: .word 8                  ; @@ReadBy a0123 a0330 a0334 a0347 a0353 a0370 a0376 a0410 a0416 a0431 a0453 a0461 a0472 a0500 a0645 a1113
@1141:000011                 const_9: .word 9                  ; @@ReadBy a0437
@1142:000012                const_10: .word 10                 ; @@ReadBy a0102 a0117
@1143:000013                const_11: .word 11                 ; loop counter for 12 iterations @@ReadBy a0077 a0114
@1144:000014                const_12: .word 12
@1145:020000            const_2_cell: .word 8192               ; decimal value of screen coord corresponding to two cells in width @@ReadBy a0443

@1146:100002             const_x_win: .word 0o100002           ; two plus sign bit @@ReadBy cross_win
@1147:100003             const_o_win: .word 0o100003           ; two plus sign bit @@ReadBy naught_win
@1150:100004              const_draw: .word 0o100004           ; three plus sign bit @@ReadBy its_a_tie


                                      ; these two constants give the delta values to draw a "maximum short vector"
@1151:076000          horiz_line_seg: .word 0o174 * 0o400      ; +32 in the top half of the word
@1152:000174           vert_line_seg: .word 0o174              ; +32 in the bottom half of the word
@1153:076174       diag_up_right_seg: .word 0o174 * 0o400 + 0o174
@1154:100200        diag_dn_left_seg: .word 0o200 * 0o400 + 0o200
@1155:076200       diag_dn_right_seg: .word 0o174 * 0o400 + 0o200
@1156:100174        diag_up_left_seg: .word 0o200 * 0o400 + 0o174


                                      ; ---------------------------------------

                          panic_stop:
@1157:100000                          ca 0                     ; @@JumpedToBy a1433
                                      .print "panic stop"
@1160:000000                          si 0                     ; ; Auto-Annotate I/O: unknown i/o device


                                      ; ;these are the values to be placed in a cell on the board to show
                                      ; who's playing which position
                                      .pp XX, 1
                                      .pp Oh, 2
                                      .pp None, -1

                                      ; Constants
@1161:000002                     c_2: .word 2                  ; @@ReadBy a0627 a0714 a1406 a1410
@1162:177775                    c_2n: .word -2                 ; for a loop of three @@ReadBy a1351 a1367
@1163:000003                     c_3: .word 3                  ; @@ReadBy a1356 a1363 a2373 a2376 a2401
@1164:000004                     c_4: .word 4                  ; @@ReadBy a1401
@1165:177767                    c_8n: .word -8                 ; for a loop of nine passes @@ReadBy a1271 a1667 a1733 a2017
@1166:000012                    c_10: .word 10                 ; @@ReadBy a1420 a1422 a1634 a1644
@1167:001750                  c_1000: .word 1000               ; BigNum @@ReadBy a1663 a1727 a2013
@1170:000001                    c_XX: .word XX                 ; @@ReadBy apm_its_a_cross a0706
@1171:000002                    c_oh: .word Oh                 ; @@ReadBy apm_its_a_naught a0704

                                      ; Global Variables
                                      ;Default state to start the game: player = 'x', opponent = 'o';
@1172:000001                  player: .word XX                 ; @@WrittenBy a0705 ReadBy a1415 a1701 a2032
@1173:000002                opponent: .word Oh                 ; @@WrittenBy a0707 ReadBy a1745



                                      ;#define GAME1
                                      ;#ifdef GAME1
                                      ;    char board[3][3] =
                                      ;     {
                                      ;         { '_', 'o', 'x' },
                                      ;         { 'x', 'o', '_' },
                                      ;         { '_', '_', '_' }
                                      ;     };
                                      ; #endif
                                      ; #ifdef GAME2
                                      ;    // X should win this game in one move, but it will try every possible alternative before figuring it out
                                      ;    char board[3][3] =
                                      ;    {
                                      ;        { '_', 'o', 'x' },
                                      ;        { '_', 'o', 'x' },
                                      ;        { '_', '_', '_' }
                                      ;    };
                                      ; #endif


                                      ; pointers - yuck :-(  This cell points to the first of several board layouts
@1174:000011                BRD_SIZE: .word board3 - board2    ; nine words per each boar layouts
                                      ; BRDS_COUNT: .word -5    ; six test board layouts (so far!)
                                      ; BRDS_COUNT: .word (first_boardp - boardp) / (board3 - board2) + 1    ; six test board layouts (so far!)
@1175:000001              BRDS_COUNT: .word 1                  ; set the count to do just one board


                                      ; Board Layout
                                      ;   0  1  2
                                      ;   3  4  5
                                      ;   6  7  8

@1176:001177            first_boardp: .word board2

                                      ;        { 'x', 'o', 'o' },
                                      ;        { 'x', 'o', 'x' },
                                      ;        { '_', '_', '_' }
@1177:000001                  board2: .word XX                 ; 0
@1200:000002                          .word Oh
@1201:000002                          .word Oh
@1202:000001                          .word XX                 ; 3
@1203:000002                          .word Oh
@1204:000001                          .word XX
@1205:177776                          .word None               ; 6
@1206:177776                          .word None
@1207:177776                          .word None

                                      ; X plays next, but Oh wins in one move
                                      ;        { '_', 'o', 'o' },
                                      ;        { 'x', 'o', 'x' },
                                      ;        { '_', '_', '_' }
@1210:177776                  board3: .word None               ; 0
@1211:000002                          .word Oh
@1212:000002                          .word Oh
@1213:000001                          .word XX                 ; 3
@1214:000002                          .word Oh
@1215:000001                          .word XX
@1216:177776                          .word None               ; 6
@1217:177776                          .word None
@1220:177776                          .word None

                                      ; Test evaluate_board, Rows
                                      ; First row is Not a Win, second row should detect a win by X
                                      ;        { '_', 'o', 'o' },
                                      ;        { 'x', 'x', 'x' },
                                      ;        { 'o', '_', '_' }
                     board_row_x_win:
@1221:177776                          .word None               ; 0
@1222:000002                          .word Oh
@1223:000002                          .word Oh
@1224:000001                          .word XX                 ; 3
@1225:000001                          .word XX
@1226:000001                          .word XX
@1227:000002                          .word Oh                 ; 6
@1230:177776                          .word None
@1231:177776                          .word None

                                      ; Test evaluate_board, Cols
                                      ; First col is Not a Win, second col should detect a win by 0
                                      ;        { '_', 'o', 'x' },
                                      ;        { 'x', 'o', 'x' },
                                      ;        { 'o', 'o', '_' }
                     board_col_o_win:
@1232:177776                          .word None               ; 0
@1233:000002                          .word Oh
@1234:000001                          .word XX
@1235:000001                          .word XX                 ; 3
@1236:000002                          .word Oh
@1237:000001                          .word XX
@1240:000002                          .word Oh                 ; 6
@1241:000002                          .word Oh
@1242:177776                          .word None

                                      ; Test evaluate_board, 2-4-6 diagonal
                                      ;        { '_', 'o', 'x' },
                                      ;        { 'o', 'x', 'o' },
                                      ;        { 'x', 'o', '_' }
                board_2_4_6_diagonal:
@1243:177776                          .word None               ; 0
@1244:000002                          .word Oh
@1245:000001                          .word XX
@1246:000002                          .word Oh                 ; 3
@1247:000001                          .word XX
@1250:000002                          .word Oh
@1251:000001                          .word XX                 ; 6
@1252:000002                          .word Oh
@1253:177776                          .word None

                                      ; X plays next, and 'should' play cell 8
                                      ;        { 'o', 'x', '_' },
                                      ;        { '_', 'o', '_' },
                                      ;        { '_', '_', '_' }
@1254:000002                  board4: .word Oh                 ; 0
@1255:000001                          .word XX
@1256:177776                          .word None
@1257:177776                          .word None               ; 3
@1260:000002                          .word Oh
@1261:177776                          .word None
@1262:177776                          .word None               ; 6
@1263:177776                          .word None
@1264:177776                          .word None


@1265:001254                  boardp: .word board4             ; board2 to scan all the games @@ReadBy a0643 a1267 a1311 a1671 a1735 a2023

                                      ; // This function returns true if there are moves
                                      ; // remaining on the board. It returns false if
                                      ; // there are no moves left to play.
                                      ; bool isMovesLeft()
                                      ; {
                                      ;     for (int i = 0; i<3; i++)
                                      ;         for (int j = 0; j<3; j++)
                                      ;             if (board[i][j]=='_')
                                      ;                 return true;
                                      ;     //printf("IsMovesLeft --> false\n");
                                      ;     return false;
                                      ; }
                                      ; IsMovesLeft returns positive if there are more moves, negative if there
                                      ; are no empty cells
                         isMovesLeft:
@1266:051305                          ta isMovesLeftRet        ; @@JumpedToBy a1653
@1267:101265                          ca boardp
@1270:045273                          td iML_bptr              ; store a pointer to the start of the game board
@1271:101165                          ca c_8n
@1272:041306                          ts iML_cnt
@1273:100000                iML_bptr: ca 0                     ; read the cell under test; If the cell is empty, there are move moves, we can stop @@WrittenBy a1270 a1277 ReadBy a1277 JumpedToBy a1301
@1274:071304                          cp iML_empty             ; branch if the cell is empty, ie, neither X or O.

@1275:100001                          ca one                   ; non-empty cell; prepare to return positive
@1276:041307                          ts iML_ret
@1277:131273                          ao iML_bptr              ; update the pointer to the next cell
@1300:131306                  iML_lp: ao iML_cnt               ; increment the loop count
@1301:071273                          cp iML_bptr              ; branch if not done yet

@1302:104001                          cs one                   ; no empty cells; return -1
@1303:075305                          sp isMovesLeftRet

                           iML_empty:
@1304:100001                          ca one                   ; return One for more moves left @@JumpedToBy a1274

                      isMovesLeftRet:
@1305:074000                          sp 0                     ; @@WrittenBy a1266 JumpedToBy a1303

                                      ; local variables
@1306:000000                 iML_cnt: .word 0                  ; loop counter @@WrittenBy a1272 iML_lp ReadBy iML_lp
@1307:000000                 iML_ret: .word 0                  ; return code @@WrittenBy a1276


                                      ; Helper routine for Evaluate_Board
                                      ; Check three adjacent cells to determine if they have the same player identifier
                                      ; Return the negative of the value if it's the same, or +1 if different (or if all three are -1, unoccupied)
                                      ; The offset from the start of the table is in ACC, the stride is in the "local"
                                      ; variable equ3_arg_stride
                                      ; The return value in the AC is inverted to make the test one level up a step
                                      ; simpler...  -1 or -2 means the row contains all X's or O's, +1 means they're not all
                                      ; the same.  The caller can then branch on negative to determine if the search for
                                      ; a winner is complete.
                                equ3:
@1310:051341                          ta equ3_ret              ; @@JumpedToBy a1354 a1372 a1404 a1411
@1311:111265                          ad boardp                ; add base pointer to the board array to offset
@1312:045313                          td rd_brd1
@1313:100000                 rd_brd1: ca 0                     ; read the first element @@WrittenBy a1312 ReadBy a1316
@1314:071340                          cp equ3_ret_not_equal
@1315:041343                          ts equ3_lcl_first_read   ; remember what's in the first cell

@1316:101313                          ca rd_brd1               ; calculate address for second cell by adding stride
@1317:111342                          ad equ3_arg_stride
@1320:045321                          td rd_brd2
@1321:100000                 rd_brd2: ca 0                     ; read the second element @@WrittenBy a1320 ReadBy a1326
@1322:115343                          su equ3_lcl_first_read   ; compare it to the first element read
@1323:134000                          dm zero
@1324:071326                          cp equ3_brd3             ; negative zero means they're the same; so test the third cell
@1325:075340                          sp equ3_ret_not_equal    ; otherwise, bail out

                           equ3_brd3:
@1326:101321                          ca rd_brd2               ; @@JumpedToBy a1324
@1327:111342                          ad equ3_arg_stride
@1330:045331                          td rd_brd3
@1331:100000                 rd_brd3: ca 0                     ; @@WrittenBy a1330
@1332:115343                          su equ3_lcl_first_read
@1333:134000                          dm zero
@1334:071336                          cp equ3_ret_equal        ; negative zero means they're the same
@1335:075340                          sp equ3_ret_not_equal

                      equ3_ret_equal:
@1336:105343                          cs equ3_lcl_first_read   ; return negative one or two @@JumpedToBy a1334
@1337:075341                          sp equ3_ret

                  equ3_ret_not_equal:
@1340:100001                          ca one                   ; @@JumpedToBy a1314 a1325 a1335
                                      ; fall through to equ3_ret

                            equ3_ret:
@1341:074000                          sp 0                     ; @@WrittenBy a1310 JumpedToBy a1337
                                      ; local vars and arguments
                     equ3_arg_stride:
@1342:000000                          .word 0                  ; @@WrittenBy a1346 a1364 a1402 a1407 ReadBy a1317 a1327
                 equ3_lcl_first_read:
@1343:000000                          .word 0                  ; @@WrittenBy a1315 ReadBy a1322 a1332 a1336




                                      ; // This is the evaluation function as discussed
                                      ; // in the previous article ( http://goo.gl/sJgv68 )
                                      ; int evaluate() {

                                      ;     // Checking for Rows for X or O victory.
                                      ;     for (int row = 0; row<3; row++)
                                      ;     {
                                      ;         if (board[row][0]==board[row][1] &&   // stride = +1
                                      ;             board[row][1]==board[row][2])
                                      ;         {
                                      ;             if (board[row][0]==player)
                                      ;                 return +10;
                                      ;             else if (board[row][0]==opponent)
                                      ;                 return -10;
                                      ;         }
                                      ;     }

                                      ;     // Checking for Columns for X or O victory.
                                      ;     for (int col = 0; col<3; col++)
                                      ;     {
                                      ;         if (board[0][col]==board[1][col] &&  // stride = +3
                                      ;             board[1][col]==board[2][col])
                                      ;         {
                                      ;             if (board[0][col]==player)
                                      ;                 return +10;
                                      ;             else if (board[0][col]==opponent)
                                      ;                 return -10;
                                      ;         }
                                      ;     }

                                      ;     // Checking for Diagonals for X or O victory.
                                      ;     if (board[0][0]==board[1][1] && board[1][1]==board[2][2])  // stride = +4
                                      ;     {
                                      ;         if (board[0][0]==player)
                                      ;             return +10;
                                      ;         else if (board[0][0]==opponent)
                                      ;             return -10;
                                      ;     }

                                      ;     if (board[0][2]==board[1][1] && board[1][1]==board[2][0])   // stride = +2
                                      ;     {
                                      ;         if (board[0][2]==player)
                                      ;             return +10;
                                      ;         else if (board[0][2]==opponent)
                                      ;             return -10;
                                      ;     }

                                      ;     // Else if none of them have won then return 0
                                      ;     return 0;
                                      ; }

                                      ; Evaluate the current board for win, lose or incomplete
                                      ; If it's a Win for the Player, return +10; if it's a Lose for the Player, return -10
                                      ; If the game is undecided, return zero
                                      ; This routine takes no input arguments
                      evaluate_board:
@1344:051424                          ta eval_ret              ; @@JumpedToBy a1631
                        eval_chk_row:
                                      ; check rows for a win; stride of three, starting at zero
@1345:100001                          ca one
@1346:041342                          ts equ3_arg_stride       ; set the equ3 stride to one, i.e., three adjacent horizontal cells
@1347:100000                          ca zero                  ; set the equ3 starting cell to row zero
@1350:041425                          ts eval_lcl_nxt_cell
@1351:101162                          ca c_2n                  ; initialize loop counter; prepare to go around the loop three times
@1352:041426                          ts eval_lcl_loop_count
                       eval_row_loop:
@1353:101425                          ca eval_lcl_nxt_cell     ; place offset of first cell to check in AC @@JumpedToBy a1362
@1354:075310                          sp equ3                  ; check one row
@1355:071415                          cp eval_score_players    ; match -- figure out who won

                    eval_chk_nxt_row:
@1356:101163                          ca c_3                   ; next row is three cells forward
@1357:111425                          ad eval_lcl_nxt_cell     ; compute the first cell of the next row
@1360:041425                          ts eval_lcl_nxt_cell
@1361:131426                          ao eval_lcl_loop_count
@1362:071353                          cp eval_row_loop         ; branch if there's another row to check, fall through if we've checked three rows

                                      ; no one won on rows, so go on to check columns

                        eval_chk_col:
                                      ; check cols for a win; stride of three, starting at zero
@1363:101163                          ca c_3
@1364:041342                          ts equ3_arg_stride       ; set the equ3 stride to three, i.e., three adjacent vertical cells
@1365:100000                          ca zero                  ; set the equ3 starting cell to col zero
@1366:041425                          ts eval_lcl_nxt_cell
@1367:101162                          ca c_2n                  ; initialize loop counter; prepare to go around the loop three times
@1370:041426                          ts eval_lcl_loop_count
                       eval_col_loop:
@1371:101425                          ca eval_lcl_nxt_cell     ; place offset of first cell to check in AC @@JumpedToBy a1400
@1372:075310                          sp equ3                  ; check one row
@1373:071415                          cp eval_score_players    ; match -- figure out who won

                    eval_chk_nxt_col:
@1374:100001                          ca one                   ; next col is one cell forward
@1375:111425                          ad eval_lcl_nxt_cell     ; compute the first cell of the next row
@1376:041425                          ts eval_lcl_nxt_cell
@1377:131426                          ao eval_lcl_loop_count
@1400:071371                          cp eval_col_loop         ; branch if there's another row to check, fall through if we've checked three rows

                                      ; there are only two diagonals, no loops here; just test 0, 4, 8 then 2, 4, 6
                  eval_chk_diagonal0:
@1401:101164                          ca c_4
@1402:041342                          ts equ3_arg_stride       ; set the equ3 stride to four, i.e., 0, 4, 8 diagonal cells
@1403:100000                          ca zero                  ; set the equ3 starting cell to col zero
@1404:075310                          sp equ3                  ; check one row
@1405:071415                          cp eval_score_players    ; match -- figure out who won

                  eval_chk_diagonal1:
@1406:101161                          ca c_2
@1407:041342                          ts equ3_arg_stride       ; set the equ3 stride to two, i.e., 2, 4, 6 diagonal cells
@1410:101161                          ca c_2                   ; set the equ3 starting cell to cell 2
@1411:075310                          sp equ3                  ; check one row
@1412:071415                          cp eval_score_players    ; match -- figure out who won

                                      ; nobody won; return 0
@1413:100000                          ca zero
@1414:075424                          sp eval_ret

                                      ; somebody won; check if it's the Player or Opponent
                                      ; The winner cell is -1 or -2 in AC; convert that to a score (recall equ3 results are inverted)
                                      ; depending on whether who's Player and who's Opponent at the moment
                  eval_score_players:
@1415:111172                          ad player                ; test to see if the current Player is the one that was found to have three winning cells @@JumpedToBy a1355 a1373 a1405 a1412
@1416:134000                          dm zero
@1417:071422                          cp eval_player_win

                        eval_opp_win:
@1420:105166                          cs c_10                  ; score an opponent win as -10
@1421:075424                          sp eval_ret

                     eval_player_win:
@1422:101166                          ca c_10                  ; score a Player win as +10 @@JumpedToBy a1417
@1423:075424                          sp eval_ret

                            eval_ret:
                                      ; .print "  Evaluate_Score returns %ad"
@1424:074000                          sp 0                     ; @@WrittenBy a1344 JumpedToBy a1414 a1421 a1423
                   eval_lcl_nxt_cell:
@1425:000000                          .word 0                  ; @@WrittenBy a1350 a1360 a1366 a1376 ReadBy a1353 a1357 a1371 a1375
                 eval_lcl_loop_count:
@1426:000000                          .word 0                  ; @@WrittenBy a1352 a1361 a1370 a1377 ReadBy a1361 a1377


                                      ; ================  MINIMAX Section =====================

                                      ; Two helper functions to save state for recursive calls
                                      ; to "push" onto the stack, we copy all the local minimax variables to
                                      ; where ever the stack pointer is pointing, then increment the stack
                                      ; pointer by the size of the frame
                         push_minmax:
@1427:051456                          ta push_ret              ; @@JumpedToBy a1627
@1430:041507                          ts push_pop_lcl_acc_stash; stash the AC
@1431:101513                          ca stack_size
@1432:115506                          su push_lcl_depth        ; test to be sure we're not running over the allocated space
@1433:071157                          cp panic_stop            ; branch if overflow

@1434:105511                          cs frame_size
@1435:110001                          ad one
@1436:041510                          ts push_pop_word_count   ; initialize the loop counter
@1437:101512                          ca minimax_retp          ; fetch the "source pointer"
@1440:045443                          td push_src
@1441:101514                          ca stackp                ; fetch the "destination pointer"
@1442:045444                          td push_dst

                            push_src:                          ; copy loop
@1443:100000                          ca 0                     ; filled in above @@WrittenBy a1440 a1445 ReadBy a1445 JumpedToBy a1450
                            push_dst:
@1444:040000                          ts 0                     ; @@WrittenBy a1442 a1446 ReadBy a1446
@1445:131443                          ao push_src
@1446:131444                          ao push_dst
@1447:131510                          ao push_pop_word_count
@1450:071443                          cp push_src              ; around the loop until the entire stack frame is copied

@1451:101514                          ca stackp                ; update the stack pointer for next time
@1452:111511                          ad frame_size
@1453:045514                          td stackp
@1454:131506                          ao push_lcl_depth

@1455:101507                          ca push_pop_lcl_acc_stash; retrieve the AC
                            push_ret:
@1456:074000                          sp 0                     ; subroutine return @@WrittenBy a1427


                          pop_minmax:
@1457:051505                          ta pop_ret               ; @@JumpedToBy a1775
@1460:041507                          ts push_pop_lcl_acc_stash; stash the AC
@1461:101514                          ca stackp                ; back up the stack pointer
@1462:115511                          su frame_size
@1463:045514                          td stackp
@1464:101506                          ca push_lcl_depth
@1465:114001                          su one
@1466:041506                          ts push_lcl_depth

@1467:105511                          cs frame_size
@1470:110001                          ad one
@1471:041510                          ts push_pop_word_count   ; initialize the loop counter
@1472:101512                          ca minimax_retp          ; fetch the "destination pointer"
@1473:045477                          td pop_dst
@1474:101514                          ca stackp                ; fetch the "source pointer"
@1475:045476                          td pop_src

                             pop_src:                          ; copy loop
@1476:100000                          ca 0                     ; filled in above @@WrittenBy a1475 a1500 ReadBy a1500 JumpedToBy a1503
                             pop_dst:
@1477:040000                          ts 0                     ; @@WrittenBy a1473 a1501 ReadBy a1501
@1500:131476                          ao pop_src
@1501:131477                          ao pop_dst
@1502:131510                          ao push_pop_word_count
@1503:071476                          cp pop_src               ; around the loop until the entire stack frame is copied

@1504:101507                          ca push_pop_lcl_acc_stash; retrieve the AC
                             pop_ret:
@1505:074000                          sp 0                     ; @@WrittenBy a1457

                      push_lcl_depth:
@1506:000000                          .word 0                  ; @@WrittenBy a1454 a1466 ReadBy a1432 a1454 a1464
              push_pop_lcl_acc_stash:
@1507:000000                          .word 0                  ; @@WrittenBy a1430 a1460 ReadBy a1455 a1504
                 push_pop_word_count:                          ; this var is the copy-word counter for push and pop
@1510:000000                          .word 0                  ; @@WrittenBy a1436 a1447 a1471 a1502 ReadBy a1447 a1502

                                      ; calculate the size of a single push on the stack
@1511:000007              frame_size: .word minmax_lcl_data_end - minmax_ret; @@ReadBy a1434 a1452 a1462 a1467
                        minimax_retp:                          ; Here's the address of the minimax local data to be pushed onto stack
@1512:001776                          .word minmax_ret         ; @@ReadBy a1437 a1472
                          stack_size:
@1513:000012                          .word 10                 ; I've allocated ten frames below for use of the stack @@ReadBy a1431


@1514:001515                  stackp: .word stack0             ; @@WrittenBy a1453 a1463 ReadBy a1441 a1451 a1461 a1474
@1515:000000                  stack0: .word 0                  ; frame 0
@1516:000000                          .word 0
@1517:000000                          .word 0
@1520:000000                          .word 0
@1521:000000                          .word 0
@1522:000000                          .word 0
@1523:000000                          .word 0
@1524:000000                          .word 0                  ; frame 1
@1525:000000                          .word 0
@1526:000000                          .word 0
@1527:000000                          .word 0
@1530:000000                          .word 0
@1531:000000                          .word 0
@1532:000000                          .word 0
@1533:000000                          .word 0                  ; frame 2
@1534:000000                          .word 0
@1535:000000                          .word 0
@1536:000000                          .word 0
@1537:000000                          .word 0
@1540:000000                          .word 0
@1541:000000                          .word 0
@1542:000000                          .word 0                  ; frame 3
@1543:000000                          .word 0
@1544:000000                          .word 0
@1545:000000                          .word 0
@1546:000000                          .word 0
@1547:000000                          .word 0
@1550:000000                          .word 0
@1551:000000                          .word 0                  ; frame 4
@1552:000000                          .word 0
@1553:000000                          .word 0
@1554:000000                          .word 0
@1555:000000                          .word 0
@1556:000000                          .word 0
@1557:000000                          .word 0
@1560:000000                          .word 0                  ; frame 5
@1561:000000                          .word 0
@1562:000000                          .word 0
@1563:000000                          .word 0
@1564:000000                          .word 0
@1565:000000                          .word 0
@1566:000000                          .word 0
@1567:000000                          .word 0                  ; frame 6
@1570:000000                          .word 0
@1571:000000                          .word 0
@1572:000000                          .word 0
@1573:000000                          .word 0
@1574:000000                          .word 0
@1575:000000                          .word 0
@1576:000000                          .word 0                  ; frame 7
@1577:000000                          .word 0
@1600:000000                          .word 0
@1601:000000                          .word 0
@1602:000000                          .word 0
@1603:000000                          .word 0
@1604:000000                          .word 0
@1605:000000                          .word 0                  ; frame 8
@1606:000000                          .word 0
@1607:000000                          .word 0
@1610:000000                          .word 0
@1611:000000                          .word 0
@1612:000000                          .word 0
@1613:000000                          .word 0
@1614:000000                          .word 0                  ; frame 9
@1615:000000                          .word 0
@1616:000000                          .word 0
@1617:000000                          .word 0
@1620:000000                          .word 0
@1621:000000                          .word 0
@1622:000000                          .word 0
@1623:000000                     eos: .word 0                  ; end of stack
@1624:001623              stack_endp: .word eos




                                      ; // This is the minimax function. It considers all
                                      ; // the possible ways the game can go and returns
                                      ; // the value of the board
                                      ; int minimax(int depth, bool isMax)
                                      ; {
                                      ;     int score = evaluate(board);
                                      ;     int m;
                                      ;     int best;

                                      ;     ; printf("%sMinimax Start\n", indent[depth+1]);
                                      ;     // If Maximizer has won the game return his/her
                                      ;     // evaluated score
                                      ;     if (score == 10) {
                                      ;         return score;
                                      ;         ; printf("%sMaximizer wins\n", indent[depth+1]);
                                      ;     }

                                      ;     // If Minimizer has won the game return his/her
                                      ;     // evaluated score
                                      ;     if (score == -10) {
                                      ;         ; printf("%sMinimizer Wins\n", indent[depth+1]);
                                      ;         return score;
                                      ;     }

                                      ;     // If there are no more moves and no winner then
                                      ;     // it is a tie
                                      ;     if (isMovesLeft(board)==false) {
                                      ;         ; printf("%sMinimax: No More Moves\n", indent[depth+1] );
                                      ;         return 0;
                                      ;     }

                                      ;     // If this maximizer's move
                                      ;     if (isMax)
                                      ;     {
                                      ;         best = -1000;

                                      ;         // Traverse all cells
                                      ;         for (int i = 0; i<3; i++)
                                      ;         {
                                      ;             for (int j = 0; j<3; j++)
                                      ;            {
                                      ;                // Check if cell is empty
                                      ;                if (board[i][j]=='_')
                                      ;                {
                                      ;                    // Make the move
                                      ;                    board[i][j] = player;

                                      ;                    // Call minimax recursively and choose
                                      ;                    // the maximum value
                                      ;                    //best = max( best,
                                      ;                    //    minimax(board, depth+1, !isMax) );
                                      ;                    m = minimax(depth+1, !isMax);
                                      ;                    //added by guy:
                                      ;                    m -= depth;
                                      ;                    ; printf("%sminimax isMAX=%d returned score %d  ", indent[depth+1], isMax, m);
                                      ;                    if (m > best) {
                                      ;                        best = m;
                                      ;                        ; printf("%sBest Higher\n", indent[depth+1]);
                                      ;                    } else {
                                      ;                        ; printf("\n");
                                      ;                    }
                                      ;                    ; print_board(depth);

                                      ;                    // Undo the move
                                      ;                    board[i][j] = '_';
                                      ;                }
                                      ;            }
                                      ;         }
                                      ;         return best;
                                      ;     }

                                      ;     // If this minimizer's move
                                      ;     else
                                      ;     {
                                      ;         best = 1000;

                                      ;         // Traverse all cells
                                      ;         for (int i = 0; i<3; i++)
                                      ;         {
                                      ;             for (int j = 0; j<3; j++)
                                      ;             {
                                      ;                 // Check if cell is empty
                                      ;                 if (board[i][j]=='_')
                                      ;                 {
                                      ;                     // Make the move
                                      ;                     board[i][j] = opponent;

                                      ;                     // Call minimax recursively and choose
                                      ;                     // the minimum value
                                      ;                     // best = min(best,
                                      ;                     //       minimax(depth+1, !isMax));
                                      ;                     m = minimax(depth+1, !isMax);
                                      ;                     ; for (int s = 0; s < depth; s++) printf("  ");
                                      ;                    //added by guy:
                                      ;                     m += depth;
                                      ;                     ; printf("    minimax isMAX=%d returned score %d  ", isMax, m);
                                      ;                      if (m < best) {
                                      ;                         best = m;
                                      ;                         ; printf("Best Lower\n");
                                      ;                     } else {
                                      ;                         ; printf("\n");
                                      ;                     }
                                      ;                     ; print_board(depth);

                                      ;                     // Undo the move
                                      ;                     board[i][j] = '_';
                                      ;                 }
                                      ;             }
                                      ;         }
                                      ;         return best;
                                      ;     }
                                      ; }


                                      ; This is the recursive module that tries all the combinations to find the
                                      ; best move.
                                      ; The routine takes one arg to say if we're trying to do Max or Min; Max is +1
                                      ; Min is -1, passed in AC
                             minimax:
@1625:051776                          ta minmax_ret            ; @@JumpedToBy a1707 a1751 a2036
@1626:041777                          ts minmax_lcl_isMax
@1627:075427                          sp push_minmax           ; store state on "the stack"
                                      ; .exec print_indent(cm, "Starting minimax: IsMax:%d, player: %d opponent %d, depth: %d" % (cm.rd(rl("minmax_lcl_isMax")), cm.rd(rl("player")), cm.rd(rl("opponent")), cm.rd(rl("push_lcl_depth"))), rl("push_lcl_depth"))
@1630:030000                          sd zero                  ; no-op
                                      ; .exec print_board(cm, rl("boardp"), rl("push_lcl_depth"), rl("player"), "Starting Minimax")
@1631:075344                          sp evaluate_board        ; figure out how we're doing
@1632:042000                          ts minmax_lcl_score

                     minmax_test_max:                          ; test if Maximizer has won
@1633:102000                          ca minmax_lcl_score
@1634:115166                          su c_10
@1635:134000                          dm 0                     ; test to see if score is +10
@1636:071640                          cp minmax_max_won        ; branch if yes
@1637:075643                          sp minmax_test_min

                      minmax_max_won:
                                      ; .print "Maximizer Won, score %d", minmax_lcl_score
@1640:102000                          ca minmax_lcl_score      ; @@JumpedToBy a1636
@1641:042003                          ts minmax_lcl_best       ; set up the return code
@1642:075772                          sp minmax_exit           ; all done

                     minmax_test_min:
@1643:102000                          ca minmax_lcl_score      ; @@JumpedToBy a1637
@1644:111166                          ad c_10
@1645:134000                          dm 0                     ; test to see if score is -10
@1646:071650                          cp minmax_min_won        ; branch if yes
@1647:075653                          sp minmax_test_tie

                      minmax_min_won:
                                      ; .print "Minimizer Won, score %d", minmax_lcl_score
@1650:102000                          ca minmax_lcl_score      ; @@JumpedToBy a1646
@1651:042003                          ts minmax_lcl_best       ; set up the return code
@1652:075772                          sp minmax_exit           ; all done

                     minmax_test_tie:
@1653:075266                          sp isMovesLeft           ; test if there are more moves to go @@JumpedToBy a1647
                                      ;.print "minmax_test_tie: isMovesLeft = %ad"
@1654:071656                          cp minmax_tie            ; Negative means "no more empty cells"
@1655:075661                          sp minmax_prepare_scan

                          minmax_tie:
@1656:100000                          ca zero                  ; @@JumpedToBy a1654
                                      ;.print "Minimax Tie"
@1657:042003                          ts minmax_lcl_best       ; set up the return code
@1660:075772                          sp minmax_exit           ; bail out

                 minmax_prepare_scan:
@1661:101777                          ca minmax_lcl_isMax      ; @@JumpedToBy a1655
@1662:071727                          cp minmax_not_isMax      ; branch if isMax == False

                                      ; ======== This section is "isMax == True" =============
                        minmax_isMax:
@1663:105167                          cs c_1000
@1664:042003                          ts minmax_lcl_best       ; initialize to Most Negative
@1665:100000                          ca zero                  ; prepare to scan all cells starting w/zero
@1666:042001                          ts minmax_lcl_next_cell
@1667:101165                          ca c_8n                  ; loop nine times
@1670:042002                          ts minmax_lcl_loop_cnt
                        minmax_loop1:
@1671:101265                          ca boardp                ; get the base board ptr to read the next cell @@JumpedToBy a1724
@1672:112001                          ad minmax_lcl_next_cell
@1673:045676                          td minmax_rd1
@1674:045702                          td minmax_wr1
@1675:046004                          td minmax_lcl_undo_move  ; this is only used _after_ the recursive call, and will need to be restored from stack
                          minmax_rd1:
@1676:100000                          ca 0                     ; fetch the next cell @@WrittenBy a1673
@1677:071701                          cp minmax_empty_cell1    ; continue if the cell is empty
@1700:075722                          sp minmax_loop1_end      ; go to the next loop step if the cell is not empty

                  minmax_empty_cell1:                          ; here, we know the cell we tested is empty, and a candidate for analysis
@1701:101172                          ca player                ; fetch the Player marker @@JumpedToBy a1677
                          minmax_wr1:
@1702:040000                          ts 0                     ; ... and write it into the cell @@WrittenBy a1674
                                      .exec print_experiment(cm, cb, "Trying  game piece %d to cell %d, count %d, isMax==True", ("player", "minmax_lcl_next_cell", "minmax_lcl_loop_cnt"), "push_lcl_depth")
@1703:030000                          sd zero                  ; no-op

@1704:104000                          cs zero                  ; load negative zero, i.e. all ones
@1705:031777                          sd minmax_lcl_isMax      ; Sum Digits, i.e., xor, will reverse isMax
@1706:104001                          cs one                   ; load -1 to signal isMax should be False
                                      ; here begins the recursion
                                      ; .exec print_indent(cm, "starting recursive call to minimax: isMax==True-branch, cell at %d, depth: %d, loop_count: %d" % (cm.rd(rl("minmax_lcl_next_cell")), cm.rd(rl("push_lcl_depth")), cm.rd(rl("minmax_lcl_loop_cnt"))), rl("push_lcl_depth"))
@1707:075625                          sp minimax
                                      ; the following adjustment probably shouldn't be done if the answer is Zero
@1710:114001                          su one                   ; push_lcl_depth       ; reduce the score by the calling depth
@1711:042006                          ts mm_lcl_ret_val        ; very local storage for the minimax return call
                                      ; .exec print_indent(cm, "finished recursive call to minimax: isMax==True-branch, cell at %d, depth: %d, loop_count: %d, score: 0o%o" % (cm.rd(rl("minmax_lcl_next_cell")), cm.rd(rl("push_lcl_depth")), cm.rd(rl("minmax_lcl_loop_cnt")), cm.rd(rl("mm_lcl_ret_val"))), rl("push_lcl_depth"))
@1712:116003                          su minmax_lcl_best       ; determine if this was the "best" score so far
@1713:071716                          cp minmax_not_best0      ; branch if we've seen a better score already

@1714:102006                          ca mm_lcl_ret_val        ; save this result as the Best Score So Far
@1715:042003                          ts minmax_lcl_best

                    minmax_not_best0:
@1716:102004                          ca minmax_lcl_undo_move  ; remember that modified instruction addresses are effectively local variables, so restore this one from the stack @@JumpedToBy a1713
                                      ;.exec print_experiment(cm, cb, "Undoing game piece %d in cell %d at 0o%o, isMax==True", ("player", "minmax_lcl_next_cell", "minmax_lcl_undo_move"), "push_lcl_depth")
@1717:045721                          td minmax_undo_move0
@1720:104001                          cs one                   ; undo the trial move
                   minmax_undo_move0:
@1721:040000                          ts 0                     ; @@WrittenBy a1717

                    minmax_loop1_end:                          ; get ready for the next cell iteration
@1722:132001                          ao minmax_lcl_next_cell  ; @@JumpedToBy a1700
@1723:132002                          ao minmax_lcl_loop_cnt
                                      ; .print "decrement loop count to %ad, depth: %d, isMax==True-branch", push_lcl_depth
@1724:071671                          cp minmax_loop1          ; go around again if the loop cnt is not exhausted

@1725:102003                          ca minmax_lcl_best       ; return the best score found in AC
@1726:075772                          sp minmax_exit           ; all done with this pass of isMax == True



                                      ; ======== This section is "isMax == False" =============
                    minmax_not_isMax:
@1727:101167                          ca c_1000                ; @@JumpedToBy a1662
@1730:042003                          ts minmax_lcl_best       ; initialize to Most Positive
@1731:100000                          ca zero                  ; prepare to scan all cells starting w/zero
@1732:042001                          ts minmax_lcl_next_cell
@1733:101165                          ca c_8n                  ; loop nine times
@1734:042002                          ts minmax_lcl_loop_cnt
                        minmax_loop2:
@1735:101265                          ca boardp                ; get the base board ptr to read the next cell @@JumpedToBy a1767
@1736:112001                          ad minmax_lcl_next_cell
@1737:045742                          td minmax_rd2
@1740:045746                          td minmax_wr2
@1741:046004                          td minmax_lcl_undo_move  ; store this address on the 'stack' for now
                          minmax_rd2:
@1742:100000                          ca 0                     ; fetch the next cell @@WrittenBy a1737
@1743:071745                          cp minmax_empty_cell2    ; continue if the cell is empty
@1744:075765                          sp minmax_loop2_end      ; go to the next loop step if the cell is not empty

                  minmax_empty_cell2:                          ; here, we know the cell we tested is empty, and a candidate for analysis
@1745:101173                          ca opponent              ; fetch the Opponent marker @@JumpedToBy a1743
                          minmax_wr2:
@1746:040000                          ts 0                     ; ... and write it into the cell @@WrittenBy a1740
                                      ; .exec print_experiment(cm, cb, "Trying  game piece %d in cell %d, count %d, isMax==False", ("opponent", "minmax_lcl_next_cell", "minmax_lcl_loop_cnt"), "push_lcl_depth")
@1747:030000                          sd zero                  ; no-op
                                      ;        cs zero                 ; load negative zero, i.e. all ones
                                      ;        sd minmax_lcl_isMax     ; Sum Digits, i.e., xor, will reverse isMax
@1750:100001                          ca one                   ; load -1 to signal isMax should be True
                                      ; here begins the recursion
                                      ; .exec print_indent(cm, "starting recursive call to minimax: isMax==False-branch, cell at %d, depth: %d, loop_count: %d" % (cm.rd(rl("minmax_lcl_next_cell")), cm.rd(rl("push_lcl_depth")), cm.rd(rl("minmax_lcl_loop_cnt"))), rl("push_lcl_depth"))
@1751:075625                          sp minimax
                                      ; the following adjustment probably shouldn't be done if the answer is Zero
@1752:110001                          ad one                   ;  push_lcl_depth       ; increase the (negative) score by the calling depth
@1753:042006                          ts mm_lcl_ret_val        ; very local storage for the minimax return value
                                      ; .exec print_indent(cm, "finished recursive call to minimax: isMax==False-branch, cell at %d, depth: %d, loop_count: %d, score: 0o%o" % (cm.rd(rl("minmax_lcl_next_cell")), cm.rd(rl("push_lcl_depth")), cm.rd(rl("minmax_lcl_loop_cnt")), cm.rd(rl("mm_lcl_ret_val"))), rl("push_lcl_depth"))


@1754:116003                          su minmax_lcl_best       ; determine if this was the "best" score so far
@1755:071757                          cp minmax_best2
@1756:075761                          sp minmax_not_best2      ; branch if we've seen a better score already

                        minmax_best2:
@1757:102006                          ca mm_lcl_ret_val        ; save this result as the Best Score So Far @@JumpedToBy a1755
@1760:042003                          ts minmax_lcl_best

                    minmax_not_best2:

@1761:102004                          ca minmax_lcl_undo_move  ; remember that modified instruction addresses are effectively local variables, so restore this one from the stack @@JumpedToBy a1756
                                      ; .exec print_experiment(cm, cb, "Undoing game piece %d in cell %d at 0o%o, isMax==False", ("player", "minmax_lcl_next_cell", "minmax_lcl_undo_move"), "push_lcl_depth")
@1762:045764                          td minmax_undo_move2
@1763:104001                          cs one                   ; undo the trial move
                   minmax_undo_move2:
@1764:040000                          ts 0                     ; @@WrittenBy a1762

                    minmax_loop2_end:                          ; get ready for the next cell iteration
@1765:132001                          ao minmax_lcl_next_cell  ; @@JumpedToBy a1744
@1766:132002                          ao minmax_lcl_loop_cnt
@1767:071735                          cp minmax_loop2          ; go around again if the loop cnt is not exhausted

@1770:102003                          ca minmax_lcl_best       ; return the best score found in AC
@1771:075772                          sp minmax_exit           ; all done with this pass of isMax == False


                         minmax_exit:
@1772:030000                          sd zero                  ; no-op for .exec @@JumpedToBy a1642 a1652 a1660 a1726 a1771
                                      ; .exec print_indent(cm, "Exiting minimax: IsMax:%d, depth: %d, score: %d" % (cm.rd(rl("minmax_lcl_isMax")), cm.rd(rl("push_lcl_depth")), cm.rd(rl("minmax_lcl_best"))), rl("push_lcl_depth"))
@1773:030000                          sd zero                  ; this is a no-op
                                      ; .exec print_board(cm, rl("boardp"), rl("push_lcl_depth"), rl("player") )
@1774:102003                          ca minmax_lcl_best

                                      ; note that we stash and retrieve the AC during PoP
@1775:075457                          sp pop_minmax
                          minmax_ret:
@1776:074000                          sp 0                     ; @@WrittenBy a1625

                                      ; the 'local data' for minmax must be copied/retrieved from the "stack" for recursion
                                      ; a "stack frame" must store from minmax_ret to minmax_lcl_data_end
@1777:000000        minmax_lcl_isMax: .word 0                  ; @@WrittenBy a1626 ReadBy a1661 a1705
@2000:000000        minmax_lcl_score: .word 0                  ; @@WrittenBy a1632 ReadBy a1633 a1640 a1643 a1650
@2001:000000    minmax_lcl_next_cell: .word 0                  ; @@WrittenBy a1666 a1722 a1732 a1765 ReadBy a1672 a1722 a1736 a1765
@2002:000000     minmax_lcl_loop_cnt: .word 0                  ; @@WrittenBy a1670 a1723 a1734 a1766 ReadBy a1723 a1766
@2003:000000         minmax_lcl_best: .word 0                  ; @@WrittenBy a1641 a1651 a1657 a1664 a1715 a1730 a1760 ReadBy a1712 a1725 a1754 a1770 a1774
@2004:000000    minmax_lcl_undo_move: .word 0                  ; @@WrittenBy a1675 a1741 ReadBy a1716 a1761
@2005:000000     minmax_lcl_data_end: .word 0                  ; this is just a marker for the end of data to be pushed

@2006:000000          mm_lcl_ret_val: .word 0                  ; @@WrittenBy a1711 a1753 ReadBy a1714 a1757



                                      ; // This will return the best possible move for the player
                                      ; // This routine used to return row and move with a single pointer to a struct.
                                      ; // Not a WW Kind of Thing, so I changed it to return two ints via args
                                      ; // struct Move findBestMove)
                                      ; void findBestMove(int *move_row, int *move_col)
                                      ; {
                                      ;     int bestVal = -1000;
                                      ;     int bestMove_row = -1;
                                      ;     int bestMove_col = -1;

                                      ;     // Traverse all cells, evaluate minimax function for
                                      ;     // all empty cells. And return the cell with optimal
                                      ;     // value.
                                      ;     for (int i = 0; i<3; i++)
                                      ;     {
                                      ;         for (int j = 0; j<3; j++)
                                      ;         {
                                      ;             // Check if cell is empty
                                      ;             if (board[i][j]=='_')
                                      ;             {
                                      ;                 // Make the move
                                      ;                 board[i][j] = player;

                                      ;                 // compute evaluation function for this
                                      ;                 // move.
                                      ;                 int moveVal = minimax(0, false);

                                      ;                 // Undo the move
                                      ;                 board[i][j] = '_';

                                      ;                 // If the value of the current move is
                                      ;                 // more than the best value, then update
                                      ;                 // best/
                                      ;                 printf("minimax returned %d  ", moveVal);
                                      ;                 if (moveVal > bestVal)
                                      ;                 {
                                      ;                     bestMove_row = i;
                                      ;                     bestMove_col = j;
                                      ;                     bestVal = moveVal;
                                      ;                     printf("Best\n");
                                      ;                 }
                                      ;                 else {
                                      ;                     printf("\n");
                                      ;                 }
                                      ;             }
                                      ;         }
                                      ;     }

                                      ;     printf("The value of the best Move for Player %c is : %d\n",
                                      ;             player, bestVal);

                                      ;     *move_row = bestMove_row;
                                      ;     *move_col = bestMove_col;
                                      ;     // return // bestMove;
                                      ; }


                                      ; findBestMove cycles through the board to find the move that results
                                      ; in the best score for the current Player
                                      ; The routine takes no explicit argument, but assumes that Player is the
                                      ; one we're trying to advance
                                      ; the assumption on calling this routine is that there's at least one move available to be tried
                                      ; This routine can take a while, so it redraws the screen a couple of times.  To indicate who'S
                                      ; doing what, we reverse the "player" bit temporarily.
                        findBestMove:
@2007:052063                          ta fBM_ret               ; @@JumpedToBy a0710

                                      ; switch the display to the machine player
@2010:100211                          ca which_player
@2011:030001                          sd const_1               ; xor a 1 into the LSB; i.e. 0->1 or 1->0
@2012:040211                          ts which_player

                                      ; initialize the 'best stuff' detector
@2013:105167                          cs c_1000
@2014:042064                          ts fBM_lcl_best_value
                                      ; .print "Starting findBestMove, player=%d, opponent=%d", player, opponent
@2015:104001                          cs one
@2016:042065                          ts fBM_lcl_best_move
@2017:101165                          ca c_8n
@2020:042066                          ts fBM_lcl_loop_count
@2021:100000                          ca zero
@2022:042067                          ts fBM_lcl_current_cell
@2023:101265                          ca boardp                ; we always start from cell zero`
@2024:046027                          td fBM_fetch_cell
@2025:046033                          td fBM_set_cell
@2026:046041                          td fBM_clear_cell

                                      ; we start the loop here, but the first test will bypass the rest of the loop if the cell is already spoken for
                      fBM_fetch_cell:
@2027:100000                          ca 0                     ; read the current cell into AC @@WrittenBy a2024 a2051 ReadBy a2051 JumpedToBy a2056
@2030:072032                          cp fBM_try_move          ; if the cell is empty, go on to try out a move
@2031:076051                          sp fBM_next_loop         ; take a pass on this non-empty cell, go on to the next one

                        fBM_try_move:
@2032:101172                          ca player                ; @@JumpedToBy a2030
                                      ; try out a move on this cell
                                      .print "fBM: try  empty cell %d, player=%d", fBM_lcl_current_cell, player
                        fBM_set_cell:
@2033:040000                          ts 0                     ; @@WrittenBy a2025 a2052 ReadBy a2052
@2034:074070                          sp draw_game_board       ; be careful to not trigger unintended recursion...

@2035:104001                          cs one                   ; tell Minimax to try for a Min score on this cell
                                      ; .print "fBM: call minimax, player=%d, IsMax=%ad", player
@2036:075625                          sp minimax               ; call the optimizer; best-score comes back in AC
                                      ;.print "fBM: minimax returned %ad"
@2037:042070                          ts fBM_lcl_tmp_score     ; stash the score for now

@2040:104001                          cs one                   ; undo the trial move, then evaluate the results of minimax
                      fBM_clear_cell:
@2041:040000                          ts 0                     ; @@WrittenBy a2026 a2053 ReadBy a2053

                                      ; see if we bested a previous score
@2042:102070                          ca fBM_lcl_tmp_score     ; compare the new result with previous best
@2043:116064                          su fBM_lcl_best_value    ; branch if the old one was better; i.e., skip updating the eval_score_players
@2044:072051                          cp fBM_next_loop

@2045:102070                          ca fBM_lcl_tmp_score
@2046:042064                          ts fBM_lcl_best_value    ; save the New Best Score
@2047:102067                          ca fBM_lcl_current_cell  ; and remember how we got here, i.e., which cell we tried
                                      .print "fBM new Best Move: score %d, cell %d, loop: %d", fBM_lcl_tmp_score, fBM_lcl_current_cell, fBM_lcl_loop_count
@2050:042065                          ts fBM_lcl_best_move

                       fBM_next_loop:
@2051:132027                          ao fBM_fetch_cell        ; @@JumpedToBy a2031 a2044
@2052:132033                          ao fBM_set_cell
@2053:132041                          ao fBM_clear_cell
@2054:132067                          ao fBM_lcl_current_cell
@2055:132066                          ao fBM_lcl_loop_count
@2056:072027                          cp fBM_fetch_cell        ; go 'round the loop again

                                      ; now switch the display back to the original (human) player
@2057:100211                          ca which_player
@2060:030001                          sd const_1               ; xor a 1 into the LSB; i.e. 0->1 or 1->0
@2061:040211                          ts which_player

                                      ; when we're done with the loop, return the best move found (not the score, the cell that played best)
@2062:102065                          ca fBM_lcl_best_move
                                      .print "fBM findBestMove for player %d returns move to cell %ad, score=%d", player, fBM_lcl_best_value
                             fBM_ret:
@2063:074000                          sp 0                     ; @@WrittenBy a2007
                  fBM_lcl_best_value:                          ; best score found so far
@2064:000000                          .word 0                  ; @@WrittenBy a2014 a2046 ReadBy a2043
                   fBM_lcl_best_move:                          ; remember the move that resulted in the best score
@2065:000000                          .word 0                  ; @@WrittenBy a2016 a2050 ReadBy a2062
                  fBM_lcl_loop_count:
@2066:000000                          .word 0                  ; @@WrittenBy a2020 a2055 ReadBy a2055
                fBM_lcl_current_cell:
@2067:000000                          .word 0                  ; @@WrittenBy a2022 a2054 ReadBy a2047 a2054
                   fBM_lcl_tmp_score:
@2070:000000                          .word 0                  ; @@WrittenBy a2037 ReadBy a2042 a2045


                                      ;=====================================================================================

                                      ; /* 16-segment character generator, originally in Core Memory Clock
                                      ;  *
                                      ;  * Guy Fedorkow, Feb 22, 2025
                                      ;  *  originally for Arduino Mega
                                      ;  *
                                      ;  */



                      unit_test_main:
@2071:104044                          cs c_scope_edge          ; @@JumpedToBy a2076
@2072:042160                          ts ds_argx
@2073:042161                          ts ds_argy
@2074:102077                          ca msgp
@2075:076134                          sp draw_str
                                      ;si 0
@2076:076071                          sp unit_test_main


@2077:002100                    msgp: .word msg                ; @@ReadBy a2074
@2100:000071                     msg: .flexl "N"
@2101:000030
@2102:000071                          .flexl "O"
@2103:000060
@2104:000071                          .flexl "W"
@2105:000046
@2106:000010                          .flexl " "
@2107:000071                          .flexl "I"
@2110:000014
@2111:000071                          .flexl "S"
@2112:000012
@2113:000010                          .flexl " "
@2114:000071                          .flexl "T"
@2115:000040
@2116:000071                          .flexl "H"
@2117:000050
@2120:000071                          .flexl "E"
@2121:000002
@2122:000010                          .flexl " "
@2123:000071                          .flexl "T"
@2124:000040
@2125:000071                          .flexl "I"
@2126:000014
@2127:000071                          .flexl "M"
@2130:000070
@2131:000071                          .flexl "E"
@2132:000002
@2133:177776                          .word -1


                                      ; -----------------------------------------
                                      ; draw a character string on the CRT
                                      ; AC contains a pointer to the string, terminated by the first negative 'character'
                                      ; ds_argx and ds_argy give the initial (x, y) location
                            draw_str:
@2134:052156                          ta ds_ret                ; @@JumpedToBy a0172 a2075
@2135:046157                          td ds_lcl_charp          ; save the character pointer passed in the ACC
                             ds_loop:
@2136:102160                          ca ds_argx               ; @@JumpedToBy a2155
@2137:042416                          ts d16c_argx
@2140:102161                          ca ds_argy
@2141:042417                          ts d16c_argy
@2142:102157                          ca ds_lcl_charp          ; walk the string from start to finish
@2143:046144                          td ds_get_char
                         ds_get_char:
@2144:100000                          ca 0                     ; fetch the next character in the string @@WrittenBy a2143
@2145:076346                          sp draw_16seg_char       ; actually draw the character!

@2146:132157                          ao ds_lcl_charp          ; prepare for next char in loop
@2147:046150                          td ds_test_str_end
                     ds_test_str_end:
@2150:100000                          ca 0                     ; @@WrittenBy a2147
@2151:072156                          cp ds_ret                ; test for a negative number as the marker for the string end; branch out if done

@2152:102160                          ca ds_argx
@2153:112345                          ad char_spacing
@2154:042160                          ts ds_argx
@2155:076136                          sp ds_loop

                              ds_ret:
@2156:074000                          sp 0                     ; @@WrittenBy a2134 JumpedToBy a2151

@2157:000000            ds_lcl_charp: .word 0                  ; pointer to the next character to display @@WrittenBy a2135 a2146 ReadBy a2142 a2146
@2160:000000                 ds_argx: .word 0                  ; @@WrittenBy a0170 a2072 a2154 ReadBy a2136 a2152
@2161:000000                 ds_argy: .word 0                  ; @@WrittenBy a0166 a2073 ReadBy a2140

                                      ; ---------------------------

                                      ; The following table, indexed by ASCII character, gives a bit map of which of the 16
                                      ; segments should be lit for each symbol.
                SixteenSegmentFlexop:
@2162:002163                          .word SixteenSegmentFlexo; @@ReadBy a2347
                 SixteenSegmentFlexo:
                         flexo_ucase:
@2163:125074                          .word 0o125074           ; /* # */
@2164:125074                          .word 0o125074           ; /* # */
@2165:100363                          .word 0o100363           ; /* E */
@2166:104377                          .word 0o104377           ; /* 8 */
@2167:125074                          .word 0o125074           ; /* # */
@2170:000060                          .word 0o000060           ; /* _ */
@2171:104317                          .word 0o104317           ; /* A */
@2172:004077                          .word 0o004077           ; /* 3 */
@2173:000000                          .word 0o000000           ; /* (space) */
@2174:021000                          .word 0o021000           ; /* : */
@2175:104273                          .word 0o104273           ; /* S */
@2176:104214                          .word 0o104214           ; /* 4 */
@2177:021063                          .word 0o021063           ; /* I */
@2200:042000                          .word 0o042000           ; /* / */
@2201:000374                          .word 0o000374           ; /* U */
@2202:104167                          .word 0o104167           ; /* 2 */
@2203:177777                          .word 0o177777           ; /* (del) */
@2204:040400                          .word 0o040400           ; /* ) */
@2205:021077                          .word 0o021077           ; /* D */
@2206:110263                          .word 0o110263           ; /* 5 */
@2207:114307                          .word 0o114307           ; /* R */
@2210:002014                          .word 0o002014           ; /* 1 */
@2211:000174                          .word 0o000174           ; /* J */
@2212:000017                          .word 0o000017           ; /* 7 */
@2213:010714                          .word 0o010714           ; /* N */
@2214:012000                          .word 0o012000           ; /* ( */
@2215:100303                          .word 0o100303           ; /* F */
@2216:104373                          .word 0o104373           ; /* 6 */
@2217:000363                          .word 0o000363           ; /* C */
@2220:104000                          .word 0o104000           ; /* - */
@2221:112300                          .word 0o112300           ; /* K */
@2222:125074                          .word 0o125074           ; /* # */
@2223:021003                          .word 0o021003           ; /* T */
@2224:125074                          .word 0o125074           ; /* # */
@2225:042063                          .word 0o042063           ; /* Z */
@2226:177777                          .word 0o177777           ; /* (del) */
@2227:000360                          .word 0o000360           ; /* L */
@2230:000000                          .word 0o000000           ; /* (space) */
@2231:050314                          .word 0o050314           ; /* W */
@2232:125074                          .word 0o125074           ; /* # */
@2233:104314                          .word 0o104314           ; /* H */
@2234:000000                          .word 0o000000           ; /* (space) */
@2235:104274                          .word 0o104274           ; /* Y */
@2236:125074                          .word 0o125074           ; /* # */
@2237:104307                          .word 0o104307           ; /* P */
@2240:125074                          .word 0o125074           ; /* # */
@2241:010377                          .word 0o010377           ; /* Q */
@2242:125074                          .word 0o125074           ; /* # */
@2243:000377                          .word 0o000377           ; /* O */
@2244:177777                          .word 0o177777           ; /* (del) */
@2245:025077                          .word 0o025077           ; /* B */
@2246:125074                          .word 0o125074           ; /* # */
@2247:004373                          .word 0o004373           ; /* G */
@2250:125074                          .word 0o125074           ; /* # */
@2251:104277                          .word 0o104277           ; /* 9 */
@2252:125074                          .word 0o125074           ; /* # */
@2253:002714                          .word 0o002714           ; /* M */
@2254:177777                          .word 0o177777           ; /* (del) */
@2255:052400                          .word 0o052400           ; /* X */
@2256:125074                          .word 0o125074           ; /* # */
@2257:042300                          .word 0o042300           ; /* V */
@2260:177777                          .word 0o177777           ; /* (del) */
@2261:042377                          .word 0o042377           ; /* 0 */
@2262:177777                          .word 0o177777           ; /* (del) */


                                      ; Lower Case not used yet
                                      ;flexo_lcase:
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o140140   ; /* e */
                                      ;        .word 0o104377   ; /* 8 */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o021000   ; /* | */
                                      ;        .word 0o120160   ; /* a */
                                      ;        .word 0o004077   ; /* 3 */
                                      ;        .word 0o000000   ; /* (space) */
                                      ;        .word 0o104060   ; /* = */
                                      ;        .word 0o120241   ; /* s */
                                      ;        .word 0o104214   ; /* 4 */
                                      ;        .word 0o020000   ; /* i */
                                      ;        .word 0o125000   ; /* + */
                                      ;        .word 0o020140   ; /* u */
                                      ;        .word 0o104167   ; /* 2 */
                                      ;        .word 0o177777   ; /* (del) */
                                      ;        .word 0o010000   ; /* . */
                                      ;        .word 0o024034   ; /* d */
                                      ;        .word 0o110263   ; /* 5 */
                                      ;        .word 0o100100   ; /* r */
                                      ;        .word 0o002014   ; /* 1 */
                                      ;        .word 0o021140   ; /* j */
                                      ;        .word 0o000017   ; /* 7 */
                                      ;        .word 0o120100   ; /* n */
                                      ;        .word 0o040000   ; /* , */
                                      ;        .word 0o125002   ; /* f */
                                      ;        .word 0o104373   ; /* 6 */
                                      ;        .word 0o100140   ; /* c */
                                      ;        .word 0o104000   ; /* - */
                                      ;        .word 0o033000   ; /* k */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o100340   ; /* t */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o140040   ; /* z */
                                      ;        .word 0o177777   ; /* (del) */
                                      ;        .word 0o000300   ; /* l */
                                      ;        .word 0o000000   ; /* (space) */
                                      ;        .word 0o050110   ; /* w */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o120300   ; /* h */
                                      ;        .word 0o000000   ; /* (space) */
                                      ;        .word 0o005034   ; /* y */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o101301   ; /* p */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o121201   ; /* q */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o120140   ; /* o */
                                      ;        .word 0o177777   ; /* (del) */
                                      ;        .word 0o120340   ; /* b */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o121241   ; /* g */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o104277   ; /* 9 */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o124110   ; /* m */
                                      ;        .word 0o177777   ; /* (del) */
                                      ;        .word 0o052400   ; /* x */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o040100   ; /* v */
                                      ;        .word 0o177777   ; /* (del) */
                                      ;        .word 0o042377   ; /* 0 */
                                      ;        .word 0o177777   ; /* (del) */


                                      ; // size of 16-segment characters
                                      .pp WIDTH_16SEG, 0o60
                                      .pp HEIGHT_16SEG, 0o110
                                      .pp OFFSET_16SEG, 0o10   ; 0d08
                                      .pp SPACING_16SEG, (WIDTH_16SEG + WIDTH_16SEG / 4) * 64

                                      ; Delta word for vectors
                                      ;  Left 8 bits are horizontal, right 8 are vertical
                                      ;  Of each, only the six left bits are used

                                      .pp DOWN_LEFT, ((127 - (OFFSET_16SEG - 3)) * 256 * 2) + (255 - HEIGHT_16SEG)
                                      .pp UP_RIGHT, (OFFSET_16SEG - 3) * 256 * 2 + HEIGHT_16SEG
                                      .pp HORIZ_RIGHT, WIDTH_16SEG * 256

                                      .pp UP_RIGHT_DIAG, ((OFFSET_16SEG + WIDTH_16SEG) * 256) + HEIGHT_16SEG
                                      .pp DOWN_RIGHT_DIAG, ((WIDTH_16SEG - OFFSET_16SEG) * 256) + (255 - HEIGHT_16SEG)


                                      ; // these defines give the relative offsets for the points
                                      ; // that make up a 16-segment display
                                      .pp P0x, 64 * OFFSET_16SEG
                                      .pp P0y, 64 * HEIGHT_16SEG

                                      .pp P1x, 64 * (OFFSET_16SEG + WIDTH_16SEG / 2)
                                      .pp P1y, 64 * HEIGHT_16SEG

                                      .pp P2x, 64 * (OFFSET_16SEG + WIDTH_16SEG)
                                      .pp P2y, 64 * HEIGHT_16SEG

                                      .pp P3x, 64 * (OFFSET_16SEG / 2 + WIDTH_16SEG)
                                      .pp P3y, 64 * HEIGHT_16SEG / 2

                                      .pp P4x, 64 * WIDTH_16SEG
                                      .pp P4y, 64 * 0

                                      .pp P5x, 64 * WIDTH_16SEG / 2;  P0...P1...P2
                                      .pp P5y, 64 * 0          ;  .         .
                                      ;  .         .
                                      .pp P6x, 64 * 0          ;  .         .
                                      .pp P6y, 64 * 0          ;  P7...P8...P3
                                      ;  .         .
                                      .pp P7x, 64 * OFFSET_16SEG / 2;  .         .
                                      .pp P7y, 64 * HEIGHT_16SEG / 2;  .         .
                                      ;  P6...P5...P4

                                      .pp P8x, 64 * (OFFSET_16SEG / 2 + WIDTH_16SEG / 2)
                                      .pp P8y, 64 * HEIGHT_16SEG / 2


                                      ; // and this array gives sixteen starting points and delta for each line
                                      ; // segment in the 16-segment display character.

                      seg_tab_startp:
@2263:002264                          .word seg00x

@2264:001000                  seg00x: .word P0x                ;   {P0, P1}
@2265:011000                  seg00y: .word P0y
@2266:030000                  seg00d: .word HORIZ_RIGHT

@2267:004000                  seg01x: .word P1x                ;   {P1, P2},
@2270:011000                  seg01y: .word P1y
@2271:030000                  seg01d: .word HORIZ_RIGHT

@2272:007000                  seg02x: .word P2x                ;   {P2, P3},
@2273:011000                  seg02y: .word P2y
@2274:172267                  seg02d: .word DOWN_LEFT

@2275:006400                  seg03x: .word P3x                ;   {P3, P4},
@2276:004400                  seg03y: .word P3y
@2277:172267                  seg03d: .word DOWN_LEFT

@2300:003000                  seg04x: .word P5x                ;   {P4, P5},
@2301:000000                  seg04y: .word P5y
@2302:030000                  seg04d: .word HORIZ_RIGHT

@2303:000000                  seg05x: .word P6x                ;   {P5, P6},
@2304:000000                  seg05y: .word P6y
@2305:030000                  seg05d: .word HORIZ_RIGHT

@2306:000000                  seg06x: .word P6x                ;   {P6, P7},
@2307:000000                  seg06y: .word P6y
@2310:005110                  seg06d: .word UP_RIGHT

@2311:000400                  seg07x: .word P7x                ;   {P7, P0},
@2312:004400                  seg07y: .word P7y
@2313:005110                  seg07d: .word UP_RIGHT

@2314:001000                  seg08x: .word P0x                ;   {P0, P8},
@2315:011000                  seg08y: .word P0y
@2316:024267                  seg08d: .word DOWN_RIGHT_DIAG

@2317:004000                  seg09x: .word P1x                ;   {P1, P8},
@2320:011000                  seg09y: .word P1y
@2321:172267                  seg09d: .word DOWN_LEFT

@2322:003400                  seg10x: .word P8x                ;   {P2, P8},
@2323:004400                  seg10y: .word P8y
@2324:034110                  seg10d: .word UP_RIGHT_DIAG

@2325:003400                  seg11x: .word P8x                ;   {P3, P8},
@2326:004400                  seg11y: .word P8y
@2327:030000                  seg11d: .word HORIZ_RIGHT

@2330:003400                  seg12x: .word P8x                ;   {P4, P8},
@2331:004400                  seg12y: .word P8y
@2332:024267                  seg12d: .word DOWN_RIGHT_DIAG

@2333:003400                  seg13x: .word P8x                ;   {P5, P8},
@2334:004400                  seg13y: .word P8y
@2335:172267                  seg13d: .word DOWN_LEFT

@2336:000000                  seg14x: .word P6x                ;   {P6, P8},
@2337:000000                  seg14y: .word P6y
@2340:034110                  seg14d: .word UP_RIGHT_DIAG

@2341:000400                  seg15x: .word P7x                ;   {P7, P8},
@2342:004400                  seg15y: .word P7y
@2343:030000                  seg15d: .word HORIZ_RIGHT

                        seg_tab_endp:
@2344:002341                          .word seg15x             ; @@ReadBy a2355
                        char_spacing:
@2345:007400                          .word SPACING_16SEG      ; @@ReadBy a2153


                                      ; Draw a Flexo character passed in to this routine in the ACC
                                      ; First, find the segment map for a given character.  Input is a Flexo-coded character.
                                      ; The routine returns a 16-bit int where each bit represents one stroke in the character.  If the
                                      ; bit is one, draw the stroke; if not, don't draw.
                                      ; Character position is given by the args d16c_argx, d16c_argy.
                     draw_16seg_char:
@2346:052415                          ta d16c_ret              ; @@JumpedToBy a2145

@2347:112162                          ad SixteenSegmentFlexop  ; add the table start addr to the offset in ACC
@2350:046351                          td d16c_rd
                             d16c_rd:
@2351:100000                          ca 0                     ; fetch the bit map @@WrittenBy a2350
@2352:042420                          ts d16c_lcl_seg_map

                                      ; draw the sixteen segments, starting with the most significant bit
@2353:104042                          cs c_15                  ; prep for 16 times around the loop
@2354:042421                          ts d16c_lcl_loop_cnt
@2355:102344                          ca seg_tab_endp          ; walk the segment table back to front
@2356:046411                          td d16c_read_seg_tabx    ; first table entry
                                      ;        td tmp_tabx
@2357:110001                          ad one
@2360:046406                          td d16c_read_seg_taby    ; second table entry
                                      ;        td tmp_taby
@2361:110001                          ad one
@2362:046413                          td d16c_read_seg_tabdxy  ; third table entry

                                      ; I've commented out a bit of debug code here to draw dots at each of the junction points in the
                                      ; 16-segment figure.  Use this to verify that the line segments are the right length...
                           d16s_loop:
                                      ; this strip draws dots at the intersection points
@2363:100000                          ca 0                     ; no op @@JumpedToBy a2404
                                      ;tmp_taby:
                                      ;        ca 0
@2364:000677                          si scope_point           ; ; Auto-Annotate I/O: Display Points
                                      ;tmp_tabx:
                                      ;        ca 0
                                      ;        rc 0
                                      ; end of debug hack
@2365:102420                          ca d16c_lcl_seg_map
@2366:072406                          cp d16c_draw_seg         ; branch if most significant bit is on

                  d16s_loop_continue:
@2367:102420                          ca d16c_lcl_seg_map      ; @@JumpedToBy a2414
@2370:170001                          clc 1                    ; shift AC left by one bit
@2371:042420                          ts d16c_lcl_seg_map
@2372:102411                          ca d16c_read_seg_tabx
@2373:115163                          su c_3
@2374:046411                          td d16c_read_seg_tabx
                                      ;        td tmp_tabx
@2375:102406                          ca d16c_read_seg_taby
@2376:115163                          su c_3
@2377:046406                          td d16c_read_seg_taby
                                      ;        td tmp_taby
@2400:102413                          ca d16c_read_seg_tabdxy
@2401:115163                          su c_3
@2402:046413                          td d16c_read_seg_tabdxy
@2403:132421                          ao d16c_lcl_loop_cnt
@2404:072363                          cp d16s_loop
@2405:076415                          sp d16c_ret              ; bail out when count exhausted

                                      ; on entry to this code block, the three entries in the segment table should give:
                                      ;   _tab1 = X pos'n
                                      ;   _tab2 = Y pos'n
                                      ;   _tab3 = XY Delta vector
                       d16c_draw_seg:                          ; branch here if we're doing a segment, then return to the loop
                                      ; the SI uses the AC to set Y coord
                  d16c_read_seg_taby:
@2406:100000                          ca 0                     ; @@WrittenBy a2360 a2377 ReadBy a2375 JumpedToBy a2366
@2407:112417                          ad d16c_argy
@2410:001677                          si scope_vector          ; initialize vector gen with the y-coord in ACC ; Auto-Annotate I/O: Display Vectors

                                      ; the RC uses AC to set X coord and mem address for the vector length
                  d16c_read_seg_tabx:
@2411:100000                          ca 0                     ; @@WrittenBy a2356 a2374 ReadBy a2372
@2412:112416                          ad d16c_argx
                d16c_read_seg_tabdxy:
@2413:024000                          rc 0                     ; @@WrittenBy a2362 a2402 ReadBy a2400
@2414:076367                          sp d16s_loop_continue

                            d16c_ret:                          ;; Return from draw_16seg_char
@2415:074000                          sp 0                     ; @@WrittenBy a2346 JumpedToBy a2405

                           d16c_argx:
@2416:000000                          .word 0                  ; @@WrittenBy a2137 ReadBy a2412
                           d16c_argy:
@2417:000000                          .word 0                  ; @@WrittenBy a2141 ReadBy a2407
                    d16c_lcl_seg_map:
@2420:000000                          .word 0                  ; @@WrittenBy a2352 a2371 ReadBy a2365 a2367
                   d16c_lcl_loop_cnt:
@2421:000000                          .word 0                  ; @@WrittenBy a2354 a2403 ReadBy a2403





                                      ; Character Table license

                                      ; /*
                                      ;  *  Project     Segmented LED Display - ASCII Library
                                      ;  *  @author     David Madison
                                      ;  *  @link       github.com/dmadison/Segmented-LED-Display-ASCII
                                      ;  *  @license    MIT - Copyright (c) 2017 David Madison
                                      ;  *
                                      ;  * Permission is hereby granted, free of charge, to any person obtaining a copy
                                      ;  * of this software and associated documentation files (the "Software"), to deal
                                      ;  * in the Software without restriction, including without limitation the rights
                                      ;  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                                      ;  * copies of the Software, and to permit persons to whom the Software is
                                      ;  * furnished to do so, subject to the following conditions:
                                      ;  *
                                      ;  * The above copyright notice and this permission notice shall be included in
                                      ;  * all copies or substantial portions of the Software.
                                      ;  *
                                      ;  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                                      ;  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                                      ;  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                                      ;  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                                      ;  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                                      ;  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
                                      ;  * THE SOFTWARE.
                                      ;  *
                                      ;  */


                                      ; /*********************************************************************************************************
                                      ;   END FILE
                                      ; *********************************************************************************************************/

