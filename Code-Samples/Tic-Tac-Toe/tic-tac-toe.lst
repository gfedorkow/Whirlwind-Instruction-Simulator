
                                      ; Tic Tac toe
                                      ; Guy Fedorkow
                                      ; Sep 26, 2024

                                      ; Simple game of tic-tac-toe written in Whirlwind assembly code.
                                      ; The game displays on the WW CRT, and can be played with the light gun
                                      ; (As of Sep 26, it's a two-person game, i.e., i alternates X and O plays)

                                      ; Geometry
                                      ; the basic game board is laid out on a 16x16 grid as follows:

                                      ;  cell 0   | cell 1   |  cell 2
                                      ;  @(4,12)  | @(8,12)  |  @(12,12)
                                      ; --------------------------------
                                      ;  cell 3   | cell 4   |  cell 5
                                      ;  @(4,8)   | @(8,8)   |  @(12,8)
                                      ; --------------------------------
                                      ;  cell 6   | cell 7   |  cell 8
                                      ;  @(4,4)   | @(8,4)   |  @(12,4)

                                      ;----------- old layout ----------
                                      ;  cell 6   | cell 7   |  cell 8
                                      ;  @(4,12)  | @(8,12)  |  @(12,12)
                                      ; --------------------------------
                                      ;  cell 3   | cell 4   |  cell 5
                                      ;  @(4,8)   | @(8,8)   |  @(12,8)
                                      ; --------------------------------
                                      ;  cell 0   | cell 1   |  cell 2
                                      ;  @(4,4)   | @(8,4)   |  @(12,4)
                                      ;-------------------------------

                                      .org 0
                                zero:
@0000:000000                 const_0: .word 0                  ; @@WrittenBy apc_table_ts upc_table_ts a0630 apm_copy_dst a0716 igb_table_ts a1442 a1475 a1700 a1717 a1744 a1762 a2031 a2037 ReadBy a0053 ca_addr a0170 dd_y_arg dd_x_arg dc_y_arg dc_x_arg dn_y_arg dn_x1_arg dw_y_arg dw_x_arg dt_y_arg dt_x_arg lgh_x1_arg lgh_y1_arg apc_ca0 upc_ca0 a0604 a0622 a0631 apm_copy_src a0650 a0660 a0667 a0717 a0734 itw_st_ca a0747 itw_cell_ts a0756 a0765 a0773 itw_inc_gb a1104 a1122 a1155 iML_bptr rd_brd1 rd_brd2 a1321 rd_brd3 a1331 a1345 a1363 a1401 a1411 a1414 a1441 a1474 a1626 a1633 a1643 a1654 a1663 a1674 a1701 a1702 a1727 a1740 a1745 a1770 a1771 a2017 a2025 a2107 a2113 a2314 a2326 a2351 a2354 JumpedToBy gb_state_sp a0173 a0343 a0360 a0402 a0423 a0445 a0464 a0503 a0513 light_gun_cell_hit_ret a0563 a0613 a0632 a0720 a0721 a1034 a1125 a1303 a1337 a1422 a1454 a1503 a1774 a2061 a2121 a2360
                                 one:
@0001:000001                 const_1: .word 1                  ; @@ReadBy a0061 set_game_over a0126 a0130 a0132 a0522 a0561 a0654 a0732 a1273 a1300 a1302 a1336 a1343 a1372 a1433 a1463 a1466 a1704 a1706 a1716 a1746 a1750 a1761 a2007 a2013 a2033 a2036 a2056 a2322 a2324


                                      ; constants for SI graphics instruction
                                      .pp scope_vector, 0o1677 ; draw a vector on all scopes
                                      .pp scope_point, 0o0677  ; draw a point on all scopes



                                      .org 0o40


@0040:075103                    main: sp init_game_board       ; call the init subroutine
@0041:074046                          sp refresh_loop          ; branch to main display refresh loop

                                      ; constants
@0042:000017                    c_15: .word 15                 ; @@ReadBy a2316
@0043:000040                    c_32: .word 32
@0044:073300            c_scope_edge: .word 950 * 32           ; close to the edge of the scope screen @@ReadBy a0164 a2067
@0045:062000             c_msg_x_pos: .word 800 * 32           ; @@ReadBy a0166

@0046:074067            refresh_loop: sp draw_game_board       ; @@JumpedToBy a0041 a0050 a0057 a0063 a0066
@0047:101127                          ca g_game_over           ; negative value means "game over"
@0050:070046                          cp refresh_loop
@0051:074725                          sp is_there_winner       ; check to see if this user move ended the game
@0052:100210                          ca which_player          ; if which_player is not zero, then the game has ended
@0053:134000                          dm zero
@0054:070056                          cp rl_continue_game
@0055:074064                          sp set_game_over         ; negative means no more moves

                    rl_continue_game:
@0056:100200                          ca light_gun_mailbox     ; @@JumpedToBy a0054
@0057:070046                          cp refresh_loop
                                      .print "light gun hit at cell %d", light_gun_mailbox
@0060:074565                          sp user_play_cell        ; do something with the light gun hit!  ; this call is for person-vs-computer play
@0061:104001                          cs one
@0062:040200                          ts light_gun_mailbox     ; mark the mailbox as empty

@0063:074046                          sp refresh_loop

@0064:104001           set_game_over: cs one                   ; the game_over flag starts set to zero by init_game_board @@JumpedToBy a0055
@0065:041127                          ts g_game_over           ; But when the game is over, we set it to -1
@0066:074046                          sp refresh_loop



                                      ; ************* Refresh the game board display ********************
                                      ; draw the tic-tac-toe grid
                                      ; two horizontal lines first
                     draw_game_board:
@0067:050173                          ta draw_game_board_ret   ; @@JumpedToBy refresh_loop a2032
@0070:105131                          cs const_2
@0071:040201                          ts loop_count
@0072:101134                          ca const_6
@0073:040203                          ts y_arg
                         x_grid_loop:
@0074:101131                          ca const_2               ; @@JumpedToBy a0104
@0075:040202                          ts x_arg
@0076:105141                          cs const_11
@0077:040206                          ts n_segments            ; segment count should be negative, ie, we will incr the value until positive
@0100:074325                          sp draw_x_line

@0101:101140                          ca const_10
@0102:040203                          ts y_arg
@0103:130201                          ao loop_count
@0104:070074                          cp x_grid_loop

                                      ; two vertical lines next
@0105:105131                          cs const_2
@0106:040201                          ts loop_count
@0107:101134                          ca const_6
@0110:040202                          ts x_arg
                         y_grid_loop:
@0111:101131                          ca const_2               ; @@JumpedToBy a0121
@0112:040203                          ts y_arg
@0113:105141                          cs const_11
@0114:040206                          ts n_segments            ; segment count should be negative, ie, we will incr the value until positive
@0115:074344                          sp draw_y_line

@0116:101140                          ca const_10
@0117:040202                          ts x_arg
@0120:130201                          ao loop_count
@0121:070111                          cp y_grid_loop

                                      ; Draw the game_state, ie, dots, naughts, or crosses
                     draw_game_state:
@0122:105136                          cs const_8               ; nine passes; var should be 8; loop count is negative
@0123:040201                          ts loop_count
@0124:100271                          ca gb_table_start
@0125:040175                          ts next_x_addr
@0126:110001                          ad const_1
@0127:040176                          ts next_y_addr
@0130:110001                          ad const_1
@0131:040177                          ts next_gb_state_addr
@0132:104001                          cs one
@0133:040200                          ts light_gun_mailbox
                             gb_loop:
@0134:100175               gb_x_inst: ca next_x_addr           ; @@JumpedToBy a0157
@0135:040204                          ts x_addr_arg
@0136:100176               gb_y_inst: ca next_y_addr
@0137:040205                          ts y_addr_arg
@0140:100177              gb_gs_inst: ca next_gb_state_addr
@0141:044142                          td ca_addr
@0142:100000                 ca_addr: ca 0                     ; @@WrittenBy a0141
@0143:044144                          td gb_state_sp
@0144:074000             gb_state_sp: sp 0                     ; draw the X, O or dot; this call may have a side-effect of seeing a light-gun hit @@WrittenBy a0143

                                      ; increment pointers and loop count for the next pass
@0145:100175                          ca next_x_addr
@0146:111132                          ad const_3
@0147:040175                          ts next_x_addr
@0150:100176                          ca next_y_addr
@0151:111132                          ad const_3
@0152:040176                          ts next_y_addr
@0153:100177                          ca next_gb_state_addr
@0154:111132                          ad const_3
@0155:040177                          ts next_gb_state_addr
@0156:130201                          ao loop_count
@0157:070134                          cp gb_loop

                 draw_current_player:                          ; draw an alpha string at the bottom of the screen to show the state of the game
@0160:100210                          ca which_player          ; see definition for this number
@0161:175135                          md const_7               ; clear the sign bit in case of "Game Over"
@0162:110220                          ad state_msg_tablep
@0163:044170                          td dcp_ca_addr

@0164:104044                          cs c_scope_edge          ; set the location to draw a string
@0165:042124                          ts ds_argy
@0166:104045                          cs c_msg_x_pos
@0167:042123                          ts ds_argx
                         dcp_ca_addr:
@0170:100000                          ca 0                     ; get the pointer to the string into ACC @@WrittenBy a0163
@0171:076077                          sp draw_str              ; "print" the string on the screen

@0172:074504                          sp draw_reset_symbol     ; draw the symbol to call for a game reset

                 draw_game_board_ret:                          ; return from the 'board display' subroutine
@0173:074000                          sp 0                     ; @@WrittenBy a0067


                                      ; Global variables
@0174:000000             move_number: .word 0                  ; count the number of moves @@WrittenBy a0612 a1105 ReadBy a0603 a0612

                                      ; ephemeral loop state variables
@0175:000000             next_x_addr: .word 0                  ; @@WrittenBy a0125 a0147 ReadBy gb_x_inst a0145
@0176:000000             next_y_addr: .word 0                  ; @@WrittenBy a0127 a0152 ReadBy gb_y_inst a0150
@0177:000000      next_gb_state_addr: .word 0                  ; @@WrittenBy a0131 a0155 ReadBy gb_gs_inst a0153
@0200:177776       light_gun_mailbox: .word -1                 ; used to pass light-gun hits back from the drawing routine.  Negative means "no hit" @@WrittenBy a0062 a0133 a0536 ReadBy a0056

                          loop_count:                          ; used only in top-level routines for drawing the game board
@0201:000000                          .word 0                  ; @@WrittenBy a0071 a0103 a0106 a0120 a0123 a0156 a1112 a1120 ReadBy a0103 a0120 a0156 a1120


                                      ; Arguments to pass into routines
@0202:000000                   x_arg: .word 0                  ; @@WrittenBy a0075 a0110 a0117 a0334 a0340 ReadBy a0332 a0335 a0340 a0351
@0203:000000                   y_arg: .word 0                  ; @@WrittenBy a0073 a0102 a0112 a0355 ReadBy a0326 a0345 a0355
@0204:000000              x_addr_arg: .word 0                  ; pointer to x_addr @@WrittenBy a0135 ReadBy a0372 a0412 a0433 a0455 a0474 a0516
@0205:000000              y_addr_arg: .word 0                  ; @@WrittenBy a0137 ReadBy a0364 a0404 a0425 a0447 a0466 a0524
@0206:000000              n_segments: .word 0                  ; @@WrittenBy a0077 a0114 a0341 a0356 ReadBy a0341 a0356
@0207:000000            gb_state_arg: .word 0

                                      ;  Game Play State
                                      ; this var is zero or one to show which player is on-deck for the next move
                                      ; But it can also be set to negative to say "Game Over", or 2 to say Win, three to say Draw/Tie
                                      ; The var, less the sign bit, is used to index player_icon_table below
@0210:000000            which_player: .word 0                  ; @@WrittenBy a0562 a1014 a1017 a1033 a1123 a2010 a2057 ReadBy a0052 a0160 a0362 a0554 a0560 a0575 a2006 a2055

@0211:000007     player_state_x_addr: .word 7                  ; These two constants control where the X or O indicator lands on the screen
@0212:000001     player_state_y_addr: .word 1
@0213:000211      player_state_x_ptr: .word player_state_x_addr
@0214:000212      player_state_y_ptr: .word player_state_y_addr

                                      ; Static lookup table to find how to draw the current player state
                                      ; The table is a pointer to subroutine entry points
@0215:000216       player_icon_table: .word dct0               ; @@ReadBy a0553 a0574
@0216:000403                    dct0: .word draw_cross
@0217:000424                    dct1: .word draw_naught        ; @@ReadBy a0627 a0715
                                      ;dct2:       .word draw_win
                                      ;dct3:       .word draw_tie

@0220:000221        state_msg_tablep: .word state_msg_table    ; @@ReadBy a0162
                     state_msg_table:
@0221:000226                          .word msg_cross_play
@0222:000237                          .word msg_naught_play
@0223:000250                          .word msg_x_win
@0224:000256                          .word msg_o_win
@0225:000264                          .word msg_draw


                      msg_cross_play:
                                      ;            .flexl "PLAYER X"
@0226:000054                          .word 0o000054
@0227:000044                          .word 0o000044
@0230:000006                          .word 0o000006
@0231:000052                          .word 0o000052
@0232:000002                          .word 0o000002
@0233:000024                          .word 0o000024
@0234:000010                          .word 0o000010
@0235:000072                          .word 0o000072
@0236:177776                          .word -1

                     msg_naught_play:
                                      ;            .flexl "PLAYER O"
@0237:000054                          .word 0o054
@0240:000044                          .word 0o044
@0241:000006                          .word 0o006
@0242:000052                          .word 0o052
@0243:000002                          .word 0o002
@0244:000024                          .word 0o024
@0245:000010                          .word 0o010
@0246:000060                          .word 0o060
@0247:177776                          .word -1

                           msg_x_win:
                                      ;            .flexl "X WIN"
@0250:000072                          .word 0o072
@0251:000010                          .word 0o010
@0252:000046                          .word 0o046
@0253:000014                          .word 0o014
@0254:000030                          .word 0o030
@0255:177776                          .word -1

                           msg_o_win:
                                      ;            .flexl "O WIN"
@0256:000060                          .word 0o060
@0257:000010                          .word 0o010
@0260:000046                          .word 0o046
@0261:000014                          .word 0o014
@0262:000030                          .word 0o030
@0263:177776                          .word -1

                            msg_draw:
                                      ;            .flexl "DRAW"
@0264:000022                          .word 0o022
@0265:000024                          .word 0o024
@0266:000006                          .word 0o006
@0267:000046                          .word 0o046
@0270:177776                          .word -1



                                      ; Game State Variables
                                      ; The Game Table is a nine-entry array that has one entry for each cell of the game board.
                                      ; The position of each cell on the game board is static, but the "state" var shows
                                      ; whether the cell contains a dot, a naught or a cross
@0271:000272          gb_table_start: .word gb0_x              ; @@ReadBy a0124 a0550 a0571 a0624 a0636 a0713 a0744 a1106
                                      ; Game Board State
@0272:000004                   gb0_x: .word 4
@0273:000014                   gb0_y: .word 12
@0274:000361               gb0_state: .word draw_dot
@0275:000010                   gb1_x: .word 8
@0276:000014                   gb1_y: .word 12
@0277:000361               gb1_state: .word draw_dot
@0300:000014                   gb2_x: .word 12
@0301:000014                   gb2_y: .word 12
@0302:000361               gb2_state: .word draw_dot
@0303:000004                   gb3_x: .word 4
@0304:000010                   gb3_y: .word 8
@0305:000361               gb3_state: .word draw_dot
@0306:000010                   gb4_x: .word 8
@0307:000010                   gb4_y: .word 8
@0310:000361               gb4_state: .word draw_dot
@0311:000014                   gb5_x: .word 12
@0312:000010                   gb5_y: .word 8
@0313:000361               gb5_state: .word draw_dot
@0314:000004                   gb6_x: .word 4
@0315:000004                   gb6_y: .word 4
@0316:000361               gb6_state: .word draw_dot
@0317:000010                   gb7_x: .word 8
@0320:000004                   gb7_y: .word 4
@0321:000361               gb7_state: .word draw_dot
@0322:000014                   gb8_x: .word 12
@0323:000004                   gb8_y: .word 4
@0324:000361               gb8_state: .word draw_dot



                                      ; subroutine to draw a horizontal line
                         draw_x_line:
@0325:050343                          ta draw_x_line_ret       ; save the return address @@JumpedToBy a0100
@0326:100203                          ca y_arg
@0327:115136                          su const_8               ; shift from 0-15 axis to -8 to +7
@0330:154014                          slr 12                   ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@0331:001677                          si scope_vector          ; initialize vector gen ; Auto-Annotate I/O: Display Vectors
@0332:100202                          ca x_arg
@0333:115136                          su const_8               ; shift from 0-15 axis to -8 to +7
@0334:040202                          ts x_arg
                          next_x_seg:
@0335:100202                          ca x_arg                 ; re-fetch the next x_arg @@JumpedToBy a0342
@0336:154014                          slr 12                   ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0

@0337:025147                          rc horiz_line_seg        ; Draw a segment with x=ACC
@0340:130202                          ao x_arg
@0341:130206                          ao n_segments            ; increment the segment counter
@0342:070335                          cp next_x_seg
                     draw_x_line_ret:
@0343:074000                          sp 0                     ; @@WrittenBy a0325

                                      ; subroutine to draw a vertical line
                         draw_y_line:
@0344:050360                          ta draw_y_line_ret       ; save the return address @@JumpedToBy a0115
                          next_y_seg:
@0345:100203                          ca y_arg                 ; @@JumpedToBy a0357
@0346:115136                          su const_8               ; shift from 0-15 axis to -8 to +7
@0347:154014                          slr 12                   ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@0350:001677                          si scope_vector          ; initialize vector gen with the y-coord in ACC ; Auto-Annotate I/O: Display Vectors
@0351:100202                          ca x_arg
@0352:115136                          su const_8               ; shift from 0-15 axis to -8 to +7
@0353:154014                          slr 12                   ; gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0

@0354:025150                          rc vert_line_seg         ; Draw a segment with x=ACC
@0355:130203                          ao y_arg
@0356:130206                          ao n_segments            ; increment the segment counter
@0357:070345                          cp next_y_seg
                     draw_y_line_ret:
@0360:074000                          sp 0                     ; @@WrittenBy a0344




                                      ; subroutine to draw a light-gun dot in an unplayed game cell
                                      ; the args into this routine are addresses of x and y locations, not
                                      ; the locations themselves
                            draw_dot:
@0361:050402                          ta draw_dot_ret          ; save return address
@0362:100210                          ca which_player          ; test to see if there's another move allowed
@0363:070402                          cp draw_dot_ret          ; if the var is negative, we're done playing

@0364:100205                          ca y_addr_arg            ; assuming the game's not over, we continue to draw
@0365:044366                          td dd_y_arg
@0366:100000                dd_y_arg: ca 0                     ; @@WrittenBy a0365
@0367:115136                          su const_8
@0370:154014                          slr 12                   ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@0371:000677                          si scope_point           ; initialize point gen with the y-coord in ACC ; Auto-Annotate I/O: Display Points
@0372:100204                          ca x_addr_arg
@0373:044374                          td dd_x_arg
@0374:100000                dd_x_arg: ca 0                     ; @@WrittenBy a0373
@0375:115136                          su const_8               ; shift from 0-15 axis to -8 to +7
@0376:154014                          slr 12                   ; gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@0377:024000                          rc 0                     ; Draw a pont with x=ACC
@0400:014000                          rd 0                     ; read the light gun
@0401:070514                          cp light_gun_cell_hit    ; call a subroutine to handle the light gun.  The gun number is in ACC
                        draw_dot_ret:
@0402:074000                          sp 0                     ; @@WrittenBy a0361 JumpedToBy a0363


                                      ; draw an "X" centered on the screen at the position of the x and y args
                                      ; args are passed as addresses
                          draw_cross:
@0403:050423                          ta draw_cross_ret

@0404:100205                          ca y_addr_arg
@0405:044406                          td dc_y_arg
@0406:100000                dc_y_arg: ca 0                     ; @@WrittenBy a0405
@0407:115136                          su const_8               ; shift from 0-15 axis to -8 to +7
@0410:154014                          slr 12                   ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@0411:001677                          si scope_vector          ; initialize vector gen with the y-coord in ACC ; Auto-Annotate I/O: Display Vectors
@0412:100204                          ca x_addr_arg
@0413:044414                          td dc_x_arg
@0414:100000                dc_x_arg: ca 0                     ; @@WrittenBy a0413
@0415:115136                          su const_8               ; shift from 0-15 axis to -8 to +7
@0416:154014                          slr 12                   ; gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0

@0417:025151                          rc diag_up_right_seg     ; Draw a segment with x=ACC
@0420:025152                          rc diag_dn_left_seg      ; Draw a segment with x=ACC
@0421:025154                          rc diag_up_left_seg      ; Draw a segment with x=ACC
@0422:025153                          rc diag_dn_right_seg     ; Draw a segment with x=ACC
                      draw_cross_ret:
@0423:074000                          sp 0                     ; @@WrittenBy a0403

                                      ; draw an "naught" (i.e. a diamond) centered on the screen at the position of the x and y args
                                      ; args are passed as addresses
                         draw_naught:
@0424:050445                          ta draw_naught_ret

@0425:100205                          ca y_addr_arg
@0426:044427                          td dn_y_arg
@0427:100000                dn_y_arg: ca 0                     ; @@WrittenBy a0426
@0430:115136                          su const_8               ; shift from 0-15 axis to -8 to +7
@0431:154014                          slr 12                   ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@0432:001677                          si scope_vector          ; initialize vector gen with the y-coord in ACC ; Auto-Annotate I/O: Display Vectors
@0433:100204                          ca x_addr_arg
@0434:044435                          td dn_x1_arg
@0435:100000               dn_x1_arg: ca 0                     ; @@WrittenBy a0434
@0436:115137                          su const_9               ; shift from 0-15 axis to -8 to +7; plus an offset
@0437:154014                          slr 12                   ; gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0

@0440:025151                          rc diag_up_right_seg     ; Draw a segment with x=ACC
@0441:025153                          rc diag_dn_right_seg     ; Draw a segment with x=ACC

@0442:111143                          ad const_2_cell          ; shift the x-pos two cells right
@0443:025154                          rc diag_up_left_seg      ; Draw a segment with x=ACC
@0444:025152                          rc diag_dn_left_seg      ; Draw a segment with x=ACC

                     draw_naught_ret:
@0445:074000                          sp 0                     ; @@WrittenBy a0424

                                      ; placeholder to draw a Win symbol centered on the screen at the position of the x and y args
                                      ; args are passed as addresses
                            draw_win:
@0446:050464                          ta draw_win_ret

@0447:100205                          ca y_addr_arg
@0450:044451                          td dw_y_arg
@0451:100000                dw_y_arg: ca 0                     ; @@WrittenBy a0450
@0452:115136                          su const_8               ; shift from 0-15 axis to -8 to +7
@0453:154014                          slr 12                   ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@0454:001677                          si scope_vector          ; initialize vector gen with the y-coord in ACC ; Auto-Annotate I/O: Display Vectors
@0455:100204                          ca x_addr_arg
@0456:044457                          td dw_x_arg
@0457:100000                dw_x_arg: ca 0                     ; @@WrittenBy a0456
@0460:115136                          su const_8               ; shift from 0-15 axis to -8 to +7
@0461:154014                          slr 12                   ; gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0

@0462:025151                          rc diag_up_right_seg     ; Draw a segment with x=ACC
                                      ;          rc diag_dn_left_seg   ; Draw a segment with x=ACC
@0463:025154                          rc diag_up_left_seg      ; Draw a segment with x=ACC
                                      ;          rc diag_dn_right_seg  ; Draw a segment with x=ACC
                        draw_win_ret:
@0464:074000                          sp 0                     ; @@WrittenBy a0446

                                      ; placeholder to draw a Tie symbol centered on the screen at the position of the x and y args
                                      ; args are passed as addresses
                            draw_tie:
@0465:050503                          ta draw_tie_ret

@0466:100205                          ca y_addr_arg
@0467:044470                          td dt_y_arg
@0470:100000                dt_y_arg: ca 0                     ; @@WrittenBy a0467
@0471:115136                          su const_8               ; shift from 0-15 axis to -8 to +7
@0472:154014                          slr 12                   ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@0473:001677                          si scope_vector          ; initialize vector gen with the y-coord in ACC ; Auto-Annotate I/O: Display Vectors
@0474:100204                          ca x_addr_arg
@0475:044476                          td dt_x_arg
@0476:100000                dt_x_arg: ca 0                     ; @@WrittenBy a0475
@0477:115136                          su const_8               ; shift from 0-15 axis to -8 to +7
@0500:154014                          slr 12                   ; gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0

                                      ;          rc diag_up_right_seg  ; Draw a segment with x=ACC
@0501:025152                          rc diag_dn_left_seg      ; Draw a segment with x=ACC
                                      ;          rc diag_up_left_seg   ; Draw a segment with x=ACC
@0502:025153                          rc diag_dn_right_seg     ; Draw a segment with x=ACC
                        draw_tie_ret:
@0503:074000                          sp 0                     ; @@WrittenBy a0465


                   draw_reset_symbol:
@0504:050513                          ta draw_reset_symbol_ret ; @@JumpedToBy a0172
@0505:105135                          cs const_7               ; put the point at game-board coord (1, 1)
@0506:154014                          slr 12
                                      ; ACC contains the coord; use the same number for x and y
@0507:000677                          si scope_point           ; initialize point gen with the y-coord in ACC ; Auto-Annotate I/O: Display Points
@0510:024000                          rc 0                     ; Draw a pont with x=ACC
@0511:014000                          rd 0                     ; read the light gun
@0512:071103                          cp init_game_board       ; call a subroutine to handle the light gun.

               draw_reset_symbol_ret:
@0513:074000                          sp 0                     ; @@WrittenBy a0504



                                      ; ***************************  User Interaction ***********************

                                      ; Handle a user light_gun hit on one of the game cells
                                      ; Remember that this is called only from the routine that draws a
                                      ; dot in the middle of a cell on the game grid.
                                      ; This routine converts the y_address from screen polarity (more positive is up)
                                      ; to Game Board polarity (numbered from top=0 to bottom=2) by subtracting the
                                      ; light gun coord from three.
                                      ; The light gun number is passed to this routine in ACC
                  light_gun_cell_hit:
@0514:050540                          ta light_gun_cell_hit_ret; @@JumpedToBy a0401

@0515:040543                          ts lcl_gun_num
@0516:100204                          ca x_addr_arg
@0517:044520                          td lgh_x1_arg
@0520:100000              lgh_x1_arg: ca 0                     ; load the x value of the cell's address in the grid @@WrittenBy a0517
@0521:160002                          srr 2                    ; divide the cell x address by four to get 1, 2, or 3
@0522:114001                          su const_1               ; change from one-base to zero-base
@0523:040541                          ts lcl_cell_x

@0524:100205                          ca y_addr_arg            ; repeat the process for the y coordinate
@0525:044526                          td lgh_y1_arg
@0526:100000              lgh_y1_arg: ca 0                     ; load the y value of the cell's address in the grid @@WrittenBy a0525
@0527:160002                          srr 2                    ; divide the cell y address by four to get 1, 2, or 3
@0530:031130                          sd const_0n              ; invert to get negative number
@0531:111132                          ad const_3               ; change from one-base to zero-base and invert order
@0532:040542                          ts lcl_cell_y
@0533:155001                          slh 1                    ; multiply y by three, i.e., double then address
@0534:110542                          ad lcl_cell_y
@0535:110541                          ad lcl_cell_x            ; add x to get the cell number in the range 0-8

                                      .print "light gun %o hit x=%o, y=%o, cell=%ao", lcl_gun_num, lcl_cell_x, lcl_cell_y

                                      ; the cell number of the hit is passed below in ACC
                                      ; sp alternate_play_cell   ; do something with the light gun hit!; this call is for two-person play
@0536:040200                          ts light_gun_mailbox
                                      ; sp user_play_cell   ; do something with the light gun hit!  ; this call is for person-vs-computer play

@0537:074725                          sp is_there_winner       ; test to see if it's Game Over

@0540:074000  light_gun_cell_hit_ret: sp 0                     ; @@WrittenBy a0514

                                      ; temp vars for figuring the cell number in light_gun_cell_hit
@0541:000000              lcl_cell_x: .word 0                  ; @@WrittenBy a0523 ReadBy a0535
@0542:000000              lcl_cell_y: .word 0                  ; @@WrittenBy a0532 ReadBy a0534
@0543:000000             lcl_gun_num: .word 0                  ; @@WrittenBy a0515


                                      ; "Play" a cell
                                      ; This routine does a simple two-person-style play; each light gun hit simply alternates
                                      ; between X and O
                                      ; The Cell Number to play is passed in the ACC
                                      ; Note that this routine can only be called on a previously-unplayed cell, 'cause those
                                      ; are the only ones with dots in them, and that's all the light gun can see
                 alternate_play_cell:
@0544:050563                          ta alternate_play_cell_ret

@0545:040564                          ts lcl_aplay_cell_num    ; figure the pointer to the first cell draw function in game table
@0546:155001                          slh 1                    ;  thats table_start + 3*cwll_num + 2
@0547:110564                          ad lcl_aplay_cell_num    ; multiply cell number by three for a table offset
@0550:110271                          ad gb_table_start
@0551:111131                          ad const_2
@0552:044557                          td apc_table_ts

@0553:100215                          ca player_icon_table     ; figure out what the new cell should be
@0554:110210                          ad which_player
@0555:044556                          td apc_ca0
@0556:100000                 apc_ca0: ca 0                     ; ACC should now contain the address of the X or O display routine @@WrittenBy a0555
@0557:040000            apc_table_ts: ts 0                     ; store the display routine to the game state table @@WrittenBy a0552

                                      ; now switch to the other player for the next move
@0560:100210                          ca which_player
@0561:030001                          sd const_1               ; xor a 1 into the LSB; i.e. 0->1 or 1->0
@0562:040210                          ts which_player

             alternate_play_cell_ret:
@0563:074000                          sp 0                     ; @@WrittenBy a0544
@0564:000000      lcl_aplay_cell_num: .word 0                  ; @@WrittenBy a0545 ReadBy a0547



                                      ; This routine plays person against computer; each light gun hit plays an Cross,
                                      ; then the machine plays Naught
                                      ; Note that this routine can only be called on a previously-unplayed cell, 'cause those
                                      ; are the only ones with dots in them, and that's all the light gun can see.
                                      ; The number of the cell being played is in ACC
                      user_play_cell:
@0565:050613                          ta user_play_cell_ret    ; @@JumpedToBy a0060

@0566:040614                          ts lcl_uplay_cell_num    ; figure the pointer to the first cell draw function in game table
@0567:155001                          slh 1                    ;  thats table_start + 3*cell_num + 2
@0570:110614                          ad lcl_uplay_cell_num    ; multiply cell number by three for a table offset
@0571:110271                          ad gb_table_start
@0572:111131                          ad const_2
@0573:044600                          td upc_table_ts

@0574:100215                          ca player_icon_table     ; figure out what the new cell should be
@0575:110210                          ad which_player
@0576:044577                          td upc_ca0
@0577:100000                 upc_ca0: ca 0                     ; ACC should now contain the address of the X or O display routine @@WrittenBy a0576
@0600:040000            upc_table_ts: ts 0                     ; store the display routine to the game state table @@WrittenBy a0573

@0601:074725                          sp is_there_winner       ; check to see if this user move ended the game
@0602:070612                          cp upc_cleanup           ; negative means no more moves

                                      ; now switch to the other player for the next move
                                      ; table_play_move is used to optimize the first move by a simple table lookup
                                      ; auto_play_move calls minimax to figure the best move, then makes the move
                                      ; by updating the icon on the game board.
@0603:100174                          ca move_number
@0604:134000                          dm 0                     ; test if this is Move Zero, i.e., the first user move
@0605:070610                          cp upc_move_zero         ; branch for first move, fall through for subsequent moves

@0606:074635                          sp auto_play_move
@0607:074612                          sp upc_cleanup

                       upc_move_zero:
@0610:100614                          ca lcl_uplay_cell_num    ; @@JumpedToBy a0605
@0611:074615                          sp table_play_move

                         upc_cleanup:
@0612:130174                          ao move_number           ; @@JumpedToBy a0602 a0607
                  user_play_cell_ret:
@0613:074000                          sp 0                     ; @@WrittenBy a0565
@0614:000000      lcl_uplay_cell_num: .word 0                  ; @@WrittenBy a0566 ReadBy a0570 a0610


                                      ; The first move is optimized to avoid MinMax. by using a Table lookup
                                      ; AC contains the cell number of the first human move
                     table_play_move:
@0615:050632                          ta table_play_move_ret   ; @@JumpedToBy a0611
@0616:040633                          ts lcl_tpm_user_move     ; stash the arg

@0617:101071                          ca first_move_table_start
@0620:110633                          ad lcl_tpm_user_move
@0621:044622                          td tpm_fetch_move_table
                tpm_fetch_move_table:
@0622:100000                          ca 0                     ; fetch the offset of the computer move that will be used to respond @@WrittenBy a0621
@0623:040634                          ts lcl_tpm_table_move
@0624:110271                          ad gb_table_start
@0625:111157                          ad c_2
@0626:044630                          td tpm_store_move
@0627:100217                          ca dct1                  ; this is wired to have the machine move Naught
                      tpm_store_move:
@0630:040000                          ts 0                     ; update the game state table @@WrittenBy a0626
                                      .print "User move to cell %d; Table-driven move to cell offset %d / 3, ts 0o%o 0o%ao", lcl_tpm_user_move, lcl_tpm_table_move, tpm_store_move
@0631:030000                          sd zero                  ; no-op for Print

                 table_play_move_ret:
@0632:074000                          sp 0                     ; @@WrittenBy a0615

                   lcl_tpm_user_move:
@0633:000000                          .word 0                  ; @@WrittenBy a0616 ReadBy a0620
                  lcl_tpm_table_move:
@0634:000000                          .word 0                  ; @@WrittenBy a0623



                                      ; set up to call findBestMove
                      auto_play_move:
@0635:050720                          ta apm_ret               ; @@JumpedToBy a0606
@0636:100271                          ca gb_table_start
@0637:111131                          ad const_2               ; the game piece is offset three from the table start
@0640:044645                          td apm_copy_src
@0641:101263                          ca boardp
@0642:044673                          td apm_copy_dst
@0643:105136                          cs const_8
@0644:040722                          ts lcl_apm_copy_count

@0645:100000            apm_copy_src: ca 0                     ; @@WrittenBy a0640 a0675 a0676 a0677 ReadBy a0675 a0676 a0677 JumpedToBy a0701
@0646:040723                          ts lcl_apm_cell_state

@0647:135045            apm_test_dot: dm dot_fn_addr           ; test if it's a Dot
@0650:134000                          dm 0
@0651:070653                          cp apm_its_a_dot
@0652:074656                          sp apm_test_naught
@0653:131041           apm_its_a_dot: ao lcl_dot_count         ; @@JumpedToBy a0651
@0654:104001                          cs one                   ; store -1 for "unplayed"
@0655:074673                          sp apm_copy_dst

@0656:100723         apm_test_naught: ca lcl_apm_cell_state    ; retrieve the cell state @@JumpedToBy a0652
@0657:135047                          dm naught_fn_addr        ; test if it's an X
@0660:134000                          dm 0
@0661:070663                          cp apm_its_a_naught
@0662:074665                          sp apm_test_cross
@0663:101167        apm_its_a_naught: ca c_oh                  ; load the value for a Naught @@JumpedToBy a0661
@0664:074673                          sp apm_copy_dst

@0665:100723          apm_test_cross: ca lcl_apm_cell_state    ; @@JumpedToBy a0662
@0666:135046                          dm cross_fn_addr         ; test if it's an X
@0667:134000                          dm 0
@0670:070672                          cp apm_its_a_cross
@0671:074721                          sp apm_panic             ; huh, it's not a dot, cross or naught
@0672:101166         apm_its_a_cross: ca c_XX                  ; load value for a cross @@JumpedToBy a0670
                                      ; fall through to finish the copy step

@0673:040000            apm_copy_dst: ts 0                     ; @@WrittenBy a0642 a0674 ReadBy a0674 JumpedToBy a0655 a0664
@0674:130673                          ao apm_copy_dst          ; step the destination once
@0675:130645                          ao apm_copy_src          ; step the source three times
@0676:130645                          ao apm_copy_src
@0677:130645                          ao apm_copy_src
@0700:130722                          ao lcl_apm_copy_count
@0701:070645                          cp apm_copy_src          ; around the loop again
                                      ; finished copying

                                      ; this ought to test who's playing whom, but the code below has the
                                      ; human player wired as Cross, the computer plays Nought
@0702:101167                          ca c_oh
@0703:041170                          ts player
@0704:101166                          ca c_XX
@0705:041171                          ts opponent
                                      ; .exec print_board(cm, rl("boardp"), rl("push_lcl_depth"), rl("player"), "calling findBestMove")
@0706:076005                          sp findBestMove          ; return the cell number for the Best Move in ACC
@0707:040724                          ts lcl_cell_for_move

                                      ; prepare to make the suggested move permanent in the game board
@0710:154001                          slr 1                    ; multiply cell number by three
@0711:110724                          ad lcl_cell_for_move
@0712:111157                          ad c_2                   ; point to cell state in game board table
@0713:110271                          ad gb_table_start
@0714:044716                          td apm_store_move

                                      ; ca player           ;  "player" is (1, 2) for (X, O); offset for player_tab (0, 1) for (X, O)
                                      ; su one
                                      ; ad player_icon_table  ; form a pointer to the icon table
                                      ; td apm_fetch_icon_fn
                                      ; ca dct1                 ; the code above should be "put back" to compute the right icon
                                      ; td apm_fetch_icon_fn

                                      .exec print_experiment(cm, cb, "move game board player %d to cell %d, function 0o%o to gb offset 0o%o", ("player", "lcl_cell_for_move", "apm_fetch_icon_fn", "apm_store_move"), 0)

                   apm_fetch_icon_fn:
@0715:100217                          ca dct1                  ; this address should be dynamically set, not fixed to "naught"
                      apm_store_move:
@0716:040000                          ts 0                     ; @@WrittenBy a0714
@0717:030000                          sd zero                  ; for debug

                             apm_ret:
@0720:074000                          sp 0                     ; @@WrittenBy a0635

                           apm_panic:
                                      .print "APM_Panic Halt: not dot, cross or naught in auto_play_move: lcl_apm_cell_state=0o%o", lcl_apm_cell_state
@0721:074000                          sp 0                     ; @@JumpedToBy a0671

                  lcl_apm_copy_count:
@0722:000000                          .word 0                  ; @@WrittenBy a0644 a0700 ReadBy a0700
                  lcl_apm_cell_state:
@0723:000000                          .word 0                  ; @@WrittenBy a0646 ReadBy apm_test_naught apm_test_cross
                   lcl_cell_for_move:
@0724:000000                          .word 0                  ; @@WrittenBy a0707 ReadBy a0711

                                      ;;;;;;;;;;;;;;;;;

                                      ; Analyze game for a winner
                                      ; This is done by counting X and O in each horiz & vert row, plus the two diagonals.
                                      ; The routine is controlled by a table giving the start cell and increment.  For each
                                      ; table entry, we count three cells in the game_board state array
                                      ; This routing contains two nested loops, the outer one that walks the analysis table,
                                      ; and the inner one that counts three cells
                                      ; This long subroutine goes in two parts
                                      ;   a) count what's in each cell on each row, column and diagonal (eight in all)
                                      ;   b) then see if anyone won
                                      ;   [future part c might determine if anyone could win on the next round]
                                      ; The second part also can determine if the game is tied, i.e., no open cells left to play
                                      ;   [Use of this routine would be cleaner if it returned with +0 if there are more moves,
                                      ;     or -0 if it's 'game over']
                     is_there_winner:
@0725:051034                          ta is_there_winner_ret   ; @@JumpedToBy a0051 a0537 a0601
                                      ; set up the outer loop
@0726:105135                          cs const_7
@0727:041035                          ts lcl_tb_loop_count
@0730:101050                          ca analysis_table_start  ; prepare pointers into the analysis table
@0731:044740                          td itw_st_ca
@0732:110001                          ad const_1
@0733:045000                          td itw_inc_gb
@0734:104000                          cs const_0               ; initialize with negative zero to simplify zero-detect later
@0735:041042                          ts lcl_total_dots        ; count all the unplayed cells

                                      ; set up the inner loop
@0736:105131          itw_outer_loop: cs const_2               ; @@JumpedToBy a1026
@0737:041036                          ts lcl_cell_loop_count
@0740:100000               itw_st_ca: ca 0                     ; load the starting cell number from the table @@WrittenBy a0731 a1021 a1022 ReadBy a1021 a1022
@0741:041043                          ts lcl_cell_number
@0742:155001                          slh 1
@0743:111043                          ad lcl_cell_number
@0744:110271                          ad gb_table_start
@0745:111131                          ad const_2               ; move to the gb_state val in gb table
@0746:044753                          td itw_cell_ts           ; pointer to first entry for this try in the gb table

@0747:100000                          ca const_0
@0750:041037                          ts lcl_naught_count
@0751:041040                          ts lcl_cross_count
@0752:041041                          ts lcl_dot_count

                      itw_inner_loop:
@0753:100000             itw_cell_ts: ca 0                     ; fetch whatever is in this cell @@WrittenBy a0746 a1001 ReadBy a0777 JumpedToBy a1003
@0754:041044                          ts lcl_cell_state
@0755:135045                test_dot: dm dot_fn_addr           ; test if it's a Dot
@0756:134000                          dm 0
@0757:070761                          cp its_a_dot
@0760:074763                          sp test_naught
@0761:131041               its_a_dot: ao lcl_dot_count         ; @@JumpedToBy a0757
@0762:131042                          ao lcl_total_dots

@0763:101044             test_naught: ca lcl_cell_state        ; retrieve the cell state @@JumpedToBy a0760
@0764:135047                          dm naught_fn_addr        ; test if it's an X
@0765:134000                          dm 0
@0766:070770                          cp its_a_naught
@0767:074771                          sp test_cross
@0770:131037            its_a_naught: ao lcl_naught_count      ; @@JumpedToBy a0766

@0771:101044              test_cross: ca lcl_cell_state        ; @@JumpedToBy a0767
@0772:135046                          dm cross_fn_addr         ; test if it's an X
@0773:134000                          dm 0
@0774:070776                          cp its_a_cross
@0775:074777                          sp itw_inner_loop_test_end
@0776:131040             its_a_cross: ao lcl_cross_count       ; @@JumpedToBy a0774

             itw_inner_loop_test_end:
                                      ; move to next cell in the inner loop
@0777:100753                          ca itw_cell_ts           ; @@JumpedToBy a0775
@1000:110000              itw_inc_gb: ad 0                     ; add whatever the analysis table says is the increment @@WrittenBy a0733 a1023 a1024 ReadBy a1023 a1024
@1001:040753                          ts itw_cell_ts
@1002:131036                          ao lcl_cell_loop_count
@1003:070753                          cp itw_inner_loop        ; end of inner loop

                                      ; .print "analysis loop %o, dots=%o, crosses=%o, naughts=%o", lcl_tb_loop_count, lcl_dot_count, lcl_cross_count, lcl_naught_count
                                      ; test to see if there's a winner
@1004:101132                          ca const_3
@1005:135037                          dm lcl_naught_count
@1006:071013                          cp naught_win
@1007:101132                          ca const_3
@1010:135040                          dm lcl_cross_count
@1011:071016                          cp cross_win
@1012:075021                          sp itw_next_outer_loop

@1013:101145              naught_win: ca const_o_win           ; 02 with the sign bit @@JumpedToBy a1006
@1014:040210                          ts which_player          ; mark the game as "over" and a Win
                                      .print "naught win"
@1015:075021                          sp itw_next_outer_loop

@1016:101144               cross_win: ca const_x_win           ; @@JumpedToBy a1011
@1017:040210                          ts which_player          ; mark the game as "over" and a Win
                                      .print "cross win"
@1020:075021                          sp itw_next_outer_loop

                                      ; now move to next entry in outer loop
                 itw_next_outer_loop:
@1021:130740                          ao itw_st_ca             ; @@JumpedToBy a1012 a1015 a1020
@1022:130740                          ao itw_st_ca
@1023:131000                          ao itw_inc_gb
@1024:131000                          ao itw_inc_gb
@1025:131035                          ao lcl_tb_loop_count
@1026:070736                          cp itw_outer_loop

                                      ; .print "unplayed cells=0d%d", lcl_total_dots
@1027:101042                          ca lcl_total_dots
@1030:071032                          cp its_a_tie             ; negative zero means its a tie (i.e., zero dots found)
@1031:075034                          sp is_there_winner_ret   ; so if it's not negative, we're done

@1032:101146               its_a_tie: ca const_draw            ; table offset 04 with the sign bit @@JumpedToBy a1030
                                      .print "game tie"
@1033:040210                          ts which_player          ; mark the game as "over" and a Draw

                 is_there_winner_ret:
@1034:074000                          sp 0                     ; @@WrittenBy a0725 JumpedToBy a1031


                                      ; local variables
@1035:000000       lcl_tb_loop_count: .word 0                  ; @@WrittenBy a0727 a1025 ReadBy a1025
@1036:000000     lcl_cell_loop_count: .word 0                  ; @@WrittenBy a0737 a1002 ReadBy a1002
@1037:000000        lcl_naught_count: .word 0                  ; @@WrittenBy a0750 its_a_naught ReadBy its_a_naught a1005
@1040:000000         lcl_cross_count: .word 0                  ; @@WrittenBy a0751 its_a_cross ReadBy its_a_cross a1010
@1041:000000           lcl_dot_count: .word 0                  ; @@WrittenBy apm_its_a_dot a0752 its_a_dot ReadBy apm_its_a_dot its_a_dot
@1042:000000          lcl_total_dots: .word 0                  ; @@WrittenBy a0735 a0762 ReadBy a0762 a1027
@1043:000000         lcl_cell_number: .word 0                  ; @@WrittenBy a0741 ReadBy a0743
@1044:000000          lcl_cell_state: .word 0                  ; @@WrittenBy a0754 ReadBy test_naught test_cross

                                      ; static addresses
@1045:000361             dot_fn_addr: .word draw_dot           ; @@ReadBy apm_test_dot test_dot
@1046:000403           cross_fn_addr: .word draw_cross         ; @@ReadBy a0666 a0772
@1047:000424          naught_fn_addr: .word draw_naught        ; @@ReadBy a0657 a0764


                                      ; This table gives the instructions for analyzing each horizontal, vertical
                                      ; or diagonal possible win combinations.
                analysis_table_start:
@1050:001051                          .word analysis_table     ; @@ReadBy a0730
                      analysis_table:
@1051:000000                     at0: .word 0                  ; start cell  ; horizontal cells
@1052:000003                          .word 1 * 3              ; increment
@1053:000003                     at1: .word 3                  ; start cell
@1054:000003                          .word 1 * 3              ; increment
@1055:000006                     at2: .word 6                  ; start cell
@1056:000003                          .word 1 * 3              ; increment
@1057:000000                     at3: .word 0                  ; start cell  ; vertical cells
@1060:000011                          .word 3 * 3              ; increment
@1061:000001                     at4: .word 1                  ; start cell
@1062:000011                          .word 3 * 3              ; increment
@1063:000002                     at5: .word 2                  ; start cell
@1064:000011                          .word 3 * 3              ; increment
@1065:000000                     at6: .word 0                  ; start cell  ; up-right diagonal
@1066:000014                          .word 4 * 3              ; increment
@1067:000002                     at7: .word 2                  ; start cell  ; up-left diagonal
@1070:000006                          .word 2 * 3              ; increment


                                      ; This table identifies a pre-computed machine response
                                      ; to each of the possible first player moves
                                      ; i.e., if the player puts a cross in cell zero, respond
                                      ; with a naught in cell 4.
                                      ; Cell numbers are multiplied by three so they can be used to
                                      ; directly index the game state table.
              first_move_table_start:
@1071:001072                          .word first_move_table   ; @@ReadBy a0617
                    first_move_table:
@1072:000014                          .word 4 * 3              ;  0
@1073:000000                          .word 0 * 3              ;  1
@1074:000014                          .word 4 * 3              ;  2
@1075:000000                          .word 0 * 3              ;  3
@1076:000000                          .word 0 * 3              ;  4
@1077:000006                          .word 2 * 3              ;  5
@1100:000014                          .word 4 * 3              ;  6
@1101:000003                          .word 1 * 3              ;  7
@1102:000014                          .word 4 * 3              ;  8


                                      ;;;;;;;;;;;;;;;;
                                      ; Set all the game board cells to "unplayed"
                                      ; Initialize the game state
                     init_game_board:
@1103:051125                          ta init_game_board_ret   ; @@JumpedToBy main a0512

@1104:100000                          ca zero                  ; Reset the Move Counter to Zero
@1105:040174                          ts move_number

@1106:100271                          ca gb_table_start        ; calculate the offset into the game state table for this cell
@1107:111131                          ad const_2               ; offset to third table entry
@1110:045114                          td igb_table_ts          ; store the pointer to the first entry

@1111:105136                          cs const_8               ; nine passes; var should be 8; loop count is negative
@1112:040201                          ts loop_count
@1113:101126                igb_loop: ca lcl_init_val          ; fetch the address to use for the initial function pointer for each cell @@JumpedToBy a1121
@1114:040000            igb_table_ts: ts 0                     ; set a table entry to the default pointer @@WrittenBy a1110 a1117 ReadBy a1115
@1115:101114                          ca igb_table_ts          ; advance the pointer to the next entry
@1116:111132                          ad const_3
@1117:041114                          ts igb_table_ts
@1120:130201                          ao loop_count
@1121:071113                          cp igb_loop              ; around the loop until we've hit all nine entries

@1122:100000                          ca const_0
@1123:040210                          ts which_player
@1124:041127                          ts g_game_over           ; clear the "game over" flag

                                      ;;;;;
                                      ; debug - pre-populate two moves
                                      ;            ca dct0  ; X icon
                                      ;            ts gb0_state
                                      ;            ca dct1  ; O icon
                                      ;            ts gb1_state
                                      ;            ca dct1  ; O icon
                                      ;            ts gb2_state
                                      ;            ca dct0  ; X icon
                                      ;            ts gb3_state
                                      ;            ca dct1  ; O icon
                                      ;            ts gb4_state
                                      ;            ca dct0  ; X icon
                                      ;            ts gb7_state

                                      ;;;;;;
                 init_game_board_ret:
@1125:074000                          sp 0                     ; @@WrittenBy a1103
@1126:000361            lcl_init_val: .word draw_dot           ; @@ReadBy igb_loop
@1127:000000             g_game_over: .word 0                  ; @@WrittenBy a0065 a1124 ReadBy a0047

                                      ; ****************************************


                                      ; Constants
@1130:177777                const_0n: .word 0o177777           ; @@ReadBy a0530
@1131:000002                 const_2: .word 2                  ; @@ReadBy a0070 a0074 a0105 a0111 a0551 a0572 a0637 itw_outer_loop a0745 a1107
@1132:000003                 const_3: .word 3                  ; @@ReadBy a0146 a0151 a0154 a0531 a1004 a1007 a1116
@1133:000004                 const_4: .word 4
@1134:000006                 const_6: .word 6                  ; @@ReadBy a0072 a0107
@1135:000007                 const_7: .word 7                  ; @@ReadBy a0161 a0505 a0726
@1136:000010                 const_8: .word 8                  ; @@ReadBy a0122 a0327 a0333 a0346 a0352 a0367 a0375 a0407 a0415 a0430 a0452 a0460 a0471 a0477 a0643 a1111
@1137:000011                 const_9: .word 9                  ; @@ReadBy a0436
@1140:000012                const_10: .word 10                 ; @@ReadBy a0101 a0116
@1141:000013                const_11: .word 11                 ; loop counter for 12 iterations @@ReadBy a0076 a0113
@1142:000014                const_12: .word 12
@1143:020000            const_2_cell: .word 8192               ; decimal value of screen coord corresponding to two cells in width @@ReadBy a0442

@1144:100002             const_x_win: .word 0o100002           ; two plus sign bit @@ReadBy cross_win
@1145:100003             const_o_win: .word 0o100003           ; two plus sign bit @@ReadBy naught_win
@1146:100004              const_draw: .word 0o100004           ; three plus sign bit @@ReadBy its_a_tie


                                      ; these two constants give the delta values to draw a "maximum short vector"
@1147:076000          horiz_line_seg: .word 0o174 * 0o400      ; +32 in the top half of the word
@1150:000174           vert_line_seg: .word 0o174              ; +32 in the bottom half of the word
@1151:076174       diag_up_right_seg: .word 0o174 * 0o400 + 0o174
@1152:100200        diag_dn_left_seg: .word 0o200 * 0o400 + 0o200
@1153:076200       diag_dn_right_seg: .word 0o174 * 0o400 + 0o200
@1154:100174        diag_up_left_seg: .word 0o200 * 0o400 + 0o174


                                      ; ---------------------------------------

                          panic_stop:
@1155:100000                          ca 0                     ; @@JumpedToBy a1431
                                      .print "panic stop"
@1156:000000                          si 0                     ; ; Auto-Annotate I/O: unknown i/o device


                                      ; ;these are the values to be placed in a cell on the board to show
                                      ; who's playing which position
                                      .pp XX, 1
                                      .pp Oh, 2
                                      .pp None, -1

                                      ; Constants
@1157:000002                     c_2: .word 2                  ; @@ReadBy a0625 a0712 a1404 a1406
@1160:177775                    c_2n: .word -2                 ; for a loop of three @@ReadBy a1347 a1365
@1161:000003                     c_3: .word 3                  ; @@ReadBy a1354 a1361 a2336 a2341 a2344
@1162:000004                     c_4: .word 4                  ; @@ReadBy a1377
@1163:177767                    c_8n: .word -8                 ; for a loop of nine passes @@ReadBy a1267 a1665 a1731 a2015
@1164:000012                    c_10: .word 10                 ; @@ReadBy a1416 a1420 a1632 a1642
@1165:001750                  c_1000: .word 1000               ; BigNum @@ReadBy a1661 a1725 a2011
@1166:000001                    c_XX: .word XX                 ; @@ReadBy apm_its_a_cross a0704
@1167:000002                    c_oh: .word Oh                 ; @@ReadBy apm_its_a_naught a0702

                                      ; Global Variables
                                      ;Default state to start the game: player = 'x', opponent = 'o';
@1170:000001                  player: .word XX                 ; @@WrittenBy a0703 ReadBy a1413 a1677 a2030
@1171:000002                opponent: .word Oh                 ; @@WrittenBy a0705 ReadBy a1743



                                      ;#define GAME1
                                      ;#ifdef GAME1
                                      ;    char board[3][3] =
                                      ;     {
                                      ;         { '_', 'o', 'x' },
                                      ;         { 'x', 'o', '_' },
                                      ;         { '_', '_', '_' }
                                      ;     };
                                      ; #endif
                                      ; #ifdef GAME2
                                      ;    // X should win this game in one move, but it will try every possible alternative before figuring it out
                                      ;    char board[3][3] =
                                      ;    {
                                      ;        { '_', 'o', 'x' },
                                      ;        { '_', 'o', 'x' },
                                      ;        { '_', '_', '_' }
                                      ;    };
                                      ; #endif


                                      ; pointers - yuck :-(  This cell points to the first of several board layouts
@1172:000011                BRD_SIZE: .word board3 - board2    ; nine words per each boar layouts
                                      ; BRDS_COUNT: .word -5    ; six test board layouts (so far!)
                                      ; BRDS_COUNT: .word (first_boardp - boardp) / (board3 - board2) + 1    ; six test board layouts (so far!)
@1173:000001              BRDS_COUNT: .word 1                  ; set the count to do just one board


                                      ; Board Layout
                                      ;   0  1  2
                                      ;   3  4  5
                                      ;   6  7  8

@1174:001175            first_boardp: .word board2

                                      ;        { 'x', 'o', 'o' },
                                      ;        { 'x', 'o', 'x' },
                                      ;        { '_', '_', '_' }
@1175:000001                  board2: .word XX                 ; 0
@1176:000002                          .word Oh
@1177:000002                          .word Oh
@1200:000001                          .word XX                 ; 3
@1201:000002                          .word Oh
@1202:000001                          .word XX
@1203:177776                          .word None               ; 6
@1204:177776                          .word None
@1205:177776                          .word None

                                      ; X plays next, but Oh wins in one move
                                      ;        { '_', 'o', 'o' },
                                      ;        { 'x', 'o', 'x' },
                                      ;        { '_', '_', '_' }
@1206:177776                  board3: .word None               ; 0
@1207:000002                          .word Oh
@1210:000002                          .word Oh
@1211:000001                          .word XX                 ; 3
@1212:000002                          .word Oh
@1213:000001                          .word XX
@1214:177776                          .word None               ; 6
@1215:177776                          .word None
@1216:177776                          .word None

                                      ; Test evaluate_board, Rows
                                      ; First row is Not a Win, second row should detect a win by X
                                      ;        { '_', 'o', 'o' },
                                      ;        { 'x', 'x', 'x' },
                                      ;        { 'o', '_', '_' }
                     board_row_x_win:
@1217:177776                          .word None               ; 0
@1220:000002                          .word Oh
@1221:000002                          .word Oh
@1222:000001                          .word XX                 ; 3
@1223:000001                          .word XX
@1224:000001                          .word XX
@1225:000002                          .word Oh                 ; 6
@1226:177776                          .word None
@1227:177776                          .word None

                                      ; Test evaluate_board, Cols
                                      ; First col is Not a Win, second col should detect a win by 0
                                      ;        { '_', 'o', 'x' },
                                      ;        { 'x', 'o', 'x' },
                                      ;        { 'o', 'o', '_' }
                     board_col_o_win:
@1230:177776                          .word None               ; 0
@1231:000002                          .word Oh
@1232:000001                          .word XX
@1233:000001                          .word XX                 ; 3
@1234:000002                          .word Oh
@1235:000001                          .word XX
@1236:000002                          .word Oh                 ; 6
@1237:000002                          .word Oh
@1240:177776                          .word None

                                      ; Test evaluate_board, 2-4-6 diagonal
                                      ;        { '_', 'o', 'x' },
                                      ;        { 'o', 'x', 'o' },
                                      ;        { 'x', 'o', '_' }
                board_2_4_6_diagonal:
@1241:177776                          .word None               ; 0
@1242:000002                          .word Oh
@1243:000001                          .word XX
@1244:000002                          .word Oh                 ; 3
@1245:000001                          .word XX
@1246:000002                          .word Oh
@1247:000001                          .word XX                 ; 6
@1250:000002                          .word Oh
@1251:177776                          .word None

                                      ; X plays next, and 'should' play cell 8
                                      ;        { 'o', 'x', '_' },
                                      ;        { '_', 'o', '_' },
                                      ;        { '_', '_', '_' }
@1252:000002                  board4: .word Oh                 ; 0
@1253:000001                          .word XX
@1254:177776                          .word None
@1255:177776                          .word None               ; 3
@1256:000002                          .word Oh
@1257:177776                          .word None
@1260:177776                          .word None               ; 6
@1261:177776                          .word None
@1262:177776                          .word None


@1263:001252                  boardp: .word board4             ; board2 to scan all the games @@ReadBy a0641 a1265 a1307 a1667 a1733 a2021

                                      ; // This function returns true if there are moves
                                      ; // remaining on the board. It returns false if
                                      ; // there are no moves left to play.
                                      ; bool isMovesLeft()
                                      ; {
                                      ;     for (int i = 0; i<3; i++)
                                      ;         for (int j = 0; j<3; j++)
                                      ;             if (board[i][j]=='_')
                                      ;                 return true;
                                      ;     //printf("IsMovesLeft --> false\n");
                                      ;     return false;
                                      ; }
                                      ; IsMovesLeft returns positive if there are more moves, negative if there
                                      ; are no empty cells
                         isMovesLeft:
@1264:051303                          ta isMovesLeftRet        ; @@JumpedToBy a1651
@1265:101263                          ca boardp
@1266:045271                          td iML_bptr              ; store a pointer to the start of the game board
@1267:101163                          ca c_8n
@1270:041304                          ts iML_cnt
@1271:100000                iML_bptr: ca 0                     ; read the cell under test; If the cell is empty, there are move moves, we can stop @@WrittenBy a1266 a1275 ReadBy a1275 JumpedToBy a1277
@1272:071302                          cp iML_empty             ; branch if the cell is empty, ie, neither X or O.

@1273:100001                          ca one                   ; non-empty cell; prepare to return positive
@1274:041305                          ts iML_ret
@1275:131271                          ao iML_bptr              ; update the pointer to the next cell
@1276:131304                  iML_lp: ao iML_cnt               ; increment the loop count
@1277:071271                          cp iML_bptr              ; branch if not done yet

@1300:104001                          cs one                   ; no empty cells; return -1
@1301:075303                          sp isMovesLeftRet

                           iML_empty:
@1302:100001                          ca one                   ; return One for more moves left @@JumpedToBy a1272

                      isMovesLeftRet:
@1303:074000                          sp 0                     ; @@WrittenBy a1264 JumpedToBy a1301

                                      ; local variables
@1304:000000                 iML_cnt: .word 0                  ; loop counter @@WrittenBy a1270 iML_lp ReadBy iML_lp
@1305:000000                 iML_ret: .word 0                  ; return code @@WrittenBy a1274


                                      ; Helper routine for Evaluate_Board
                                      ; Check three adjacent cells to determine if they have the same player identifier
                                      ; Return the negative of the value if it's the same, or +1 if different (or if all three are -1, unoccupied)
                                      ; The offset from the start of the table is in ACC, the stride is in the "local"
                                      ; variable equ3_arg_stride
                                      ; The return value in the AC is inverted to make the test one level up a step
                                      ; simpler...  -1 or -2 means the row contains all X's or O's, +1 means they're not all
                                      ; the same.  The caller can then branch on negative to determine if the search for
                                      ; a winner is complete.
                                equ3:
@1306:051337                          ta equ3_ret              ; @@JumpedToBy a1352 a1370 a1402 a1407
@1307:111263                          ad boardp                ; add base pointer to the board array to offset
@1310:045311                          td rd_brd1
@1311:100000                 rd_brd1: ca 0                     ; read the first element @@WrittenBy a1310 ReadBy a1314
@1312:071336                          cp equ3_ret_not_equal
@1313:041341                          ts equ3_lcl_first_read   ; remember what's in the first cell

@1314:101311                          ca rd_brd1               ; calculate address for second cell by adding stride
@1315:111340                          ad equ3_arg_stride
@1316:045317                          td rd_brd2
@1317:100000                 rd_brd2: ca 0                     ; read the second element @@WrittenBy a1316 ReadBy a1324
@1320:115341                          su equ3_lcl_first_read   ; compare it to the first element read
@1321:134000                          dm zero
@1322:071324                          cp equ3_brd3             ; negative zero means they're the same; so test the third cell
@1323:075336                          sp equ3_ret_not_equal    ; otherwise, bail out

                           equ3_brd3:
@1324:101317                          ca rd_brd2               ; @@JumpedToBy a1322
@1325:111340                          ad equ3_arg_stride
@1326:045327                          td rd_brd3
@1327:100000                 rd_brd3: ca 0                     ; @@WrittenBy a1326
@1330:115341                          su equ3_lcl_first_read
@1331:134000                          dm zero
@1332:071334                          cp equ3_ret_equal        ; negative zero means they're the same
@1333:075336                          sp equ3_ret_not_equal

                      equ3_ret_equal:
@1334:105341                          cs equ3_lcl_first_read   ; return negative one or two @@JumpedToBy a1332
@1335:075337                          sp equ3_ret

                  equ3_ret_not_equal:
@1336:100001                          ca one                   ; @@JumpedToBy a1312 a1323 a1333
                                      ; fall through to equ3_ret

                            equ3_ret:
@1337:074000                          sp 0                     ; @@WrittenBy a1306 JumpedToBy a1335
                                      ; local vars and arguments
                     equ3_arg_stride:
@1340:000000                          .word 0                  ; @@WrittenBy a1344 a1362 a1400 a1405 ReadBy a1315 a1325
                 equ3_lcl_first_read:
@1341:000000                          .word 0                  ; @@WrittenBy a1313 ReadBy a1320 a1330 a1334




                                      ; // This is the evaluation function as discussed
                                      ; // in the previous article ( http://goo.gl/sJgv68 )
                                      ; int evaluate() {

                                      ;     // Checking for Rows for X or O victory.
                                      ;     for (int row = 0; row<3; row++)
                                      ;     {
                                      ;         if (board[row][0]==board[row][1] &&   // stride = +1
                                      ;             board[row][1]==board[row][2])
                                      ;         {
                                      ;             if (board[row][0]==player)
                                      ;                 return +10;
                                      ;             else if (board[row][0]==opponent)
                                      ;                 return -10;
                                      ;         }
                                      ;     }

                                      ;     // Checking for Columns for X or O victory.
                                      ;     for (int col = 0; col<3; col++)
                                      ;     {
                                      ;         if (board[0][col]==board[1][col] &&  // stride = +3
                                      ;             board[1][col]==board[2][col])
                                      ;         {
                                      ;             if (board[0][col]==player)
                                      ;                 return +10;
                                      ;             else if (board[0][col]==opponent)
                                      ;                 return -10;
                                      ;         }
                                      ;     }

                                      ;     // Checking for Diagonals for X or O victory.
                                      ;     if (board[0][0]==board[1][1] && board[1][1]==board[2][2])  // stride = +4
                                      ;     {
                                      ;         if (board[0][0]==player)
                                      ;             return +10;
                                      ;         else if (board[0][0]==opponent)
                                      ;             return -10;
                                      ;     }

                                      ;     if (board[0][2]==board[1][1] && board[1][1]==board[2][0])   // stride = +2
                                      ;     {
                                      ;         if (board[0][2]==player)
                                      ;             return +10;
                                      ;         else if (board[0][2]==opponent)
                                      ;             return -10;
                                      ;     }

                                      ;     // Else if none of them have won then return 0
                                      ;     return 0;
                                      ; }

                                      ; Evaluate the current board for win, lose or incomplete
                                      ; If it's a Win for the Player, return +10; if it's a Lose for the Player, return -10
                                      ; If the game is undecided, return zero
                                      ; This routine takes no input arguments
                      evaluate_board:
@1342:051422                          ta eval_ret              ; @@JumpedToBy a1627
                        eval_chk_row:
                                      ; check rows for a win; stride of three, starting at zero
@1343:100001                          ca one
@1344:041340                          ts equ3_arg_stride       ; set the equ3 stride to one, i.e., three adjacent horizontal cells
@1345:100000                          ca zero                  ; set the equ3 starting cell to row zero
@1346:041423                          ts eval_lcl_nxt_cell
@1347:101160                          ca c_2n                  ; initialize loop counter; prepare to go around the loop three times
@1350:041424                          ts eval_lcl_loop_count
                       eval_row_loop:
@1351:101423                          ca eval_lcl_nxt_cell     ; place offset of first cell to check in AC @@JumpedToBy a1360
@1352:075306                          sp equ3                  ; check one row
@1353:071413                          cp eval_score_players    ; match -- figure out who won

                    eval_chk_nxt_row:
@1354:101161                          ca c_3                   ; next row is three cells forward
@1355:111423                          ad eval_lcl_nxt_cell     ; compute the first cell of the next row
@1356:041423                          ts eval_lcl_nxt_cell
@1357:131424                          ao eval_lcl_loop_count
@1360:071351                          cp eval_row_loop         ; branch if there's another row to check, fall through if we've checked three rows

                                      ; no one won on rows, so go on to check columns

                        eval_chk_col:
                                      ; check cols for a win; stride of three, starting at zero
@1361:101161                          ca c_3
@1362:041340                          ts equ3_arg_stride       ; set the equ3 stride to three, i.e., three adjacent vertical cells
@1363:100000                          ca zero                  ; set the equ3 starting cell to col zero
@1364:041423                          ts eval_lcl_nxt_cell
@1365:101160                          ca c_2n                  ; initialize loop counter; prepare to go around the loop three times
@1366:041424                          ts eval_lcl_loop_count
                       eval_col_loop:
@1367:101423                          ca eval_lcl_nxt_cell     ; place offset of first cell to check in AC @@JumpedToBy a1376
@1370:075306                          sp equ3                  ; check one row
@1371:071413                          cp eval_score_players    ; match -- figure out who won

                    eval_chk_nxt_col:
@1372:100001                          ca one                   ; next col is one cell forward
@1373:111423                          ad eval_lcl_nxt_cell     ; compute the first cell of the next row
@1374:041423                          ts eval_lcl_nxt_cell
@1375:131424                          ao eval_lcl_loop_count
@1376:071367                          cp eval_col_loop         ; branch if there's another row to check, fall through if we've checked three rows

                                      ; there are only two diagonals, no loops here; just test 0, 4, 8 then 2, 4, 6
                  eval_chk_diagonal0:
@1377:101162                          ca c_4
@1400:041340                          ts equ3_arg_stride       ; set the equ3 stride to four, i.e., 0, 4, 8 diagonal cells
@1401:100000                          ca zero                  ; set the equ3 starting cell to col zero
@1402:075306                          sp equ3                  ; check one row
@1403:071413                          cp eval_score_players    ; match -- figure out who won

                  eval_chk_diagonal1:
@1404:101157                          ca c_2
@1405:041340                          ts equ3_arg_stride       ; set the equ3 stride to two, i.e., 2, 4, 6 diagonal cells
@1406:101157                          ca c_2                   ; set the equ3 starting cell to cell 2
@1407:075306                          sp equ3                  ; check one row
@1410:071413                          cp eval_score_players    ; match -- figure out who won

                                      ; nobody won; return 0
@1411:100000                          ca zero
@1412:075422                          sp eval_ret

                                      ; somebody won; check if it's the Player or Opponent
                                      ; The winner cell is -1 or -2 in AC; convert that to a score (recall equ3 results are inverted)
                                      ; depending on whether who's Player and who's Opponent at the moment
                  eval_score_players:
@1413:111170                          ad player                ; test to see if the current Player is the one that was found to have three winning cells @@JumpedToBy a1353 a1371 a1403 a1410
@1414:134000                          dm zero
@1415:071420                          cp eval_player_win

                        eval_opp_win:
@1416:105164                          cs c_10                  ; score an opponent win as -10
@1417:075422                          sp eval_ret

                     eval_player_win:
@1420:101164                          ca c_10                  ; score a Player win as +10 @@JumpedToBy a1415
@1421:075422                          sp eval_ret

                            eval_ret:
                                      ; .print "  Evaluate_Score returns %ad"
@1422:074000                          sp 0                     ; @@WrittenBy a1342 JumpedToBy a1412 a1417 a1421
                   eval_lcl_nxt_cell:
@1423:000000                          .word 0                  ; @@WrittenBy a1346 a1356 a1364 a1374 ReadBy a1351 a1355 a1367 a1373
                 eval_lcl_loop_count:
@1424:000000                          .word 0                  ; @@WrittenBy a1350 a1357 a1366 a1375 ReadBy a1357 a1375


                                      ; ================  MINIMAX Section =====================

                                      ; Two helper functions to save state for recursive calls
                                      ; to "push" onto the stack, we copy all the local minimax variables to
                                      ; where ever the stack pointer is pointing, then increment the stack
                                      ; pointer by the size of the frame
                         push_minmax:
@1425:051454                          ta push_ret              ; @@JumpedToBy a1625
@1426:041505                          ts push_pop_lcl_acc_stash; stash the AC
@1427:101511                          ca stack_size
@1430:115504                          su push_lcl_depth        ; test to be sure we're not running over the allocated space
@1431:071155                          cp panic_stop            ; branch if overflow

@1432:105507                          cs frame_size
@1433:110001                          ad one
@1434:041506                          ts push_pop_word_count   ; initialize the loop counter
@1435:101510                          ca minimax_retp          ; fetch the "source pointer"
@1436:045441                          td push_src
@1437:101512                          ca stackp                ; fetch the "destination pointer"
@1440:045442                          td push_dst

                            push_src:                          ; copy loop
@1441:100000                          ca 0                     ; filled in above @@WrittenBy a1436 a1443 ReadBy a1443 JumpedToBy a1446
                            push_dst:
@1442:040000                          ts 0                     ; @@WrittenBy a1440 a1444 ReadBy a1444
@1443:131441                          ao push_src
@1444:131442                          ao push_dst
@1445:131506                          ao push_pop_word_count
@1446:071441                          cp push_src              ; around the loop until the entire stack frame is copied

@1447:101512                          ca stackp                ; update the stack pointer for next time
@1450:111507                          ad frame_size
@1451:045512                          td stackp
@1452:131504                          ao push_lcl_depth

@1453:101505                          ca push_pop_lcl_acc_stash; retrieve the AC
                            push_ret:
@1454:074000                          sp 0                     ; subroutine return @@WrittenBy a1425


                          pop_minmax:
@1455:051503                          ta pop_ret               ; @@JumpedToBy a1773
@1456:041505                          ts push_pop_lcl_acc_stash; stash the AC
@1457:101512                          ca stackp                ; back up the stack pointer
@1460:115507                          su frame_size
@1461:045512                          td stackp
@1462:101504                          ca push_lcl_depth
@1463:114001                          su one
@1464:041504                          ts push_lcl_depth

@1465:105507                          cs frame_size
@1466:110001                          ad one
@1467:041506                          ts push_pop_word_count   ; initialize the loop counter
@1470:101510                          ca minimax_retp          ; fetch the "destination pointer"
@1471:045475                          td pop_dst
@1472:101512                          ca stackp                ; fetch the "source pointer"
@1473:045474                          td pop_src

                             pop_src:                          ; copy loop
@1474:100000                          ca 0                     ; filled in above @@WrittenBy a1473 a1476 ReadBy a1476 JumpedToBy a1501
                             pop_dst:
@1475:040000                          ts 0                     ; @@WrittenBy a1471 a1477 ReadBy a1477
@1476:131474                          ao pop_src
@1477:131475                          ao pop_dst
@1500:131506                          ao push_pop_word_count
@1501:071474                          cp pop_src               ; around the loop until the entire stack frame is copied

@1502:101505                          ca push_pop_lcl_acc_stash; retrieve the AC
                             pop_ret:
@1503:074000                          sp 0                     ; @@WrittenBy a1455

                      push_lcl_depth:
@1504:000000                          .word 0                  ; @@WrittenBy a1452 a1464 ReadBy a1430 a1452 a1462
              push_pop_lcl_acc_stash:
@1505:000000                          .word 0                  ; @@WrittenBy a1426 a1456 ReadBy a1453 a1502
                 push_pop_word_count:                          ; this var is the copy-word counter for push and pop
@1506:000000                          .word 0                  ; @@WrittenBy a1434 a1445 a1467 a1500 ReadBy a1445 a1500

                                      ; calculate the size of a single push on the stack
@1507:000007              frame_size: .word minmax_lcl_data_end - minmax_ret; @@ReadBy a1432 a1450 a1460 a1465
                        minimax_retp:                          ; Here's the address of the minimax local data to be pushed onto stack
@1510:001774                          .word minmax_ret         ; @@ReadBy a1435 a1470
                          stack_size:
@1511:000012                          .word 10                 ; I've allocated ten frames below for use of the stack @@ReadBy a1427


@1512:001513                  stackp: .word stack0             ; @@WrittenBy a1451 a1461 ReadBy a1437 a1447 a1457 a1472
@1513:000000                  stack0: .word 0                  ; frame 0
@1514:000000                          .word 0
@1515:000000                          .word 0
@1516:000000                          .word 0
@1517:000000                          .word 0
@1520:000000                          .word 0
@1521:000000                          .word 0
@1522:000000                          .word 0                  ; frame 1
@1523:000000                          .word 0
@1524:000000                          .word 0
@1525:000000                          .word 0
@1526:000000                          .word 0
@1527:000000                          .word 0
@1530:000000                          .word 0
@1531:000000                          .word 0                  ; frame 2
@1532:000000                          .word 0
@1533:000000                          .word 0
@1534:000000                          .word 0
@1535:000000                          .word 0
@1536:000000                          .word 0
@1537:000000                          .word 0
@1540:000000                          .word 0                  ; frame 3
@1541:000000                          .word 0
@1542:000000                          .word 0
@1543:000000                          .word 0
@1544:000000                          .word 0
@1545:000000                          .word 0
@1546:000000                          .word 0
@1547:000000                          .word 0                  ; frame 4
@1550:000000                          .word 0
@1551:000000                          .word 0
@1552:000000                          .word 0
@1553:000000                          .word 0
@1554:000000                          .word 0
@1555:000000                          .word 0
@1556:000000                          .word 0                  ; frame 5
@1557:000000                          .word 0
@1560:000000                          .word 0
@1561:000000                          .word 0
@1562:000000                          .word 0
@1563:000000                          .word 0
@1564:000000                          .word 0
@1565:000000                          .word 0                  ; frame 6
@1566:000000                          .word 0
@1567:000000                          .word 0
@1570:000000                          .word 0
@1571:000000                          .word 0
@1572:000000                          .word 0
@1573:000000                          .word 0
@1574:000000                          .word 0                  ; frame 7
@1575:000000                          .word 0
@1576:000000                          .word 0
@1577:000000                          .word 0
@1600:000000                          .word 0
@1601:000000                          .word 0
@1602:000000                          .word 0
@1603:000000                          .word 0                  ; frame 8
@1604:000000                          .word 0
@1605:000000                          .word 0
@1606:000000                          .word 0
@1607:000000                          .word 0
@1610:000000                          .word 0
@1611:000000                          .word 0
@1612:000000                          .word 0                  ; frame 9
@1613:000000                          .word 0
@1614:000000                          .word 0
@1615:000000                          .word 0
@1616:000000                          .word 0
@1617:000000                          .word 0
@1620:000000                          .word 0
@1621:000000                     eos: .word 0                  ; end of stack
@1622:001621              stack_endp: .word eos




                                      ; // This is the minimax function. It considers all
                                      ; // the possible ways the game can go and returns
                                      ; // the value of the board
                                      ; int minimax(int depth, bool isMax)
                                      ; {
                                      ;     int score = evaluate(board);
                                      ;     int m;
                                      ;     int best;

                                      ;     ; printf("%sMinimax Start\n", indent[depth+1]);
                                      ;     // If Maximizer has won the game return his/her
                                      ;     // evaluated score
                                      ;     if (score == 10) {
                                      ;         return score;
                                      ;         ; printf("%sMaximizer wins\n", indent[depth+1]);
                                      ;     }

                                      ;     // If Minimizer has won the game return his/her
                                      ;     // evaluated score
                                      ;     if (score == -10) {
                                      ;         ; printf("%sMinimizer Wins\n", indent[depth+1]);
                                      ;         return score;
                                      ;     }

                                      ;     // If there are no more moves and no winner then
                                      ;     // it is a tie
                                      ;     if (isMovesLeft(board)==false) {
                                      ;         ; printf("%sMinimax: No More Moves\n", indent[depth+1] );
                                      ;         return 0;
                                      ;     }

                                      ;     // If this maximizer's move
                                      ;     if (isMax)
                                      ;     {
                                      ;         best = -1000;

                                      ;         // Traverse all cells
                                      ;         for (int i = 0; i<3; i++)
                                      ;         {
                                      ;             for (int j = 0; j<3; j++)
                                      ;            {
                                      ;                // Check if cell is empty
                                      ;                if (board[i][j]=='_')
                                      ;                {
                                      ;                    // Make the move
                                      ;                    board[i][j] = player;

                                      ;                    // Call minimax recursively and choose
                                      ;                    // the maximum value
                                      ;                    //best = max( best,
                                      ;                    //    minimax(board, depth+1, !isMax) );
                                      ;                    m = minimax(depth+1, !isMax);
                                      ;                    //added by guy:
                                      ;                    m -= depth;
                                      ;                    ; printf("%sminimax isMAX=%d returned score %d  ", indent[depth+1], isMax, m);
                                      ;                    if (m > best) {
                                      ;                        best = m;
                                      ;                        ; printf("%sBest Higher\n", indent[depth+1]);
                                      ;                    } else {
                                      ;                        ; printf("\n");
                                      ;                    }
                                      ;                    ; print_board(depth);

                                      ;                    // Undo the move
                                      ;                    board[i][j] = '_';
                                      ;                }
                                      ;            }
                                      ;         }
                                      ;         return best;
                                      ;     }

                                      ;     // If this minimizer's move
                                      ;     else
                                      ;     {
                                      ;         best = 1000;

                                      ;         // Traverse all cells
                                      ;         for (int i = 0; i<3; i++)
                                      ;         {
                                      ;             for (int j = 0; j<3; j++)
                                      ;             {
                                      ;                 // Check if cell is empty
                                      ;                 if (board[i][j]=='_')
                                      ;                 {
                                      ;                     // Make the move
                                      ;                     board[i][j] = opponent;

                                      ;                     // Call minimax recursively and choose
                                      ;                     // the minimum value
                                      ;                     // best = min(best,
                                      ;                     //       minimax(depth+1, !isMax));
                                      ;                     m = minimax(depth+1, !isMax);
                                      ;                     ; for (int s = 0; s < depth; s++) printf("  ");
                                      ;                    //added by guy:
                                      ;                     m += depth;
                                      ;                     ; printf("    minimax isMAX=%d returned score %d  ", isMax, m);
                                      ;                      if (m < best) {
                                      ;                         best = m;
                                      ;                         ; printf("Best Lower\n");
                                      ;                     } else {
                                      ;                         ; printf("\n");
                                      ;                     }
                                      ;                     ; print_board(depth);

                                      ;                     // Undo the move
                                      ;                     board[i][j] = '_';
                                      ;                 }
                                      ;             }
                                      ;         }
                                      ;         return best;
                                      ;     }
                                      ; }


                                      ; This is the recursive module that tries all the combinations to find the
                                      ; best move.
                                      ; The routine takes one arg to say if we're trying to do Max or Min; Max is +1
                                      ; Min is -1, passed in AC
                             minimax:
@1623:051774                          ta minmax_ret            ; @@JumpedToBy a1705 a1747 a2034
@1624:041775                          ts minmax_lcl_isMax
@1625:075425                          sp push_minmax           ; store state on "the stack"
                                      ; .exec print_indent(cm, "Starting minimax: IsMax:%d, player: %d opponent %d, depth: %d" % (cm.rd(rl("minmax_lcl_isMax")), cm.rd(rl("player")), cm.rd(rl("opponent")), cm.rd(rl("push_lcl_depth"))), rl("push_lcl_depth"))
@1626:030000                          sd zero                  ; no-op
                                      ; .exec print_board(cm, rl("boardp"), rl("push_lcl_depth"), rl("player"), "Starting Minimax")
@1627:075342                          sp evaluate_board        ; figure out how we're doing
@1630:041776                          ts minmax_lcl_score

                     minmax_test_max:                          ; test if Maximizer has won
@1631:101776                          ca minmax_lcl_score
@1632:115164                          su c_10
@1633:134000                          dm 0                     ; test to see if score is +10
@1634:071636                          cp minmax_max_won        ; branch if yes
@1635:075641                          sp minmax_test_min

                      minmax_max_won:
                                      ; .print "Maximizer Won, score %d", minmax_lcl_score
@1636:101776                          ca minmax_lcl_score      ; @@JumpedToBy a1634
@1637:042001                          ts minmax_lcl_best       ; set up the return code
@1640:075770                          sp minmax_exit           ; all done

                     minmax_test_min:
@1641:101776                          ca minmax_lcl_score      ; @@JumpedToBy a1635
@1642:111164                          ad c_10
@1643:134000                          dm 0                     ; test to see if score is -10
@1644:071646                          cp minmax_min_won        ; branch if yes
@1645:075651                          sp minmax_test_tie

                      minmax_min_won:
                                      ; .print "Minimizer Won, score %d", minmax_lcl_score
@1646:101776                          ca minmax_lcl_score      ; @@JumpedToBy a1644
@1647:042001                          ts minmax_lcl_best       ; set up the return code
@1650:075770                          sp minmax_exit           ; all done

                     minmax_test_tie:
@1651:075264                          sp isMovesLeft           ; test if there are more moves to go @@JumpedToBy a1645
                                      ;.print "minmax_test_tie: isMovesLeft = %ad"
@1652:071654                          cp minmax_tie            ; Negative means "no more empty cells"
@1653:075657                          sp minmax_prepare_scan

                          minmax_tie:
@1654:100000                          ca zero                  ; @@JumpedToBy a1652
                                      ;.print "Minimax Tie"
@1655:042001                          ts minmax_lcl_best       ; set up the return code
@1656:075770                          sp minmax_exit           ; bail out

                 minmax_prepare_scan:
@1657:101775                          ca minmax_lcl_isMax      ; @@JumpedToBy a1653
@1660:071725                          cp minmax_not_isMax      ; branch if isMax == False

                                      ; ======== This section is "isMax == True" =============
                        minmax_isMax:
@1661:105165                          cs c_1000
@1662:042001                          ts minmax_lcl_best       ; initialize to Most Negative
@1663:100000                          ca zero                  ; prepare to scan all cells starting w/zero
@1664:041777                          ts minmax_lcl_next_cell
@1665:101163                          ca c_8n                  ; loop nine times
@1666:042000                          ts minmax_lcl_loop_cnt
                        minmax_loop1:
@1667:101263                          ca boardp                ; get the base board ptr to read the next cell @@JumpedToBy a1722
@1670:111777                          ad minmax_lcl_next_cell
@1671:045674                          td minmax_rd1
@1672:045700                          td minmax_wr1
@1673:046002                          td minmax_lcl_undo_move  ; this is only used _after_ the recursive call, and will need to be restored from stack
                          minmax_rd1:
@1674:100000                          ca 0                     ; fetch the next cell @@WrittenBy a1671
@1675:071677                          cp minmax_empty_cell1    ; continue if the cell is empty
@1676:075720                          sp minmax_loop1_end      ; go to the next loop step if the cell is not empty

                  minmax_empty_cell1:                          ; here, we know the cell we tested is empty, and a candidate for analysis
@1677:101170                          ca player                ; fetch the Player marker @@JumpedToBy a1675
                          minmax_wr1:
@1700:040000                          ts 0                     ; ... and write it into the cell @@WrittenBy a1672
                                      .exec print_experiment(cm, cb, "Trying  game piece %d to cell %d, count %d, isMax==True", ("player", "minmax_lcl_next_cell", "minmax_lcl_loop_cnt"), "push_lcl_depth")
@1701:030000                          sd zero                  ; no-op

@1702:104000                          cs zero                  ; load negative zero, i.e. all ones
@1703:031775                          sd minmax_lcl_isMax      ; Sum Digits, i.e., xor, will reverse isMax
@1704:104001                          cs one                   ; load -1 to signal isMax should be False
                                      ; here begins the recursion
                                      ; .exec print_indent(cm, "starting recursive call to minimax: isMax==True-branch, cell at %d, depth: %d, loop_count: %d" % (cm.rd(rl("minmax_lcl_next_cell")), cm.rd(rl("push_lcl_depth")), cm.rd(rl("minmax_lcl_loop_cnt"))), rl("push_lcl_depth"))
@1705:075623                          sp minimax
                                      ; the following adjustment probably shouldn't be done if the answer is Zero
@1706:114001                          su one                   ; push_lcl_depth       ; reduce the score by the calling depth
@1707:042004                          ts mm_lcl_ret_val        ; very local storage for the minimax return call
                                      ; .exec print_indent(cm, "finished recursive call to minimax: isMax==True-branch, cell at %d, depth: %d, loop_count: %d, score: 0o%o" % (cm.rd(rl("minmax_lcl_next_cell")), cm.rd(rl("push_lcl_depth")), cm.rd(rl("minmax_lcl_loop_cnt")), cm.rd(rl("mm_lcl_ret_val"))), rl("push_lcl_depth"))
@1710:116001                          su minmax_lcl_best       ; determine if this was the "best" score so far
@1711:071714                          cp minmax_not_best0      ; branch if we've seen a better score already

@1712:102004                          ca mm_lcl_ret_val        ; save this result as the Best Score So Far
@1713:042001                          ts minmax_lcl_best

                    minmax_not_best0:
@1714:102002                          ca minmax_lcl_undo_move  ; remember that modified instruction addresses are effectively local variables, so restore this one from the stack @@JumpedToBy a1711
                                      ;.exec print_experiment(cm, cb, "Undoing game piece %d in cell %d at 0o%o, isMax==True", ("player", "minmax_lcl_next_cell", "minmax_lcl_undo_move"), "push_lcl_depth")
@1715:045717                          td minmax_undo_move0
@1716:104001                          cs one                   ; undo the trial move
                   minmax_undo_move0:
@1717:040000                          ts 0                     ; @@WrittenBy a1715

                    minmax_loop1_end:                          ; get ready for the next cell iteration
@1720:131777                          ao minmax_lcl_next_cell  ; @@JumpedToBy a1676
@1721:132000                          ao minmax_lcl_loop_cnt
                                      ; .print "decrement loop count to %ad, depth: %d, isMax==True-branch", push_lcl_depth
@1722:071667                          cp minmax_loop1          ; go around again if the loop cnt is not exhausted

@1723:102001                          ca minmax_lcl_best       ; return the best score found in AC
@1724:075770                          sp minmax_exit           ; all done with this pass of isMax == True



                                      ; ======== This section is "isMax == False" =============
                    minmax_not_isMax:
@1725:101165                          ca c_1000                ; @@JumpedToBy a1660
@1726:042001                          ts minmax_lcl_best       ; initialize to Most Positive
@1727:100000                          ca zero                  ; prepare to scan all cells starting w/zero
@1730:041777                          ts minmax_lcl_next_cell
@1731:101163                          ca c_8n                  ; loop nine times
@1732:042000                          ts minmax_lcl_loop_cnt
                        minmax_loop2:
@1733:101263                          ca boardp                ; get the base board ptr to read the next cell @@JumpedToBy a1765
@1734:111777                          ad minmax_lcl_next_cell
@1735:045740                          td minmax_rd2
@1736:045744                          td minmax_wr2
@1737:046002                          td minmax_lcl_undo_move  ; store this address on the 'stack' for now
                          minmax_rd2:
@1740:100000                          ca 0                     ; fetch the next cell @@WrittenBy a1735
@1741:071743                          cp minmax_empty_cell2    ; continue if the cell is empty
@1742:075763                          sp minmax_loop2_end      ; go to the next loop step if the cell is not empty

                  minmax_empty_cell2:                          ; here, we know the cell we tested is empty, and a candidate for analysis
@1743:101171                          ca opponent              ; fetch the Opponent marker @@JumpedToBy a1741
                          minmax_wr2:
@1744:040000                          ts 0                     ; ... and write it into the cell @@WrittenBy a1736
                                      ; .exec print_experiment(cm, cb, "Trying  game piece %d in cell %d, count %d, isMax==False", ("opponent", "minmax_lcl_next_cell", "minmax_lcl_loop_cnt"), "push_lcl_depth")
@1745:030000                          sd zero                  ; no-op
                                      ;        cs zero                 ; load negative zero, i.e. all ones
                                      ;        sd minmax_lcl_isMax     ; Sum Digits, i.e., xor, will reverse isMax
@1746:100001                          ca one                   ; load -1 to signal isMax should be True
                                      ; here begins the recursion
                                      ; .exec print_indent(cm, "starting recursive call to minimax: isMax==False-branch, cell at %d, depth: %d, loop_count: %d" % (cm.rd(rl("minmax_lcl_next_cell")), cm.rd(rl("push_lcl_depth")), cm.rd(rl("minmax_lcl_loop_cnt"))), rl("push_lcl_depth"))
@1747:075623                          sp minimax
                                      ; the following adjustment probably shouldn't be done if the answer is Zero
@1750:110001                          ad one                   ;  push_lcl_depth       ; increase the (negative) score by the calling depth
@1751:042004                          ts mm_lcl_ret_val        ; very local storage for the minimax return value
                                      ; .exec print_indent(cm, "finished recursive call to minimax: isMax==False-branch, cell at %d, depth: %d, loop_count: %d, score: 0o%o" % (cm.rd(rl("minmax_lcl_next_cell")), cm.rd(rl("push_lcl_depth")), cm.rd(rl("minmax_lcl_loop_cnt")), cm.rd(rl("mm_lcl_ret_val"))), rl("push_lcl_depth"))


@1752:116001                          su minmax_lcl_best       ; determine if this was the "best" score so far
@1753:071755                          cp minmax_best2
@1754:075757                          sp minmax_not_best2      ; branch if we've seen a better score already

                        minmax_best2:
@1755:102004                          ca mm_lcl_ret_val        ; save this result as the Best Score So Far @@JumpedToBy a1753
@1756:042001                          ts minmax_lcl_best

                    minmax_not_best2:

@1757:102002                          ca minmax_lcl_undo_move  ; remember that modified instruction addresses are effectively local variables, so restore this one from the stack @@JumpedToBy a1754
                                      ; .exec print_experiment(cm, cb, "Undoing game piece %d in cell %d at 0o%o, isMax==False", ("player", "minmax_lcl_next_cell", "minmax_lcl_undo_move"), "push_lcl_depth")
@1760:045762                          td minmax_undo_move2
@1761:104001                          cs one                   ; undo the trial move
                   minmax_undo_move2:
@1762:040000                          ts 0                     ; @@WrittenBy a1760

                    minmax_loop2_end:                          ; get ready for the next cell iteration
@1763:131777                          ao minmax_lcl_next_cell  ; @@JumpedToBy a1742
@1764:132000                          ao minmax_lcl_loop_cnt
@1765:071733                          cp minmax_loop2          ; go around again if the loop cnt is not exhausted

@1766:102001                          ca minmax_lcl_best       ; return the best score found in AC
@1767:075770                          sp minmax_exit           ; all done with this pass of isMax == False


                         minmax_exit:
@1770:030000                          sd zero                  ; no-op for .exec @@JumpedToBy a1640 a1650 a1656 a1724 a1767
                                      ; .exec print_indent(cm, "Exiting minimax: IsMax:%d, depth: %d, score: %d" % (cm.rd(rl("minmax_lcl_isMax")), cm.rd(rl("push_lcl_depth")), cm.rd(rl("minmax_lcl_best"))), rl("push_lcl_depth"))
@1771:030000                          sd zero                  ; this is a no-op
                                      ; .exec print_board(cm, rl("boardp"), rl("push_lcl_depth"), rl("player") )
@1772:102001                          ca minmax_lcl_best

                                      ; note that we stash and retrieve the AC during PoP
@1773:075455                          sp pop_minmax
                          minmax_ret:
@1774:074000                          sp 0                     ; @@WrittenBy a1623

                                      ; the 'local data' for minmax must be copied/retrieved from the "stack" for recursion
                                      ; a "stack frame" must store from minmax_ret to minmax_lcl_data_end
@1775:000000        minmax_lcl_isMax: .word 0                  ; @@WrittenBy a1624 ReadBy a1657 a1703
@1776:000000        minmax_lcl_score: .word 0                  ; @@WrittenBy a1630 ReadBy a1631 a1636 a1641 a1646
@1777:000000    minmax_lcl_next_cell: .word 0                  ; @@WrittenBy a1664 a1720 a1730 a1763 ReadBy a1670 a1720 a1734 a1763
@2000:000000     minmax_lcl_loop_cnt: .word 0                  ; @@WrittenBy a1666 a1721 a1732 a1764 ReadBy a1721 a1764
@2001:000000         minmax_lcl_best: .word 0                  ; @@WrittenBy a1637 a1647 a1655 a1662 a1713 a1726 a1756 ReadBy a1710 a1723 a1752 a1766 a1772
@2002:000000    minmax_lcl_undo_move: .word 0                  ; @@WrittenBy a1673 a1737 ReadBy a1714 a1757
@2003:000000     minmax_lcl_data_end: .word 0                  ; this is just a marker for the end of data to be pushed

@2004:000000          mm_lcl_ret_val: .word 0                  ; @@WrittenBy a1707 a1751 ReadBy a1712 a1755



                                      ; // This will return the best possible move for the player
                                      ; // This routine used to return row and move with a single pointer to a struct.
                                      ; // Not a WW Kind of Thing, so I changed it to return two ints via args
                                      ; // struct Move findBestMove)
                                      ; void findBestMove(int *move_row, int *move_col)
                                      ; {
                                      ;     int bestVal = -1000;
                                      ;     int bestMove_row = -1;
                                      ;     int bestMove_col = -1;

                                      ;     // Traverse all cells, evaluate minimax function for
                                      ;     // all empty cells. And return the cell with optimal
                                      ;     // value.
                                      ;     for (int i = 0; i<3; i++)
                                      ;     {
                                      ;         for (int j = 0; j<3; j++)
                                      ;         {
                                      ;             // Check if cell is empty
                                      ;             if (board[i][j]=='_')
                                      ;             {
                                      ;                 // Make the move
                                      ;                 board[i][j] = player;

                                      ;                 // compute evaluation function for this
                                      ;                 // move.
                                      ;                 int moveVal = minimax(0, false);

                                      ;                 // Undo the move
                                      ;                 board[i][j] = '_';

                                      ;                 // If the value of the current move is
                                      ;                 // more than the best value, then update
                                      ;                 // best/
                                      ;                 printf("minimax returned %d  ", moveVal);
                                      ;                 if (moveVal > bestVal)
                                      ;                 {
                                      ;                     bestMove_row = i;
                                      ;                     bestMove_col = j;
                                      ;                     bestVal = moveVal;
                                      ;                     printf("Best\n");
                                      ;                 }
                                      ;                 else {
                                      ;                     printf("\n");
                                      ;                 }
                                      ;             }
                                      ;         }
                                      ;     }

                                      ;     printf("The value of the best Move for Player %c is : %d\n",
                                      ;             player, bestVal);

                                      ;     *move_row = bestMove_row;
                                      ;     *move_col = bestMove_col;
                                      ;     // return // bestMove;
                                      ; }


                                      ; findBestMove cycles through the board to find the move that results
                                      ; in the best score for the current Player
                                      ; The routine takes no explicit argument, but assumes that Player is the
                                      ; one we're trying to advance
                                      ; the assumption on calling this routine is that there's at least one move available to be tried
                                      ; This routine can take a while, so it redraws the screen a couple of times.  To indicate who'S
                                      ; doing what, we reverse the "player" bit temporarily.
                        findBestMove:
@2005:052061                          ta fBM_ret               ; @@JumpedToBy a0706

                                      ; switch the display to the machine player
@2006:100210                          ca which_player
@2007:030001                          sd const_1               ; xor a 1 into the LSB; i.e. 0->1 or 1->0
@2010:040210                          ts which_player

                                      ; initialize the 'best stuff' detector
@2011:105165                          cs c_1000
@2012:042062                          ts fBM_lcl_best_value
                                      ; .print "Starting findBestMove, player=%d, opponent=%d", player, opponent
@2013:104001                          cs one
@2014:042063                          ts fBM_lcl_best_move
@2015:101163                          ca c_8n
@2016:042064                          ts fBM_lcl_loop_count
@2017:100000                          ca zero
@2020:042065                          ts fBM_lcl_current_cell
@2021:101263                          ca boardp                ; we always start from cell zero`
@2022:046025                          td fBM_fetch_cell
@2023:046031                          td fBM_set_cell
@2024:046037                          td fBM_clear_cell

                                      ; we start the loop here, but the first test will bypass the rest of the loop if the cell is already spoken for
                      fBM_fetch_cell:
@2025:100000                          ca 0                     ; read the current cell into AC @@WrittenBy a2022 a2047 ReadBy a2047 JumpedToBy a2054
@2026:072030                          cp fBM_try_move          ; if the cell is empty, go on to try out a move
@2027:076047                          sp fBM_next_loop         ; take a pass on this non-empty cell, go on to the next one

                        fBM_try_move:
@2030:101170                          ca player                ; @@JumpedToBy a2026
                                      ; try out a move on this cell
                                      .print "fBM: try  empty cell %d, player=%d", fBM_lcl_current_cell, player
                        fBM_set_cell:
@2031:040000                          ts 0                     ; @@WrittenBy a2023 a2050 ReadBy a2050
@2032:074067                          sp draw_game_board       ; be careful to not trigger unintended recursion...

@2033:104001                          cs one                   ; tell Minimax to try for a Min score on this cell
                                      ; .print "fBM: call minimax, player=%d, IsMax=%ad", player
@2034:075623                          sp minimax               ; call the optimizer; best-score comes back in AC
                                      ;.print "fBM: minimax returned %ad"
@2035:042066                          ts fBM_lcl_tmp_score     ; stash the score for now

@2036:104001                          cs one                   ; undo the trial move, then evaluate the results of minimax
                      fBM_clear_cell:
@2037:040000                          ts 0                     ; @@WrittenBy a2024 a2051 ReadBy a2051

                                      ; see if we bested a previous score
@2040:102066                          ca fBM_lcl_tmp_score     ; compare the new result with previous best
@2041:116062                          su fBM_lcl_best_value    ; branch if the old one was better; i.e., skip updating the eval_score_players
@2042:072047                          cp fBM_next_loop

@2043:102066                          ca fBM_lcl_tmp_score
@2044:042062                          ts fBM_lcl_best_value    ; save the New Best Score
@2045:102065                          ca fBM_lcl_current_cell  ; and remember how we got here, i.e., which cell we tried
                                      .print "fBM new Best Move: score %d, cell %d, loop: %d", fBM_lcl_tmp_score, fBM_lcl_current_cell, fBM_lcl_loop_count
@2046:042063                          ts fBM_lcl_best_move

                       fBM_next_loop:
@2047:132025                          ao fBM_fetch_cell        ; @@JumpedToBy a2027 a2042
@2050:132031                          ao fBM_set_cell
@2051:132037                          ao fBM_clear_cell
@2052:132065                          ao fBM_lcl_current_cell
@2053:132064                          ao fBM_lcl_loop_count
@2054:072025                          cp fBM_fetch_cell        ; go 'round the loop again

                                      ; now switch the display back to the original (human) player
@2055:100210                          ca which_player
@2056:030001                          sd const_1               ; xor a 1 into the LSB; i.e. 0->1 or 1->0
@2057:040210                          ts which_player

                                      ; when we're done with the loop, return the best move found (not the score, the cell that played best)
@2060:102063                          ca fBM_lcl_best_move
                                      .print "fBM findBestMove for player %d returns move to cell %ad, score=%d", player, fBM_lcl_best_value
                             fBM_ret:
@2061:074000                          sp 0                     ; @@WrittenBy a2005
                  fBM_lcl_best_value:                          ; best score found so far
@2062:000000                          .word 0                  ; @@WrittenBy a2012 a2044 ReadBy a2041
                   fBM_lcl_best_move:                          ; remember the move that resulted in the best score
@2063:000000                          .word 0                  ; @@WrittenBy a2014 a2046 ReadBy a2060
                  fBM_lcl_loop_count:
@2064:000000                          .word 0                  ; @@WrittenBy a2016 a2053 ReadBy a2053
                fBM_lcl_current_cell:
@2065:000000                          .word 0                  ; @@WrittenBy a2020 a2052 ReadBy a2045 a2052
                   fBM_lcl_tmp_score:
@2066:000000                          .word 0                  ; @@WrittenBy a2035 ReadBy a2040 a2043


                                      ;=====================================================================================

                                      ; /* 16-segment character generator, originally in Core Memory Clock
                                      ;  *
                                      ;  * Guy Fedorkow, Feb 22, 2025
                                      ;  *  originally for Arduino Mega
                                      ;  *
                                      ;  */



                      unit_test_main:
@2067:104044                          cs c_scope_edge          ; @@JumpedToBy a2074
@2070:042123                          ts ds_argx
@2071:042124                          ts ds_argy
@2072:102075                          ca msgp
@2073:076077                          sp draw_str
                                      ;si 0
@2074:076067                          sp unit_test_main


@2075:002076                    msgp: .word msg                ; @@ReadBy a2072
@2076:000030                     msg: .flexl "N"
@2076:000060                          .flexl "O"
@2076:000046                          .flexl "W"
@2076:000010                          .flexl " "
@2076:000014                          .flexl "I"
@2076:000012                          .flexl "S"
@2076:000010                          .flexl " "
@2076:000040                          .flexl "T"
@2076:000050                          .flexl "H"
@2076:000002                          .flexl "E"
@2076:000010                          .flexl " "
@2076:000040                          .flexl "T"
@2076:000014                          .flexl "I"
@2076:000070                          .flexl "M"
@2076:000002                          .flexl "E"
@2076:177776                          .word -1


                                      ; -----------------------------------------
                                      ; draw a character string on the CRT
                                      ; AC contains a pointer to the string, terminated by the first negative 'character'
                                      ; ds_argx and ds_argy give the initial (x, y) location
                            draw_str:
@2077:052121                          ta ds_ret                ; @@JumpedToBy a0171 a2073
@2100:046122                          td ds_lcl_charp          ; save the character pointer passed in the ACC
                             ds_loop:
@2101:102123                          ca ds_argx               ; @@JumpedToBy a2120
@2102:042361                          ts d16c_argx
@2103:102124                          ca ds_argy
@2104:042362                          ts d16c_argy
@2105:102122                          ca ds_lcl_charp          ; walk the string from start to finish
@2106:046107                          td ds_get_char
                         ds_get_char:
@2107:100000                          ca 0                     ; fetch the next character in the string @@WrittenBy a2106
@2110:076311                          sp draw_16seg_char       ; actually draw the character!

@2111:132122                          ao ds_lcl_charp          ; prepare for next char in loop
@2112:046113                          td ds_test_str_end
                     ds_test_str_end:
@2113:100000                          ca 0                     ; @@WrittenBy a2112
@2114:072121                          cp ds_ret                ; test for a negative number as the marker for the string end; branch out if done

@2115:102123                          ca ds_argx
@2116:112310                          ad char_spacing
@2117:042123                          ts ds_argx
@2120:076101                          sp ds_loop

                              ds_ret:
@2121:074000                          sp 0                     ; @@WrittenBy a2077 JumpedToBy a2114

@2122:000000            ds_lcl_charp: .word 0                  ; pointer to the next character to display @@WrittenBy a2100 a2111 ReadBy a2105 a2111
@2123:000000                 ds_argx: .word 0                  ; @@WrittenBy a0167 a2070 a2117 ReadBy a2101 a2115
@2124:000000                 ds_argy: .word 0                  ; @@WrittenBy a0165 a2071 ReadBy a2103

                                      ; ---------------------------

                                      ; The following table, indexed by ASCII character, gives a bit map of which of the 16
                                      ; segments should be lit for each symbol.
                SixteenSegmentFlexop:
@2125:002126                          .word SixteenSegmentFlexo; @@ReadBy a2312
                 SixteenSegmentFlexo:
                         flexo_ucase:
@2126:125074                          .word 0o125074           ; /* # */
@2127:125074                          .word 0o125074           ; /* # */
@2130:100363                          .word 0o100363           ; /* E */
@2131:104377                          .word 0o104377           ; /* 8 */
@2132:125074                          .word 0o125074           ; /* # */
@2133:000060                          .word 0o000060           ; /* _ */
@2134:104317                          .word 0o104317           ; /* A */
@2135:004077                          .word 0o004077           ; /* 3 */
@2136:000000                          .word 0o000000           ; /* (space) */
@2137:021000                          .word 0o021000           ; /* : */
@2140:104273                          .word 0o104273           ; /* S */
@2141:104214                          .word 0o104214           ; /* 4 */
@2142:021063                          .word 0o021063           ; /* I */
@2143:042000                          .word 0o042000           ; /* / */
@2144:000374                          .word 0o000374           ; /* U */
@2145:104167                          .word 0o104167           ; /* 2 */
@2146:177777                          .word 0o177777           ; /* (del) */
@2147:040400                          .word 0o040400           ; /* ) */
@2150:021077                          .word 0o021077           ; /* D */
@2151:110263                          .word 0o110263           ; /* 5 */
@2152:114307                          .word 0o114307           ; /* R */
@2153:002014                          .word 0o002014           ; /* 1 */
@2154:000174                          .word 0o000174           ; /* J */
@2155:000017                          .word 0o000017           ; /* 7 */
@2156:010714                          .word 0o010714           ; /* N */
@2157:012000                          .word 0o012000           ; /* ( */
@2160:100303                          .word 0o100303           ; /* F */
@2161:104373                          .word 0o104373           ; /* 6 */
@2162:000363                          .word 0o000363           ; /* C */
@2163:104000                          .word 0o104000           ; /* - */
@2164:112300                          .word 0o112300           ; /* K */
@2165:125074                          .word 0o125074           ; /* # */
@2166:021003                          .word 0o021003           ; /* T */
@2167:125074                          .word 0o125074           ; /* # */
@2170:042063                          .word 0o042063           ; /* Z */
@2171:177777                          .word 0o177777           ; /* (del) */
@2172:000360                          .word 0o000360           ; /* L */
@2173:000000                          .word 0o000000           ; /* (space) */
@2174:050314                          .word 0o050314           ; /* W */
@2175:125074                          .word 0o125074           ; /* # */
@2176:104314                          .word 0o104314           ; /* H */
@2177:000000                          .word 0o000000           ; /* (space) */
@2200:104274                          .word 0o104274           ; /* Y */
@2201:125074                          .word 0o125074           ; /* # */
@2202:104307                          .word 0o104307           ; /* P */
@2203:125074                          .word 0o125074           ; /* # */
@2204:010377                          .word 0o010377           ; /* Q */
@2205:125074                          .word 0o125074           ; /* # */
@2206:000377                          .word 0o000377           ; /* O */
@2207:177777                          .word 0o177777           ; /* (del) */
@2210:025077                          .word 0o025077           ; /* B */
@2211:125074                          .word 0o125074           ; /* # */
@2212:004373                          .word 0o004373           ; /* G */
@2213:125074                          .word 0o125074           ; /* # */
@2214:104277                          .word 0o104277           ; /* 9 */
@2215:125074                          .word 0o125074           ; /* # */
@2216:002714                          .word 0o002714           ; /* M */
@2217:177777                          .word 0o177777           ; /* (del) */
@2220:052400                          .word 0o052400           ; /* X */
@2221:125074                          .word 0o125074           ; /* # */
@2222:042300                          .word 0o042300           ; /* V */
@2223:177777                          .word 0o177777           ; /* (del) */
@2224:042377                          .word 0o042377           ; /* 0 */
@2225:177777                          .word 0o177777           ; /* (del) */


                                      ; Lower Case not used yet
                                      ;flexo_lcase:
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o140140   ; /* e */
                                      ;        .word 0o104377   ; /* 8 */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o021000   ; /* | */
                                      ;        .word 0o120160   ; /* a */
                                      ;        .word 0o004077   ; /* 3 */
                                      ;        .word 0o000000   ; /* (space) */
                                      ;        .word 0o104060   ; /* = */
                                      ;        .word 0o120241   ; /* s */
                                      ;        .word 0o104214   ; /* 4 */
                                      ;        .word 0o020000   ; /* i */
                                      ;        .word 0o125000   ; /* + */
                                      ;        .word 0o020140   ; /* u */
                                      ;        .word 0o104167   ; /* 2 */
                                      ;        .word 0o177777   ; /* (del) */
                                      ;        .word 0o010000   ; /* . */
                                      ;        .word 0o024034   ; /* d */
                                      ;        .word 0o110263   ; /* 5 */
                                      ;        .word 0o100100   ; /* r */
                                      ;        .word 0o002014   ; /* 1 */
                                      ;        .word 0o021140   ; /* j */
                                      ;        .word 0o000017   ; /* 7 */
                                      ;        .word 0o120100   ; /* n */
                                      ;        .word 0o040000   ; /* , */
                                      ;        .word 0o125002   ; /* f */
                                      ;        .word 0o104373   ; /* 6 */
                                      ;        .word 0o100140   ; /* c */
                                      ;        .word 0o104000   ; /* - */
                                      ;        .word 0o033000   ; /* k */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o100340   ; /* t */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o140040   ; /* z */
                                      ;        .word 0o177777   ; /* (del) */
                                      ;        .word 0o000300   ; /* l */
                                      ;        .word 0o000000   ; /* (space) */
                                      ;        .word 0o050110   ; /* w */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o120300   ; /* h */
                                      ;        .word 0o000000   ; /* (space) */
                                      ;        .word 0o005034   ; /* y */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o101301   ; /* p */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o121201   ; /* q */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o120140   ; /* o */
                                      ;        .word 0o177777   ; /* (del) */
                                      ;        .word 0o120340   ; /* b */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o121241   ; /* g */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o104277   ; /* 9 */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o124110   ; /* m */
                                      ;        .word 0o177777   ; /* (del) */
                                      ;        .word 0o052400   ; /* x */
                                      ;        .word 0o125074   ; /* # */
                                      ;        .word 0o040100   ; /* v */
                                      ;        .word 0o177777   ; /* (del) */
                                      ;        .word 0o042377   ; /* 0 */
                                      ;        .word 0o177777   ; /* (del) */


                                      ; // size of 16-segment characters
                                      .pp WIDTH_16SEG, 0o60
                                      .pp HEIGHT_16SEG, 0o110
                                      .pp OFFSET_16SEG, 0o10   ; 0d08
                                      .pp SPACING_16SEG, (WIDTH_16SEG + WIDTH_16SEG / 4) * 64

                                      ; Delta word for vectors
                                      ;  Left 8 bits are horizontal, right 8 are vertical
                                      ;  Of each, only the six left bits are used

                                      .pp DOWN_LEFT, ((127 - (OFFSET_16SEG - 3)) * 256 * 2) + (255 - HEIGHT_16SEG)
                                      .pp UP_RIGHT, (OFFSET_16SEG - 3) * 256 * 2 + HEIGHT_16SEG
                                      .pp HORIZ_RIGHT, WIDTH_16SEG * 256

                                      .pp UP_RIGHT_DIAG, ((OFFSET_16SEG + WIDTH_16SEG) * 256) + HEIGHT_16SEG
                                      .pp DOWN_RIGHT_DIAG, ((WIDTH_16SEG - OFFSET_16SEG) * 256) + (255 - HEIGHT_16SEG)


                                      ; // these defines give the relative offsets for the points
                                      ; // that make up a 16-segment display
                                      .pp P0x, 64 * OFFSET_16SEG
                                      .pp P0y, 64 * HEIGHT_16SEG

                                      .pp P1x, 64 * (OFFSET_16SEG + WIDTH_16SEG / 2)
                                      .pp P1y, 64 * HEIGHT_16SEG

                                      .pp P2x, 64 * (OFFSET_16SEG + WIDTH_16SEG)
                                      .pp P2y, 64 * HEIGHT_16SEG

                                      .pp P3x, 64 * (OFFSET_16SEG / 2 + WIDTH_16SEG)
                                      .pp P3y, 64 * HEIGHT_16SEG / 2

                                      .pp P4x, 64 * WIDTH_16SEG
                                      .pp P4y, 64 * 0

                                      .pp P5x, 64 * WIDTH_16SEG / 2;  P0...P1...P2
                                      .pp P5y, 64 * 0          ;  .         .
                                      ;  .         .
                                      .pp P6x, 64 * 0          ;  .         .
                                      .pp P6y, 64 * 0          ;  P7...P8...P3
                                      ;  .         .
                                      .pp P7x, 64 * OFFSET_16SEG / 2;  .         .
                                      .pp P7y, 64 * HEIGHT_16SEG / 2;  .         .
                                      ;  P6...P5...P4

                                      .pp P8x, 64 * (OFFSET_16SEG / 2 + WIDTH_16SEG / 2)
                                      .pp P8y, 64 * HEIGHT_16SEG / 2


                                      ; // and this array gives sixteen starting points and delta for each line
                                      ; // segment in the 16-segment display character.

                      seg_tab_startp:
@2226:002227                          .word seg00x

@2227:001000                  seg00x: .word P0x                ;   {P0, P1}
@2230:011000                  seg00y: .word P0y
@2231:030000                  seg00d: .word HORIZ_RIGHT

@2232:004000                  seg01x: .word P1x                ;   {P1, P2},
@2233:011000                  seg01y: .word P1y
@2234:030000                  seg01d: .word HORIZ_RIGHT

@2235:007000                  seg02x: .word P2x                ;   {P2, P3},
@2236:011000                  seg02y: .word P2y
@2237:172267                  seg02d: .word DOWN_LEFT

@2240:006400                  seg03x: .word P3x                ;   {P3, P4},
@2241:004400                  seg03y: .word P3y
@2242:172267                  seg03d: .word DOWN_LEFT

@2243:003000                  seg04x: .word P5x                ;   {P4, P5},
@2244:000000                  seg04y: .word P5y
@2245:030000                  seg04d: .word HORIZ_RIGHT

@2246:000000                  seg05x: .word P6x                ;   {P5, P6},
@2247:000000                  seg05y: .word P6y
@2250:030000                  seg05d: .word HORIZ_RIGHT

@2251:000000                  seg06x: .word P6x                ;   {P6, P7},
@2252:000000                  seg06y: .word P6y
@2253:005110                  seg06d: .word UP_RIGHT

@2254:000400                  seg07x: .word P7x                ;   {P7, P0},
@2255:004400                  seg07y: .word P7y
@2256:005110                  seg07d: .word UP_RIGHT

@2257:001000                  seg08x: .word P0x                ;   {P0, P8},
@2260:011000                  seg08y: .word P0y
@2261:024267                  seg08d: .word DOWN_RIGHT_DIAG

@2262:004000                  seg09x: .word P1x                ;   {P1, P8},
@2263:011000                  seg09y: .word P1y
@2264:172267                  seg09d: .word DOWN_LEFT

@2265:003400                  seg10x: .word P8x                ;   {P2, P8},
@2266:004400                  seg10y: .word P8y
@2267:034110                  seg10d: .word UP_RIGHT_DIAG

@2270:003400                  seg11x: .word P8x                ;   {P3, P8},
@2271:004400                  seg11y: .word P8y
@2272:030000                  seg11d: .word HORIZ_RIGHT

@2273:003400                  seg12x: .word P8x                ;   {P4, P8},
@2274:004400                  seg12y: .word P8y
@2275:024267                  seg12d: .word DOWN_RIGHT_DIAG

@2276:003400                  seg13x: .word P8x                ;   {P5, P8},
@2277:004400                  seg13y: .word P8y
@2300:172267                  seg13d: .word DOWN_LEFT

@2301:000000                  seg14x: .word P6x                ;   {P6, P8},
@2302:000000                  seg14y: .word P6y
@2303:034110                  seg14d: .word UP_RIGHT_DIAG

@2304:000400                  seg15x: .word P7x                ;   {P7, P8},
@2305:004400                  seg15y: .word P7y
@2306:030000                  seg15d: .word HORIZ_RIGHT

                        seg_tab_endp:
@2307:002304                          .word seg15x             ; @@ReadBy a2320
                        char_spacing:
@2310:007400                          .word SPACING_16SEG      ; @@ReadBy a2116


                                      ; Draw a Flexo character passed in to this routine in the ACC
                                      ; First, find the segment map for a given character.  Input is a Flexo-coded character.
                                      ; The routine returns a 16-bit int where each bit represents one stroke in the character.  If the
                                      ; bit is one, draw the stroke; if not, don't draw.
                                      ; Character position is given by the args d16c_argx, d16c_argy.
                     draw_16seg_char:
@2311:052360                          ta d16c_ret              ; @@JumpedToBy a2110

@2312:112125                          ad SixteenSegmentFlexop  ; add the table start addr to the offset in ACC
@2313:046314                          td d16c_rd
                             d16c_rd:
@2314:100000                          ca 0                     ; fetch the bit map @@WrittenBy a2313
@2315:042363                          ts d16c_lcl_seg_map

                                      ; draw the sixteen segments, starting with the most significant bit
@2316:104042                          cs c_15                  ; prep for 16 times around the loop
@2317:042364                          ts d16c_lcl_loop_cnt
@2320:102307                          ca seg_tab_endp          ; walk the segment table back to front
@2321:046354                          td d16c_read_seg_tabx    ; first table entry
                                      ;        td tmp_tabx
@2322:110001                          ad one
@2323:046351                          td d16c_read_seg_taby    ; second table entry
                                      ;        td tmp_taby
@2324:110001                          ad one
@2325:046356                          td d16c_read_seg_tabdxy  ; third table entry

                                      ; I've commented out a bit of debug code here to draw dots at each of the junction points in the
                                      ; 16-segment figure.  Use this to verify that the line segments are the right length...
                           d16s_loop:
                                      ; this strip draws dots at the intersection points
@2326:100000                          ca 0                     ; no op @@JumpedToBy a2347
                                      ;tmp_taby:
                                      ;        ca 0
@2327:000677                          si scope_point           ; ; Auto-Annotate I/O: Display Points
                                      ;tmp_tabx:
                                      ;        ca 0
                                      ;        rc 0
                                      ; end of debug hack
@2330:102363                          ca d16c_lcl_seg_map
@2331:072351                          cp d16c_draw_seg         ; branch if most significant bit is on

                  d16s_loop_continue:
@2332:102363                          ca d16c_lcl_seg_map      ; @@JumpedToBy a2357
@2333:170001                          clc 1                    ; shift AC left by one bit
@2334:042363                          ts d16c_lcl_seg_map
@2335:102354                          ca d16c_read_seg_tabx
@2336:115161                          su c_3
@2337:046354                          td d16c_read_seg_tabx
                                      ;        td tmp_tabx
@2340:102351                          ca d16c_read_seg_taby
@2341:115161                          su c_3
@2342:046351                          td d16c_read_seg_taby
                                      ;        td tmp_taby
@2343:102356                          ca d16c_read_seg_tabdxy
@2344:115161                          su c_3
@2345:046356                          td d16c_read_seg_tabdxy
@2346:132364                          ao d16c_lcl_loop_cnt
@2347:072326                          cp d16s_loop
@2350:076360                          sp d16c_ret              ; bail out when count exhausted

                                      ; on entry to this code block, the three entries in the segment table should give:
                                      ;   _tab1 = X pos'n
                                      ;   _tab2 = Y pos'n
                                      ;   _tab3 = XY Delta vector
                       d16c_draw_seg:                          ; branch here if we're doing a segment, then return to the loop
                                      ; the SI uses the AC to set Y coord
                  d16c_read_seg_taby:
@2351:100000                          ca 0                     ; @@WrittenBy a2323 a2342 ReadBy a2340 JumpedToBy a2331
@2352:112362                          ad d16c_argy
@2353:001677                          si scope_vector          ; initialize vector gen with the y-coord in ACC ; Auto-Annotate I/O: Display Vectors

                                      ; the RC uses AC to set X coord and mem address for the vector length
                  d16c_read_seg_tabx:
@2354:100000                          ca 0                     ; @@WrittenBy a2321 a2337 ReadBy a2335
@2355:112361                          ad d16c_argx
                d16c_read_seg_tabdxy:
@2356:024000                          rc 0                     ; @@WrittenBy a2325 a2345 ReadBy a2343
@2357:076332                          sp d16s_loop_continue

                            d16c_ret:                          ;; Return from draw_16seg_char
@2360:074000                          sp 0                     ; @@WrittenBy a2311 JumpedToBy a2350

                           d16c_argx:
@2361:000000                          .word 0                  ; @@WrittenBy a2102 ReadBy a2355
                           d16c_argy:
@2362:000000                          .word 0                  ; @@WrittenBy a2104 ReadBy a2352
                    d16c_lcl_seg_map:
@2363:000000                          .word 0                  ; @@WrittenBy a2315 a2334 ReadBy a2330 a2332
                   d16c_lcl_loop_cnt:
@2364:000000                          .word 0                  ; @@WrittenBy a2317 a2346 ReadBy a2346





                                      ; Character Table license

                                      ; /*
                                      ;  *  Project     Segmented LED Display - ASCII Library
                                      ;  *  @author     David Madison
                                      ;  *  @link       github.com/dmadison/Segmented-LED-Display-ASCII
                                      ;  *  @license    MIT - Copyright (c) 2017 David Madison
                                      ;  *
                                      ;  * Permission is hereby granted, free of charge, to any person obtaining a copy
                                      ;  * of this software and associated documentation files (the "Software"), to deal
                                      ;  * in the Software without restriction, including without limitation the rights
                                      ;  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                                      ;  * copies of the Software, and to permit persons to whom the Software is
                                      ;  * furnished to do so, subject to the following conditions:
                                      ;  *
                                      ;  * The above copyright notice and this permission notice shall be included in
                                      ;  * all copies or substantial portions of the Software.
                                      ;  *
                                      ;  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                                      ;  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                                      ;  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                                      ;  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                                      ;  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                                      ;  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
                                      ;  * THE SOFTWARE.
                                      ;  *
                                      ;  */


                                      ; /*********************************************************************************************************
                                      ;   END FILE
                                      ; *********************************************************************************************************/

