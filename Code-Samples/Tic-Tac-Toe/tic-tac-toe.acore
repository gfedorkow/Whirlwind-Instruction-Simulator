
; *** Core Image ***
%File: tic-tac-toe.ww
%TapeID: 
@C0000: 0000000 0000001  None    None    None    None    None    None   
@C0040: 0075105 0074046 0000017 0000040 0073300 0062000 0074070 0101131 
@C0050: 0070046 0074727 0100211 0134000 0070056 0074065 0100201 0110001 
@C0060: 0070046 0074566 0104001 0040201 0074046 0104001 0041131 0074046 
@C0070: 0050174 0105133 0040202 0101136 0040204 0101133 0040203 0105143 
@C0100: 0040207 0074326 0101142 0040204 0130202 0070075 0105133 0040202 
@C0110: 0101136 0040203 0101133 0040204 0105143 0040207 0074345 0101142 
@C0120: 0040203 0130202 0070112 0105140 0040202 0100272 0040176 0110001 
@C0130: 0040177 0110001 0040200 0104001 0040201 0100176 0040205 0100177 
@C0140: 0040206 0100200 0044143 0100000 0044145 0074000 0100176 0111134 
@C0150: 0040176 0100177 0111134 0040177 0100200 0111134 0040200 0130202 
@C0160: 0070135 0100211 0175137 0110221 0044171 0104044 0042161 0104045 
@C0170: 0042160 0100000 0076134 0074505 0074000 0000000 0000000 0000000 
@C0200: 0000000 0177776 0000000 0000000 0000000 0000000 0000000 0000000 
@C0210: 0000000 0000000 0000007 0000001 0000212 0000213 0000217 0000404 
@C0220: 0000425 0000222 0000227 0000240 0000251 0000257 0000265 0000054 
@C0230: 0000044 0000006 0000052 0000002 0000024 0000010 0000072 0177776 
@C0240: 0000054 0000044 0000006 0000052 0000002 0000024 0000010 0000060 
@C0250: 0177776 0000072 0000010 0000046 0000014 0000030 0177776 0000060 
@C0260: 0000010 0000046 0000014 0000030 0177776 0000022 0000024 0000006 
@C0270: 0000046 0177776 0000273 0000004 0000014 0000362 0000010 0000014 
@C0300: 0000362 0000014 0000014 0000362 0000004 0000010 0000362 0000010 
@C0310: 0000010 0000362 0000014 0000010 0000362 0000004 0000004 0000362 
@C0320: 0000010 0000004 0000362 0000014 0000004 0000362 0050344 0100204 
@C0330: 0115140 0154014 0001677 0100203 0115140 0040203 0100203 0154014 
@C0340: 0025151 0130203 0130207 0070336 0074000 0050361 0100204 0115140 
@C0350: 0154014 0001677 0100203 0115140 0154014 0025152 0130204 0130207 
@C0360: 0070346 0074000 0050403 0100211 0070403 0100206 0044367 0100000 
@C0370: 0115140 0154014 0000677 0100205 0044375 0100000 0115140 0154014 
@C0400: 0024000 0014000 0070515 0074000 0050424 0100206 0044407 0100000 
@C0410: 0115140 0154014 0001677 0100205 0044415 0100000 0115140 0154014 
@C0420: 0025153 0025154 0025156 0025155 0074000 0050446 0100206 0044430 
@C0430: 0100000 0115140 0154014 0001677 0100205 0044436 0100000 0115141 
@C0440: 0154014 0025153 0025155 0111145 0025156 0025154 0074000 0050465 
@C0450: 0100206 0044452 0100000 0115140 0154014 0001677 0100205 0044460 
@C0460: 0100000 0115140 0154014 0025153 0025156 0074000 0050504 0100206 
@C0470: 0044471 0100000 0115140 0154014 0001677 0100205 0044477 0100000 
@C0500: 0115140 0154014 0025154 0025155 0074000 0050514 0105137 0154014 
@C0510: 0000677 0024000 0014000 0071105 0074000 0050541 0040544 0100205 
@C0520: 0044521 0100000 0160002 0114001 0040542 0100206 0044527 0100000 
@C0530: 0160002 0031132 0111134 0040543 0155001 0110543 0110542 0040201 
@C0540: 0074727 0074000 0000000 0000000 0000000 0050564 0040565 0155001 
@C0550: 0110565 0110272 0111133 0044560 0100216 0110211 0044557 0100000 
@C0560: 0040000 0100211 0030001 0040211 0074000 0000000 0050615 0100201 
@C0570: 0040616 0155001 0110616 0110272 0111133 0044602 0100216 0110211 
@C0600: 0044601 0100000 0040000 0074727 0070614 0100175 0134000 0070612 
@C0610: 0074637 0074614 0100616 0074617 0130175 0074000 0000000 0050634 
@C0620: 0040635 0101073 0110635 0044624 0100000 0040636 0110272 0111161 
@C0630: 0044632 0100220 0040000 0030000 0074000 0000000 0000000 0050722 
@C0640: 0100272 0111133 0044647 0101265 0044675 0105140 0040724 0100000 
@C0650: 0040725 0135047 0134000 0070655 0074660 0131043 0104001 0074675 
@C0660: 0100725 0135051 0134000 0070665 0074667 0101171 0074675 0100725 
@C0670: 0135050 0134000 0070674 0074723 0101170 0040000 0130675 0130647 
@C0700: 0130647 0130647 0130724 0070647 0101171 0041172 0101170 0041173 
@C0710: 0076007 0040726 0154001 0110726 0111161 0110272 0044720 0100220 
@C0720: 0040000 0030000 0074000 0074000 0000000 0000000 0000000 0051036 
@C0730: 0105137 0041037 0101052 0044742 0110001 0045002 0104000 0041044 
@C0740: 0105133 0041040 0100000 0041045 0155001 0111045 0110272 0111133 
@C0750: 0044755 0100000 0041041 0041042 0041043 0100000 0041046 0135047 
@C0760: 0134000 0070763 0074765 0131043 0131044 0101046 0135051 0134000 
@C0770: 0070772 0074773 0131041 0101046 0135050 0134000 0071000 0075001 
@C1000: 0131042 0100755 0110000 0040755 0131040 0070755 0101134 0135041 
@C1010: 0071015 0101134 0135042 0071020 0075023 0101147 0040211 0075023 
@C1020: 0101146 0040211 0075023 0130742 0130742 0131002 0131002 0131037 
@C1030: 0070740 0101044 0071034 0075036 0101150 0040211 0074000 0000000 
@C1040: 0000000 0000000 0000000 0000000 0000000 0000000 0000000 0000362 
@C1050: 0000404 0000425 0001053 0000000 0000003 0000003 0000003 0000006 
@C1060: 0000003 0000000 0000011 0000001 0000011 0000002 0000011 0000000 
@C1070: 0000014 0000002 0000006 0001074 0000014 0000000 0000014 0000000 
@C1100: 0000000 0000006 0000014 0000003 0000014 0051127 0100000 0040175 
@C1110: 0100272 0111133 0045116 0105140 0040202 0101130 0040000 0101116 
@C1120: 0111134 0041116 0130202 0071115 0100000 0040211 0041131 0074000 
@C1130: 0000362 0000000 0177777 0000002 0000003 0000004 0000006 0000007 
@C1140: 0000010 0000011 0000012 0000013 0000014 0020000 0100002 0100003 
@C1150: 0100004 0076000 0000174 0076174 0100200 0076200 0100174 0100000 
@C1160: 0000000 0000002 0177775 0000003 0000004 0177767 0000012 0001750 
@C1170: 0000001 0000002 0000001 0000002 0000011 0000001 0001177 0000001 
@C1200: 0000002 0000002 0000001 0000002 0000001 0177776 0177776 0177776 
@C1210: 0177776 0000002 0000002 0000001 0000002 0000001 0177776 0177776 
@C1220: 0177776 0177776 0000002 0000002 0000001 0000001 0000001 0000002 
@C1230: 0177776 0177776 0177776 0000002 0000001 0000001 0000002 0000001 
@C1240: 0000002 0000002 0177776 0177776 0000002 0000001 0000002 0000001 
@C1250: 0000002 0000001 0000002 0177776 0000002 0000001 0177776 0177776 
@C1260: 0000002 0177776 0177776 0177776 0177776 0001254 0051305 0101265 
@C1270: 0045273 0101165 0041306 0100000 0071304 0100001 0041307 0131273 
@C1300: 0131306 0071273 0104001 0075305 0100001 0074000 0000000 0000000 
@C1310: 0051341 0111265 0045313 0100000 0071340 0041343 0101313 0111342 
@C1320: 0045321 0100000 0115343 0134000 0071326 0075340 0101321 0111342 
@C1330: 0045331 0100000 0115343 0134000 0071336 0075340 0105343 0075341 
@C1340: 0100001 0074000 0000000 0000000 0051424 0100001 0041342 0100000 
@C1350: 0041425 0101162 0041426 0101425 0075310 0071415 0101163 0111425 
@C1360: 0041425 0131426 0071353 0101163 0041342 0100000 0041425 0101162 
@C1370: 0041426 0101425 0075310 0071415 0100001 0111425 0041425 0131426 
@C1400: 0071371 0101164 0041342 0100000 0075310 0071415 0101161 0041342 
@C1410: 0101161 0075310 0071415 0100000 0075424 0111172 0134000 0071422 
@C1420: 0105166 0075424 0101166 0075424 0074000 0000000 0000000 0051456 
@C1430: 0041507 0101513 0115506 0071157 0105511 0110001 0041510 0101512 
@C1440: 0045443 0101514 0045444 0100000 0040000 0131443 0131444 0131510 
@C1450: 0071443 0101514 0111511 0045514 0131506 0101507 0074000 0051505 
@C1460: 0041507 0101514 0115511 0045514 0101506 0114001 0041506 0105511 
@C1470: 0110001 0041510 0101512 0045477 0101514 0045476 0100000 0040000 
@C1500: 0131476 0131477 0131510 0071476 0101507 0074000 0000000 0000000 
@C1510: 0000000 0000007 0001776 0000012 0001515 0000000 0000000 0000000 
@C1520: 0000000 0000000 0000000 0000000 0000000 0000000 0000000 0000000 
@C1530: 0000000 0000000 0000000 0000000 0000000 0000000 0000000 0000000 
@C1540: 0000000 0000000 0000000 0000000 0000000 0000000 0000000 0000000 
@C1550: 0000000 0000000 0000000 0000000 0000000 0000000 0000000 0000000 
@C1560: 0000000 0000000 0000000 0000000 0000000 0000000 0000000 0000000 
@C1570: 0000000 0000000 0000000 0000000 0000000 0000000 0000000 0000000 
@C1600: 0000000 0000000 0000000 0000000 0000000 0000000 0000000 0000000 
@C1610: 0000000 0000000 0000000 0000000 0000000 0000000 0000000 0000000 
@C1620: 0000000 0000000 0000000 0000000 0001623 0051776 0041777 0075427 
@C1630: 0030000 0075344 0042000 0102000 0115166 0134000 0071640 0075643 
@C1640: 0102000 0042003 0075772 0102000 0111166 0134000 0071650 0075653 
@C1650: 0102000 0042003 0075772 0075266 0071656 0075661 0100000 0042003 
@C1660: 0075772 0101777 0071727 0105167 0042003 0100000 0042001 0101165 
@C1670: 0042002 0101265 0112001 0045676 0045702 0046004 0100000 0071701 
@C1700: 0075722 0101172 0040000 0030000 0104000 0031777 0104001 0075625 
@C1710: 0114001 0042006 0116003 0071716 0102006 0042003 0102004 0045721 
@C1720: 0104001 0040000 0132001 0132002 0071671 0102003 0075772 0101167 
@C1730: 0042003 0100000 0042001 0101165 0042002 0101265 0112001 0045742 
@C1740: 0045746 0046004 0100000 0071745 0075765 0101173 0040000 0030000 
@C1750: 0100001 0075625 0110001 0042006 0116003 0071757 0075761 0102006 
@C1760: 0042003 0102004 0045764 0104001 0040000 0132001 0132002 0071735 
@C1770: 0102003 0075772 0030000 0030000 0102003 0075457 0074000 0000000 
@C2000: 0000000 0000000 0000000 0000000 0000000 0000000 0000000 0052063 
@C2010: 0100211 0030001 0040211 0105167 0042064 0104001 0042065 0101165 
@C2020: 0042066 0100000 0042067 0101265 0046027 0046033 0046041 0100000 
@C2030: 0072032 0076051 0101172 0040000 0074070 0104001 0075625 0042070 
@C2040: 0104001 0040000 0102070 0116064 0072051 0102070 0042064 0102067 
@C2050: 0042065 0132027 0132033 0132041 0132067 0132066 0072027 0100211 
@C2060: 0030001 0040211 0102065 0074000 0000000 0000000 0000000 0000000 
@C2070: 0000000 0104044 0042160 0042161 0102077 0076134 0076071 0002100 
@C2100: 0000071 0000030 0000071 0000060 0000071 0000046 0000010 0000071 
@C2110: 0000014 0000071 0000012 0000010 0000071 0000040 0000071 0000050 
@C2120: 0000071 0000002 0000010 0000071 0000040 0000071 0000014 0000071 
@C2130: 0000070 0000071 0000002 0177776 0052156 0046157 0102160 0042416 
@C2140: 0102161 0042417 0102157 0046144 0100000 0076346 0132157 0046150 
@C2150: 0100000 0072156 0102160 0112345 0042160 0076136 0074000 0000000 
@C2160: 0000000 0000000 0002163 0125074 0125074 0100363 0104377 0125074 
@C2170: 0000060 0104317 0004077 0000000 0021000 0104273 0104214 0021063 
@C2200: 0042000 0000374 0104167 0177777 0040400 0021077 0110263 0114307 
@C2210: 0002014 0000174 0000017 0010714 0012000 0100303 0104373 0000363 
@C2220: 0104000 0112300 0125074 0021003 0125074 0042063 0177777 0000360 
@C2230: 0000000 0050314 0125074 0104314 0000000 0104274 0125074 0104307 
@C2240: 0125074 0010377 0125074 0000377 0177777 0025077 0125074 0004373 
@C2250: 0125074 0104277 0125074 0002714 0177777 0052400 0125074 0042300 
@C2260: 0177777 0042377 0177777 0002264 0001000 0011000 0030000 0004000 
@C2270: 0011000 0030000 0007000 0011000 0172267 0006400 0004400 0172267 
@C2300: 0003000 0000000 0030000 0000000 0000000 0030000 0000000 0000000 
@C2310: 0005110 0000400 0004400 0005110 0001000 0011000 0024267 0004000 
@C2320: 0011000 0172267 0003400 0004400 0034110 0003400 0004400 0030000 
@C2330: 0003400 0004400 0024267 0003400 0004400 0172267 0000000 0000000 
@C2340: 0034110 0000400 0004400 0030000 0002341 0007400 0052415 0112162 
@C2350: 0046351 0100000 0042420 0104042 0042421 0102344 0046411 0110001 
@C2360: 0046406 0110001 0046413 0100000 0000677 0102420 0072406 0102420 
@C2370: 0170001 0042420 0102411 0115163 0046411 0102406 0115163 0046406 
@C2400: 0102413 0115163 0046413 0132421 0072363 0076415 0100000 0112417 
@C2410: 0001677 0100000 0112416 0024000 0076367 0074000 0000000 0000000 
@C2420: 0000000 0000000  None    None    None    None    None    None   
@S0000: zero
@S0000: const_0
@S0001: one
@S0001: const_1
@S0040: main
@S0042: c_15
@S0043: c_32
@S0044: c_scope_edge
@S0045: c_msg_x_pos
@S0046: refresh_loop
@S0056: rl_continue_game
@S0065: set_game_over
@S0070: draw_game_board
@S0075: x_grid_loop
@S0112: y_grid_loop
@S0123: draw_game_state
@S0135: gb_loop
@S0135: gb_x_inst
@S0137: gb_y_inst
@S0141: gb_gs_inst
@S0143: ca_addr
@S0145: gb_state_sp
@S0161: draw_current_player
@S0171: dcp_ca_addr
@S0174: draw_game_board_ret
@S0175: move_number
@S0176: next_x_addr
@S0177: next_y_addr
@S0200: next_gb_state_addr
@S0201: light_gun_mailbox
@S0202: loop_count
@S0203: x_arg
@S0204: y_arg
@S0205: x_addr_arg
@S0206: y_addr_arg
@S0207: n_segments
@S0210: gb_state_arg
@S0211: which_player
@S0212: player_state_x_addr
@S0213: player_state_y_addr
@S0214: player_state_x_ptr
@S0215: player_state_y_ptr
@S0216: player_icon_table
@S0217: dct0
@S0220: dct1
@S0221: state_msg_tablep
@S0222: state_msg_table
@S0227: msg_cross_play
@S0240: msg_naught_play
@S0251: msg_x_win
@S0257: msg_o_win
@S0265: msg_draw
@S0272: gb_table_start
@S0273: gb0_x
@S0274: gb0_y
@S0275: gb0_state
@S0276: gb1_x
@S0277: gb1_y
@S0300: gb1_state
@S0301: gb2_x
@S0302: gb2_y
@S0303: gb2_state
@S0304: gb3_x
@S0305: gb3_y
@S0306: gb3_state
@S0307: gb4_x
@S0310: gb4_y
@S0311: gb4_state
@S0312: gb5_x
@S0313: gb5_y
@S0314: gb5_state
@S0315: gb6_x
@S0316: gb6_y
@S0317: gb6_state
@S0320: gb7_x
@S0321: gb7_y
@S0322: gb7_state
@S0323: gb8_x
@S0324: gb8_y
@S0325: gb8_state
@S0326: draw_x_line
@S0336: next_x_seg
@S0344: draw_x_line_ret
@S0345: draw_y_line
@S0346: next_y_seg
@S0361: draw_y_line_ret
@S0362: draw_dot
@S0367: dd_y_arg
@S0375: dd_x_arg
@S0403: draw_dot_ret
@S0404: draw_cross
@S0407: dc_y_arg
@S0415: dc_x_arg
@S0424: draw_cross_ret
@S0425: draw_naught
@S0430: dn_y_arg
@S0436: dn_x1_arg
@S0446: draw_naught_ret
@S0447: draw_win
@S0452: dw_y_arg
@S0460: dw_x_arg
@S0465: draw_win_ret
@S0466: draw_tie
@S0471: dt_y_arg
@S0477: dt_x_arg
@S0504: draw_tie_ret
@S0505: draw_reset_symbol
@S0514: draw_reset_symbol_ret
@S0515: light_gun_cell_hit
@S0521: lgh_x1_arg
@S0527: lgh_y1_arg
@S0541: light_gun_cell_hit_ret
@S0542: lcl_cell_x
@S0543: lcl_cell_y
@S0544: lcl_gun_num
@S0545: alternate_play_cell
@S0557: apc_ca0
@S0560: apc_table_ts
@S0564: alternate_play_cell_ret
@S0565: lcl_aplay_cell_num
@S0566: user_play_cell
@S0601: upc_ca0
@S0602: upc_table_ts
@S0612: upc_move_zero
@S0614: upc_cleanup
@S0615: user_play_cell_ret
@S0616: lcl_uplay_cell_num
@S0617: table_play_move
@S0624: tpm_fetch_move_table
@S0632: tpm_store_move
@S0634: table_play_move_ret
@S0635: lcl_tpm_user_move
@S0636: lcl_tpm_table_move
@S0637: auto_play_move
@S0647: apm_copy_src
@S0651: apm_test_dot
@S0655: apm_its_a_dot
@S0660: apm_test_naught
@S0665: apm_its_a_naught
@S0667: apm_test_cross
@S0674: apm_its_a_cross
@S0675: apm_copy_dst
@S0717: apm_fetch_icon_fn
@S0720: apm_store_move
@S0722: apm_ret
@S0723: apm_panic
@S0724: lcl_apm_copy_count
@S0725: lcl_apm_cell_state
@S0726: lcl_cell_for_move
@S0727: is_there_winner
@S0740: itw_outer_loop
@S0742: itw_st_ca
@S0755: itw_inner_loop
@S0755: itw_cell_ts
@S0757: test_dot
@S0763: its_a_dot
@S0765: test_naught
@S0772: its_a_naught
@S0773: test_cross
@S1000: its_a_cross
@S1001: itw_inner_loop_test_end
@S1002: itw_inc_gb
@S1015: naught_win
@S1020: cross_win
@S1023: itw_next_outer_loop
@S1034: its_a_tie
@S1036: is_there_winner_ret
@S1037: lcl_tb_loop_count
@S1040: lcl_cell_loop_count
@S1041: lcl_naught_count
@S1042: lcl_cross_count
@S1043: lcl_dot_count
@S1044: lcl_total_dots
@S1045: lcl_cell_number
@S1046: lcl_cell_state
@S1047: dot_fn_addr
@S1050: cross_fn_addr
@S1051: naught_fn_addr
@S1052: analysis_table_start
@S1053: analysis_table
@S1053: at0
@S1055: at1
@S1057: at2
@S1061: at3
@S1063: at4
@S1065: at5
@S1067: at6
@S1071: at7
@S1073: first_move_table_start
@S1074: first_move_table
@S1105: init_game_board
@S1115: igb_loop
@S1116: igb_table_ts
@S1127: init_game_board_ret
@S1130: lcl_init_val
@S1131: g_game_over
@S1132: const_0n
@S1133: const_2
@S1134: const_3
@S1135: const_4
@S1136: const_6
@S1137: const_7
@S1140: const_8
@S1141: const_9
@S1142: const_10
@S1143: const_11
@S1144: const_12
@S1145: const_2_cell
@S1146: const_x_win
@S1147: const_o_win
@S1150: const_draw
@S1151: horiz_line_seg
@S1152: vert_line_seg
@S1153: diag_up_right_seg
@S1154: diag_dn_left_seg
@S1155: diag_dn_right_seg
@S1156: diag_up_left_seg
@S1157: panic_stop
@S1161: c_2
@S1162: c_2n
@S1163: c_3
@S1164: c_4
@S1165: c_8n
@S1166: c_10
@S1167: c_1000
@S1170: c_XX
@S1171: c_oh
@S1172: player
@S1173: opponent
@S1174: BRD_SIZE
@S1175: BRDS_COUNT
@S1176: first_boardp
@S1177: board2
@S1210: board3
@S1221: board_row_x_win
@S1232: board_col_o_win
@S1243: board_2_4_6_diagonal
@S1254: board4
@S1265: boardp
@S1266: isMovesLeft
@S1273: iML_bptr
@S1300: iML_lp
@S1304: iML_empty
@S1305: isMovesLeftRet
@S1306: iML_cnt
@S1307: iML_ret
@S1310: equ3
@S1313: rd_brd1
@S1321: rd_brd2
@S1326: equ3_brd3
@S1331: rd_brd3
@S1336: equ3_ret_equal
@S1340: equ3_ret_not_equal
@S1341: equ3_ret
@S1342: equ3_arg_stride
@S1343: equ3_lcl_first_read
@S1344: evaluate_board
@S1345: eval_chk_row
@S1353: eval_row_loop
@S1356: eval_chk_nxt_row
@S1363: eval_chk_col
@S1371: eval_col_loop
@S1374: eval_chk_nxt_col
@S1401: eval_chk_diagonal0
@S1406: eval_chk_diagonal1
@S1415: eval_score_players
@S1420: eval_opp_win
@S1422: eval_player_win
@S1424: eval_ret
@S1425: eval_lcl_nxt_cell
@S1426: eval_lcl_loop_count
@S1427: push_minmax
@S1443: push_src
@S1444: push_dst
@S1456: push_ret
@S1457: pop_minmax
@S1476: pop_src
@S1477: pop_dst
@S1505: pop_ret
@S1506: push_lcl_depth
@S1507: push_pop_lcl_acc_stash
@S1510: push_pop_word_count
@S1511: frame_size
@S1512: minimax_retp
@S1513: stack_size
@S1514: stackp
@S1515: stack0
@S1623: eos
@S1624: stack_endp
@S1625: minimax
@S1633: minmax_test_max
@S1640: minmax_max_won
@S1643: minmax_test_min
@S1650: minmax_min_won
@S1653: minmax_test_tie
@S1656: minmax_tie
@S1661: minmax_prepare_scan
@S1663: minmax_isMax
@S1671: minmax_loop1
@S1676: minmax_rd1
@S1701: minmax_empty_cell1
@S1702: minmax_wr1
@S1716: minmax_not_best0
@S1721: minmax_undo_move0
@S1722: minmax_loop1_end
@S1727: minmax_not_isMax
@S1735: minmax_loop2
@S1742: minmax_rd2
@S1745: minmax_empty_cell2
@S1746: minmax_wr2
@S1757: minmax_best2
@S1761: minmax_not_best2
@S1764: minmax_undo_move2
@S1765: minmax_loop2_end
@S1772: minmax_exit
@S1776: minmax_ret
@S1777: minmax_lcl_isMax
@S2000: minmax_lcl_score
@S2001: minmax_lcl_next_cell
@S2002: minmax_lcl_loop_cnt
@S2003: minmax_lcl_best
@S2004: minmax_lcl_undo_move
@S2005: minmax_lcl_data_end
@S2006: mm_lcl_ret_val
@S2007: findBestMove
@S2027: fBM_fetch_cell
@S2032: fBM_try_move
@S2033: fBM_set_cell
@S2041: fBM_clear_cell
@S2051: fBM_next_loop
@S2063: fBM_ret
@S2064: fBM_lcl_best_value
@S2065: fBM_lcl_best_move
@S2066: fBM_lcl_loop_count
@S2067: fBM_lcl_current_cell
@S2070: fBM_lcl_tmp_score
@S2071: unit_test_main
@S2077: msgp
@S2100: msg
@S2134: draw_str
@S2136: ds_loop
@S2144: ds_get_char
@S2150: ds_test_str_end
@S2156: ds_ret
@S2157: ds_lcl_charp
@S2160: ds_argx
@S2161: ds_argy
@S2162: SixteenSegmentFlexop
@S2163: SixteenSegmentFlexo
@S2163: flexo_ucase
@S2263: seg_tab_startp
@S2264: seg00x
@S2265: seg00y
@S2266: seg00d
@S2267: seg01x
@S2270: seg01y
@S2271: seg01d
@S2272: seg02x
@S2273: seg02y
@S2274: seg02d
@S2275: seg03x
@S2276: seg03y
@S2277: seg03d
@S2300: seg04x
@S2301: seg04y
@S2302: seg04d
@S2303: seg05x
@S2304: seg05y
@S2305: seg05d
@S2306: seg06x
@S2307: seg06y
@S2310: seg06d
@S2311: seg07x
@S2312: seg07y
@S2313: seg07d
@S2314: seg08x
@S2315: seg08y
@S2316: seg08d
@S2317: seg09x
@S2320: seg09y
@S2321: seg09d
@S2322: seg10x
@S2323: seg10y
@S2324: seg10d
@S2325: seg11x
@S2326: seg11y
@S2327: seg11d
@S2330: seg12x
@S2331: seg12y
@S2332: seg12d
@S2333: seg13x
@S2334: seg13y
@S2335: seg13d
@S2336: seg14x
@S2337: seg14y
@S2340: seg14d
@S2341: seg15x
@S2342: seg15y
@S2343: seg15d
@S2344: seg_tab_endp
@S2345: char_spacing
@S2346: draw_16seg_char
@S2351: d16c_rd
@S2363: d16s_loop
@S2367: d16s_loop_continue
@S2406: d16c_draw_seg
@S2406: d16c_read_seg_taby
@S2411: d16c_read_seg_tabx
@S2413: d16c_read_seg_tabdxy
@S2415: d16c_ret
@S2416: d16c_argx
@S2417: d16c_argy
@S2420: d16c_lcl_seg_map
@S2421: d16c_lcl_loop_cnt
@S1677: scope_vector
@S0677: scope_point
@S0001: XX
@S0002: Oh
@S-001: None
@S0060: WIDTH_16SEG
@S0110: HEIGHT_16SEG
@S0010: OFFSET_16SEG
@S7400: SPACING_16SEG
@S172267: DOWN_LEFT
@S5110: UP_RIGHT
@S30000: HORIZ_RIGHT
@S34110: UP_RIGHT_DIAG
@S24267: DOWN_RIGHT_DIAG
@S1000: P0x
@S11000: P0y
@S4000: P1x
@S11000: P1y
@S7000: P2x
@S11000: P2y
@S6400: P3x
@S4400: P3y
@S6000: P4x
@S0000: P4y
@S3000: P5x
@S0000: P5y
@S0000: P6x
@S0000: P6y
@S0400: P7x
@S4400: P7y
@S3400: P8x
@S4400: P8y
@E0061: print: "light gun hit at cell %d", 0o000201
@E0537: print: "light gun %o hit x=%o, y=%o, cell=%ao", 0o000544, 0o000542, 0o000543
@E0633: print: "User move to cell %d; Table-driven move to cell offset %d / 3, ts 0o%o 0o%ao", 0o000635, 0o000636, 0o000632
@E0717: exec: print_experiment(cm, cb, "move game board player %d to cell %d, function 0o%o to gb offset 0o%o", ("player", "lcl_cell_for_move", "apm_fetch_icon_fn", "apm_store_move"), 0)
@E0723: print: "APM_Panic Halt: not dot, cross or naught in auto_play_move: lcl_apm_cell_state=0o%o", 0o000725
@E1017: print: "naught win"
@E1022: print: "cross win"
@E1035: print: "game tie"
@E1160: print: "panic stop"
@E1703: exec: print_experiment(cm, cb, "Trying  game piece %d to cell %d, count %d, isMax==True", ("player", "minmax_lcl_next_cell", "minmax_lcl_loop_cnt"), "push_lcl_depth")
@E2033: print: "fBM: try  empty cell %d, player=%d", 0o002067, 0o001172
@E2050: print: "fBM new Best Move: score %d, cell %d, loop: %d", 0o002070, 0o002067, 0o002066
@E2063: print: "fBM findBestMove for player %d returns move to cell %ad, score=%d", 0o001172, 0o002064
@N0002:  draw a point on all scopes
@N0040:  call the init subroutine
@N0041:  branch to main display refresh loop
@N0042:  constants
@N0044:  close to the edge of the scope screen
@N0047:  negative value means "game over"
@N0051:  check to see if this user move ended the game
@N0052:  if which_player is not zero, then the game has ended
@N0055:  negative means no more moves
@N0057:  convert -0 (cell zero) into +1 before the next CP test, then discard the result
@N0061:  do something with the light gun hit!  ; this call is for person-vs-computer play
@N0062:  put -1 in the mailbox to indicate Empty
@N0063:  mark the mailbox as empty
@N0065:  the game_over flag starts set to zero by init_game_board
@N0066:  But when the game is over, we set it to -1
@N0070:  two horizontal lines first
@N0100:  segment count should be negative, ie, we will incr the value until positive
@N0106:  two vertical lines next
@N0115:  segment count should be negative, ie, we will incr the value until positive
@N0123:  nine passes; var should be 8; loop count is negative
@N0145:  draw the X, O or dot; this call may have a side-effect of seeing a light-gun hit
@N0146:  increment pointers and loop count for the next pass
@N0161:  see definition for this number
@N0162:  clear the sign bit in case of "Game Over"
@N0165:  set the location to draw a string
@N0171:  get the pointer to the string into ACC
@N0172:  "print" the string on the screen
@N0173:  draw the symbol to call for a game reset
@N0174:  return from the 'board display' subroutine
@N0175:  count the number of moves
@N0176:  ephemeral loop state variables
@N0201:  used to pass light-gun hits back from the drawing routine.  Negative means "no hit"
@N0202:  used only in top-level routines for drawing the game board
@N0203:  Arguments to pass into routines
@N0205:  pointer to x_addr
@N0211:  The var, less the sign bit, is used to index player_icon_table below
@N0212:  These two constants control where the X or O indicator lands on the screen
@N0216:  The table is a pointer to subroutine entry points
@N0221: dct3:       .word draw_tie
@N0227:             .flexl "PLAYER X"
@N0240:             .flexl "PLAYER O"
@N0251:             .flexl "X WIN"
@N0257:             .flexl "O WIN"
@N0265:             .flexl "DRAW"
@N0272:  whether the cell contains a dot, a naught or a cross
@N0273:  Game Board State
@N0326:  save the return address
@N0330:  shift from 0-15 axis to -8 to +7
@N0331:  multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0332:  initialize vector gen
@N0334:  shift from 0-15 axis to -8 to +7
@N0336:  re-fetch the next x_arg
@N0337:  multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0340:  Draw a segment with x=ACC
@N0342:  increment the segment counter
@N0345:  save the return address
@N0347:  shift from 0-15 axis to -8 to +7
@N0350:  multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0351:  initialize vector gen with the y-coord in ACC
@N0353:  shift from 0-15 axis to -8 to +7
@N0354:  gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0355:  Draw a segment with x=ACC
@N0357:  increment the segment counter
@N0362:  save return address
@N0363:  test to see if there's another move allowed
@N0364:  if the var is negative, we're done playing
@N0365:  assuming the game's not over, we continue to draw
@N0371:  multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0372:  initialize point gen with the y-coord in ACC
@N0376:  shift from 0-15 axis to -8 to +7
@N0377:  gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0400:  Draw a pont with x=ACC
@N0401:  read the light gun
@N0402:  call a subroutine to handle the light gun.  The gun number is in ACC
@N0404:  args are passed as addresses
@N0410:  shift from 0-15 axis to -8 to +7
@N0411:  multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0412:  initialize vector gen with the y-coord in ACC
@N0416:  shift from 0-15 axis to -8 to +7
@N0417:  gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0420:  Draw a segment with x=ACC
@N0421:  Draw a segment with x=ACC
@N0422:  Draw a segment with x=ACC
@N0423:  Draw a segment with x=ACC
@N0425:  args are passed as addresses
@N0431:  shift from 0-15 axis to -8 to +7
@N0432:  multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0433:  initialize vector gen with the y-coord in ACC
@N0437:  shift from 0-15 axis to -8 to +7; plus an offset
@N0440:  gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0441:  Draw a segment with x=ACC
@N0442:  Draw a segment with x=ACC
@N0443:  shift the x-pos two cells right
@N0444:  Draw a segment with x=ACC
@N0445:  Draw a segment with x=ACC
@N0447:  args are passed as addresses
@N0453:  shift from 0-15 axis to -8 to +7
@N0454:  multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0455:  initialize vector gen with the y-coord in ACC
@N0461:  shift from 0-15 axis to -8 to +7
@N0462:  gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0463:  Draw a segment with x=ACC
@N0464:  Draw a segment with x=ACC
@N0465:           rc diag_dn_right_seg  ; Draw a segment with x=ACC
@N0466:  args are passed as addresses
@N0472:  shift from 0-15 axis to -8 to +7
@N0473:  multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0474:  initialize vector gen with the y-coord in ACC
@N0500:  shift from 0-15 axis to -8 to +7
@N0501:  gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0502:  Draw a segment with x=ACC
@N0503:  Draw a segment with x=ACC
@N0506:  put the point at game-board coord (1, 1)
@N0510:  initialize point gen with the y-coord in ACC
@N0511:  Draw a pont with x=ACC
@N0512:  read the light gun
@N0513:  call a subroutine to handle the light gun.
@N0515:  The light gun number is passed to this routine in ACC
@N0521:  load the x value of the cell's address in the grid
@N0522:  divide the cell x address by four to get 1, 2, or 3
@N0523:  change from one-base to zero-base
@N0525:  repeat the process for the y coordinate
@N0527:  load the y value of the cell's address in the grid
@N0530:  divide the cell y address by four to get 1, 2, or 3
@N0531:  invert to get negative number
@N0532:  change from one-base to zero-base and invert order
@N0534:  multiply y by three, i.e., double then add address
@N0536:  add x to get the cell number in the range 0-8
@N0537:  sp alternate_play_cell   ; do something with the light gun hit!; this call is for two-person play
@N0540:  test to see if it's Game Over
@N0542:  temp vars for figuring the cell number in light_gun_cell_hit
@N0545:  are the only ones with dots in them, and that's all the light gun can see
@N0546:  figure the pointer to the first cell draw function in game table
@N0547:   thats table_start + 3*cwll_num + 2
@N0550:  multiply cell number by three for a table offset
@N0554:  figure out what the new cell should be
@N0557:  ACC should now contain the address of the X or O display routine
@N0560:  store the display routine to the game state table
@N0561:  now switch to the other player for the next move
@N0562:  xor a 1 into the LSB; i.e. 0->1 or 1->0
@N0566:  from the mailbox
@N0567:  fetch the cell number
@N0570:  figure the pointer to the first cell draw function in game table
@N0571:   thats table_start + 3*cell_num + 2
@N0572:  multiply cell number by three for a table offset
@N0576:  figure out what the new cell should be
@N0601:  ACC should now contain the address of the X or O display routine
@N0602:  store the display routine to the game state table
@N0603:  check to see if this user move ended the game
@N0604:  negative means no more moves
@N0605:  by updating the icon on the game board.
@N0606:  test if this is Move Zero, i.e., the first user move
@N0607:  branch for first move, fall through for subsequent moves
@N0617:  AC contains the cell number of the first human move
@N0620:  stash the arg
@N0624:  fetch the offset of the computer move that will be used to respond
@N0631:  this is wired to have the machine move Naught
@N0632:  update the game state table
@N0633:  no-op for Print
@N0637:  set up to call findBestMove
@N0641:  the game piece is offset three from the table start
@N0651:  test if it's a Dot
@N0656:  store -1 for "unplayed"
@N0660:  retrieve the cell state
@N0661:  test if it's an X
@N0665:  load the value for a Naught
@N0670:  test if it's an X
@N0673:  huh, it's not a dot, cross or naught
@N0674:  load value for a cross
@N0675:  fall through to finish the copy step
@N0676:  step the destination once
@N0677:  step the source three times
@N0703:  around the loop again
@N0704:  human player wired as Cross, the computer plays Nought
@N0710:  return the cell number for the Best Move in ACC
@N0712:  multiply cell number by three
@N0714:  point to cell state in game board table
@N0717:  this address should be dynamically set, not fixed to "naught"
@N0721:  for debug
@N0727:      or -0 if it's 'game over']
@N0730:  set up the outer loop
@N0732:  prepare pointers into the analysis table
@N0736:  initialize with negative zero to simplify zero-detect later
@N0737:  count all the unplayed cells
@N0740:  set up the inner loop
@N0742:  load the starting cell number from the table
@N0747:  move to the gb_state val in gb table
@N0750:  pointer to first entry for this try in the gb table
@N0755:  fetch whatever is in this cell
@N0757:  test if it's a Dot
@N0765:  retrieve the cell state
@N0766:  test if it's an X
@N0774:  test if it's an X
@N1001:  move to next cell in the inner loop
@N1002:  add whatever the analysis table says is the increment
@N1005:  end of inner loop
@N1006:  test to see if there's a winner
@N1015:  02 with the sign bit
@N1016:  mark the game as "over" and a Win
@N1021:  mark the game as "over" and a Win
@N1023:  now move to next entry in outer loop
@N1031:  .print "unplayed cells=0d%d", lcl_total_dots
@N1032:  negative zero means its a tie (i.e., zero dots found)
@N1033:  so if it's not negative, we're done
@N1034:  table offset 04 with the sign bit
@N1035:  mark the game as "over" and a Draw
@N1037:  local variables
@N1047:  static addresses
@N1052:  or diagonal possible win combinations.
@N1053:  start cell  ; horizontal cells
@N1054:  increment
@N1055:  start cell
@N1056:  increment
@N1057:  start cell
@N1060:  increment
@N1061:  start cell  ; vertical cells
@N1062:  increment
@N1063:  start cell
@N1064:  increment
@N1065:  start cell
@N1066:  increment
@N1067:  start cell  ; up-right diagonal
@N1070:  increment
@N1071:  start cell  ; up-left diagonal
@N1072:  increment
@N1073:  directly index the game state table.
@N1074:   0
@N1075:   1
@N1076:   2
@N1077:   3
@N1100:   4
@N1101:   5
@N1102:   6
@N1103:   7
@N1104:   8
@N1105:  Initialize the game state
@N1106:  Reset the Move Counter to Zero
@N1110:  calculate the offset into the game state table for this cell
@N1111:  offset to third table entry
@N1112:  store the pointer to the first entry
@N1113:  nine passes; var should be 8; loop count is negative
@N1115:  fetch the address to use for the initial function pointer for each cell
@N1116:  set a table entry to the default pointer
@N1117:  advance the pointer to the next entry
@N1123:  around the loop until we've hit all nine entries
@N1126:  clear the "game over" flag
@N1127: ;;;;;
@N1132:  Constants
@N1143:  loop counter for 12 iterations
@N1145:  decimal value of screen coord corresponding to two cells in width
@N1146:  two plus sign bit
@N1147:  two plus sign bit
@N1150:  three plus sign bit
@N1151:  +32 in the top half of the word
@N1152:  +32 in the bottom half of the word
@N1157:  ---------------------------------------
@N1161:  Constants
@N1162:  for a loop of three
@N1165:  for a loop of nine passes
@N1167:  BigNum
@N1172: Default state to start the game: player = 'x', opponent = 'o';
@N1174:  nine words per each boar layouts
@N1175:  set the count to do just one board
@N1176:    6  7  8
@N1177:  0
@N1202:  3
@N1205:  6
@N1210:  0
@N1213:  3
@N1216:  6
@N1221:  0
@N1224:  3
@N1227:  6
@N1232:  0
@N1235:  3
@N1240:  6
@N1243:  0
@N1246:  3
@N1251:  6
@N1254:  0
@N1257:  3
@N1262:  6
@N1265:  board2 to scan all the games
@N1266:  are no empty cells
@N1270:  store a pointer to the start of the game board
@N1273:  read the cell under test; If the cell is empty, there are move moves, we can stop
@N1274:  branch if the cell is empty, ie, neither X or O.
@N1275:  non-empty cell; prepare to return positive
@N1277:  update the pointer to the next cell
@N1300:  increment the loop count
@N1301:  branch if not done yet
@N1302:  no empty cells; return -1
@N1304:  return One for more moves left
@N1306:  loop counter
@N1307:  return code
@N1310:  a winner is complete.
@N1311:  add base pointer to the board array to offset
@N1313:  read the first element
@N1315:  remember what's in the first cell
@N1316:  calculate address for second cell by adding stride
@N1321:  read the second element
@N1322:  compare it to the first element read
@N1324:  negative zero means they're the same; so test the third cell
@N1325:  otherwise, bail out
@N1334:  negative zero means they're the same
@N1336:  return negative one or two
@N1341:  fall through to equ3_ret
@N1342:  local vars and arguments
@N1344:  This routine takes no input arguments
@N1345:  check rows for a win; stride of three, starting at zero
@N1346:  set the equ3 stride to one, i.e., three adjacent horizontal cells
@N1347:  set the equ3 starting cell to row zero
@N1351:  initialize loop counter; prepare to go around the loop three times
@N1353:  place offset of first cell to check in AC
@N1354:  check one row
@N1355:  match -- figure out who won
@N1356:  next row is three cells forward
@N1357:  compute the first cell of the next row
@N1362:  branch if there's another row to check, fall through if we've checked three rows
@N1363:  check cols for a win; stride of three, starting at zero
@N1364:  set the equ3 stride to three, i.e., three adjacent vertical cells
@N1365:  set the equ3 starting cell to col zero
@N1367:  initialize loop counter; prepare to go around the loop three times
@N1371:  place offset of first cell to check in AC
@N1372:  check one row
@N1373:  match -- figure out who won
@N1374:  next col is one cell forward
@N1375:  compute the first cell of the next row
@N1400:  branch if there's another row to check, fall through if we've checked three rows
@N1401:  there are only two diagonals, no loops here; just test 0, 4, 8 then 2, 4, 6
@N1402:  set the equ3 stride to four, i.e., 0, 4, 8 diagonal cells
@N1403:  set the equ3 starting cell to col zero
@N1404:  check one row
@N1405:  match -- figure out who won
@N1407:  set the equ3 stride to two, i.e., 2, 4, 6 diagonal cells
@N1410:  set the equ3 starting cell to cell 2
@N1411:  check one row
@N1412:  match -- figure out who won
@N1413:  nobody won; return 0
@N1415:  test to see if the current Player is the one that was found to have three winning cells
@N1420:  score an opponent win as -10
@N1422:  score a Player win as +10
@N1424:  .print "  Evaluate_Score returns %ad"
@N1427:  pointer by the size of the frame
@N1430:  stash the AC
@N1432:  test to be sure we're not running over the allocated space
@N1433:  branch if overflow
@N1436:  initialize the loop counter
@N1437:  fetch the "source pointer"
@N1441:  fetch the "destination pointer"
@N1443:  filled in above
@N1450:  around the loop until the entire stack frame is copied
@N1451:  update the stack pointer for next time
@N1455:  retrieve the AC
@N1456:  subroutine return
@N1460:  stash the AC
@N1461:  back up the stack pointer
@N1471:  initialize the loop counter
@N1472:  fetch the "destination pointer"
@N1474:  fetch the "source pointer"
@N1476:  filled in above
@N1503:  around the loop until the entire stack frame is copied
@N1504:  retrieve the AC
@N1510:  this var is the copy-word counter for push and pop
@N1511:  calculate the size of a single push on the stack
@N1512:  Here's the address of the minimax local data to be pushed onto stack
@N1513:  I've allocated ten frames below for use of the stack
@N1515:  frame 0
@N1524:  frame 1
@N1533:  frame 2
@N1542:  frame 3
@N1551:  frame 4
@N1560:  frame 5
@N1567:  frame 6
@N1576:  frame 7
@N1605:  frame 8
@N1614:  frame 9
@N1623:  end of stack
@N1625:  Min is -1, passed in AC
@N1627:  store state on "the stack"
@N1630:  no-op
@N1631:  figure out how we're doing
@N1633:  test if Maximizer has won
@N1635:  test to see if score is +10
@N1636:  branch if yes
@N1640:  .print "Maximizer Won, score %d", minmax_lcl_score
@N1641:  set up the return code
@N1642:  all done
@N1645:  test to see if score is -10
@N1646:  branch if yes
@N1650:  .print "Minimizer Won, score %d", minmax_lcl_score
@N1651:  set up the return code
@N1652:  all done
@N1653:  test if there are more moves to go
@N1654:  Negative means "no more empty cells"
@N1657:  set up the return code
@N1660:  bail out
@N1662:  branch if isMax == False
@N1663:  ======== This section is "isMax == True" =============
@N1664:  initialize to Most Negative
@N1665:  prepare to scan all cells starting w/zero
@N1667:  loop nine times
@N1671:  get the base board ptr to read the next cell
@N1675:  this is only used _after_ the recursive call, and will need to be restored from stack
@N1676:  fetch the next cell
@N1677:  continue if the cell is empty
@N1700:  go to the next loop step if the cell is not empty
@N1701:  fetch the Player marker
@N1702:  ... and write it into the cell
@N1703:  no-op
@N1704:  load negative zero, i.e. all ones
@N1705:  Sum Digits, i.e., xor, will reverse isMax
@N1706:  load -1 to signal isMax should be False
@N1707:  .exec print_indent(cm, "starting recursive call to minimax: isMax==True-branch, cell at %d, depth: %d, loop_count: %d" % (cm.rd(rl("minmax_lcl_next_cell")), cm.rd(rl("push_lcl_depth")), cm.rd(rl("minmax_lcl_loop_cnt"))), rl("push_lcl_depth"))
@N1710:  push_lcl_depth       ; reduce the score by the calling depth
@N1711:  very local storage for the minimax return call
@N1712:  determine if this was the "best" score so far
@N1713:  branch if we've seen a better score already
@N1714:  save this result as the Best Score So Far
@N1716:  remember that modified instruction addresses are effectively local variables, so restore this one from the stack
@N1717: .exec print_experiment(cm, cb, "Undoing game piece %d in cell %d at 0o%o, isMax==True", ("player", "minmax_lcl_next_cell", "minmax_lcl_undo_move"), "push_lcl_depth")
@N1720:  undo the trial move
@N1722:  get ready for the next cell iteration
@N1724:  go around again if the loop cnt is not exhausted
@N1725:  return the best score found in AC
@N1726:  all done with this pass of isMax == True
@N1727:  ======== This section is "isMax == False" =============
@N1730:  initialize to Most Positive
@N1731:  prepare to scan all cells starting w/zero
@N1733:  loop nine times
@N1735:  get the base board ptr to read the next cell
@N1741:  store this address on the 'stack' for now
@N1742:  fetch the next cell
@N1743:  continue if the cell is empty
@N1744:  go to the next loop step if the cell is not empty
@N1745:  fetch the Opponent marker
@N1746:  ... and write it into the cell
@N1747:  no-op
@N1750:  load -1 to signal isMax should be True
@N1751:  .exec print_indent(cm, "starting recursive call to minimax: isMax==False-branch, cell at %d, depth: %d, loop_count: %d" % (cm.rd(rl("minmax_lcl_next_cell")), cm.rd(rl("push_lcl_depth")), cm.rd(rl("minmax_lcl_loop_cnt"))), rl("push_lcl_depth"))
@N1752:   push_lcl_depth       ; increase the (negative) score by the calling depth
@N1753:  very local storage for the minimax return value
@N1754:  determine if this was the "best" score so far
@N1756:  branch if we've seen a better score already
@N1757:  save this result as the Best Score So Far
@N1761:  remember that modified instruction addresses are effectively local variables, so restore this one from the stack
@N1762:  .exec print_experiment(cm, cb, "Undoing game piece %d in cell %d at 0o%o, isMax==False", ("player", "minmax_lcl_next_cell", "minmax_lcl_undo_move"), "push_lcl_depth")
@N1763:  undo the trial move
@N1765:  get ready for the next cell iteration
@N1767:  go around again if the loop cnt is not exhausted
@N1770:  return the best score found in AC
@N1771:  all done with this pass of isMax == False
@N1772:  no-op for .exec
@N1773:  this is a no-op
@N1774:  .exec print_board(cm, rl("boardp"), rl("push_lcl_depth"), rl("player") )
@N1775:  note that we stash and retrieve the AC during PoP
@N1777:  a "stack frame" must store from minmax_ret to minmax_lcl_data_end
@N2005:  this is just a marker for the end of data to be pushed
@N2007:  doing what, we reverse the "player" bit temporarily.
@N2010:  switch the display to the machine player
@N2011:  xor a 1 into the LSB; i.e. 0->1 or 1->0
@N2013:  initialize the 'best stuff' detector
@N2015:  .print "Starting findBestMove, player=%d, opponent=%d", player, opponent
@N2023:  we always start from cell zero`
@N2027:  read the current cell into AC
@N2030:  if the cell is empty, go on to try out a move
@N2031:  take a pass on this non-empty cell, go on to the next one
@N2033:  try out a move on this cell
@N2034:  be careful to not trigger unintended recursion...
@N2035:  tell Minimax to try for a Min score on this cell
@N2036:  call the optimizer; best-score comes back in AC
@N2037:  stash the score for now
@N2040:  undo the trial move, then evaluate the results of minimax
@N2042:  compare the new result with previous best
@N2043:  branch if the old one was better; i.e., skip updating the eval_score_players
@N2046:  save the New Best Score
@N2047:  and remember how we got here, i.e., which cell we tried
@N2056:  go 'round the loop again
@N2057:  now switch the display back to the original (human) player
@N2060:  xor a 1 into the LSB; i.e. 0->1 or 1->0
@N2062:  when we're done with the loop, return the best move found (not the score, the cell that played best)
@N2064:  best score found so far
@N2065:  remember the move that resulted in the best score
@N2071:   */
@N2076: si 0
@N2134:  ds_argx and ds_argy give the initial (x, y) location
@N2135:  save the character pointer passed in the ACC
@N2142:  walk the string from start to finish
@N2144:  fetch the next character in the string
@N2145:  actually draw the character!
@N2146:  prepare for next char in loop
@N2151:  test for a negative number as the marker for the string end; branch out if done
@N2157:  pointer to the next character to display
@N2162:  segments should be lit for each symbol.
@N2163:  /* # */
@N2164:  /* # */
@N2165:  /* E */
@N2166:  /* 8 */
@N2167:  /* # */
@N2170:  /* _ */
@N2171:  /* A */
@N2172:  /* 3 */
@N2173:  /* (space) */
@N2174:  /* : */
@N2175:  /* S */
@N2176:  /* 4 */
@N2177:  /* I */
@N2200:  /* / */
@N2201:  /* U */
@N2202:  /* 2 */
@N2203:  /* (del) */
@N2204:  /* ) */
@N2205:  /* D */
@N2206:  /* 5 */
@N2207:  /* R */
@N2210:  /* 1 */
@N2211:  /* J */
@N2212:  /* 7 */
@N2213:  /* N */
@N2214:  /* ( */
@N2215:  /* F */
@N2216:  /* 6 */
@N2217:  /* C */
@N2220:  /* - */
@N2221:  /* K */
@N2222:  /* # */
@N2223:  /* T */
@N2224:  /* # */
@N2225:  /* Z */
@N2226:  /* (del) */
@N2227:  /* L */
@N2230:  /* (space) */
@N2231:  /* W */
@N2232:  /* # */
@N2233:  /* H */
@N2234:  /* (space) */
@N2235:  /* Y */
@N2236:  /* # */
@N2237:  /* P */
@N2240:  /* # */
@N2241:  /* Q */
@N2242:  /* # */
@N2243:  /* O */
@N2244:  /* (del) */
@N2245:  /* B */
@N2246:  /* # */
@N2247:  /* G */
@N2250:  /* # */
@N2251:  /* 9 */
@N2252:  /* # */
@N2253:  /* M */
@N2254:  /* (del) */
@N2255:  /* X */
@N2256:  /* # */
@N2257:  /* V */
@N2260:  /* (del) */
@N2261:  /* 0 */
@N2262:  /* (del) */
@N2263:  // segment in the 16-segment display character.
@N2264:    {P0, P1}
@N2267:    {P1, P2},
@N2272:    {P2, P3},
@N2275:    {P3, P4},
@N2300:    {P4, P5},
@N2303:    {P5, P6},
@N2306:    {P6, P7},
@N2311:    {P7, P0},
@N2314:    {P0, P8},
@N2317:    {P1, P8},
@N2322:    {P2, P8},
@N2325:    {P3, P8},
@N2330:    {P4, P8},
@N2333:    {P5, P8},
@N2336:    {P6, P8},
@N2341:    {P7, P8},
@N2346:  Character position is given by the args d16c_argx, d16c_argy.
@N2347:  add the table start addr to the offset in ACC
@N2351:  fetch the bit map
@N2353:  prep for 16 times around the loop
@N2355:  walk the segment table back to front
@N2356:  first table entry
@N2357:         td tmp_tabx
@N2360:  second table entry
@N2361:         td tmp_taby
@N2362:  third table entry
@N2363:  no op
@N2364:         ca 0
@N2365:  end of debug hack
@N2366:  branch if most significant bit is on
@N2370:  shift AC left by one bit
@N2375:         td tmp_tabx
@N2400:         td tmp_taby
@N2405:  bail out when count exhausted
@N2406:  the SI uses the AC to set Y coord
@N2410:  initialize vector gen with the y-coord in ACC
@N2411:  the RC uses AC to set X coord and mem address for the vector length
@N2415: ; Return from draw_16seg_char
@N2422:  *********************************************************************************************************/
