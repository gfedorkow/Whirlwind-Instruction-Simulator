
; *** Core Image ***
%File: tic-tac-toe.ww
%TapeID: 
@C0000: 0000000 0000001  None    None    None    None    None    None   
@C0040: 0075103 0074046 0000017 0000040 0073300 0062000 0074067 0101127 
@C0050: 0070046 0074725 0100210 0134000 0070056 0074064 0100200 0070046 
@C0060: 0074565 0104001 0040200 0074046 0104001 0041127 0074046 0050173 
@C0070: 0105131 0040201 0101134 0040203 0101131 0040202 0105141 0040206 
@C0100: 0074325 0101140 0040203 0130201 0070074 0105131 0040201 0101134 
@C0110: 0040202 0101131 0040203 0105141 0040206 0074344 0101140 0040202 
@C0120: 0130201 0070111 0105136 0040201 0100271 0040175 0110001 0040176 
@C0130: 0110001 0040177 0104001 0040200 0100175 0040204 0100176 0040205 
@C0140: 0100177 0044142 0100000 0044144 0074000 0100175 0111132 0040175 
@C0150: 0100176 0111132 0040176 0100177 0111132 0040177 0130201 0070134 
@C0160: 0100210 0175135 0110220 0044170 0104044 0042124 0104045 0042123 
@C0170: 0100000 0076077 0074504 0074000 0000000 0000000 0000000 0000000 
@C0200: 0177776 0000000 0000000 0000000 0000000 0000000 0000000 0000000 
@C0210: 0000000 0000007 0000001 0000211 0000212 0000216 0000403 0000424 
@C0220: 0000221 0000226 0000237 0000250 0000256 0000264 0000054 0000044 
@C0230: 0000006 0000052 0000002 0000024 0000010 0000072 0177776 0000054 
@C0240: 0000044 0000006 0000052 0000002 0000024 0000010 0000060 0177776 
@C0250: 0000072 0000010 0000046 0000014 0000030 0177776 0000060 0000010 
@C0260: 0000046 0000014 0000030 0177776 0000022 0000024 0000006 0000046 
@C0270: 0177776 0000272 0000004 0000014 0000361 0000010 0000014 0000361 
@C0300: 0000014 0000014 0000361 0000004 0000010 0000361 0000010 0000010 
@C0310: 0000361 0000014 0000010 0000361 0000004 0000004 0000361 0000010 
@C0320: 0000004 0000361 0000014 0000004 0000361 0050343 0100203 0115136 
@C0330: 0154014 0001677 0100202 0115136 0040202 0100202 0154014 0025147 
@C0340: 0130202 0130206 0070335 0074000 0050360 0100203 0115136 0154014 
@C0350: 0001677 0100202 0115136 0154014 0025150 0130203 0130206 0070345 
@C0360: 0074000 0050402 0100210 0070402 0100205 0044366 0100000 0115136 
@C0370: 0154014 0000677 0100204 0044374 0100000 0115136 0154014 0024000 
@C0400: 0014000 0070514 0074000 0050423 0100205 0044406 0100000 0115136 
@C0410: 0154014 0001677 0100204 0044414 0100000 0115136 0154014 0025151 
@C0420: 0025152 0025154 0025153 0074000 0050445 0100205 0044427 0100000 
@C0430: 0115136 0154014 0001677 0100204 0044435 0100000 0115137 0154014 
@C0440: 0025151 0025153 0111143 0025154 0025152 0074000 0050464 0100205 
@C0450: 0044451 0100000 0115136 0154014 0001677 0100204 0044457 0100000 
@C0460: 0115136 0154014 0025151 0025154 0074000 0050503 0100205 0044470 
@C0470: 0100000 0115136 0154014 0001677 0100204 0044476 0100000 0115136 
@C0500: 0154014 0025152 0025153 0074000 0050513 0105135 0154014 0000677 
@C0510: 0024000 0014000 0071103 0074000 0050540 0040543 0100204 0044520 
@C0520: 0100000 0160002 0114001 0040541 0100205 0044526 0100000 0160002 
@C0530: 0031130 0111132 0040542 0155001 0110542 0110541 0040200 0074725 
@C0540: 0074000 0000000 0000000 0000000 0050563 0040564 0155001 0110564 
@C0550: 0110271 0111131 0044557 0100215 0110210 0044556 0100000 0040000 
@C0560: 0100210 0030001 0040210 0074000 0000000 0050613 0040614 0155001 
@C0570: 0110614 0110271 0111131 0044600 0100215 0110210 0044577 0100000 
@C0600: 0040000 0074725 0070612 0100174 0134000 0070610 0074635 0074612 
@C0610: 0100614 0074615 0130174 0074000 0000000 0050632 0040633 0101071 
@C0620: 0110633 0044622 0100000 0040634 0110271 0111157 0044630 0100217 
@C0630: 0040000 0030000 0074000 0000000 0000000 0050720 0100271 0111131 
@C0640: 0044645 0101263 0044673 0105136 0040722 0100000 0040723 0135045 
@C0650: 0134000 0070653 0074656 0131041 0104001 0074673 0100723 0135047 
@C0660: 0134000 0070663 0074665 0101167 0074673 0100723 0135046 0134000 
@C0670: 0070672 0074721 0101166 0040000 0130673 0130645 0130645 0130645 
@C0700: 0130722 0070645 0101167 0041170 0101166 0041171 0076005 0040724 
@C0710: 0154001 0110724 0111157 0110271 0044716 0100217 0040000 0030000 
@C0720: 0074000 0074000 0000000 0000000 0000000 0051034 0105135 0041035 
@C0730: 0101050 0044740 0110001 0045000 0104000 0041042 0105131 0041036 
@C0740: 0100000 0041043 0155001 0111043 0110271 0111131 0044753 0100000 
@C0750: 0041037 0041040 0041041 0100000 0041044 0135045 0134000 0070761 
@C0760: 0074763 0131041 0131042 0101044 0135047 0134000 0070770 0074771 
@C0770: 0131037 0101044 0135046 0134000 0070776 0074777 0131040 0100753 
@C1000: 0110000 0040753 0131036 0070753 0101132 0135037 0071013 0101132 
@C1010: 0135040 0071016 0075021 0101145 0040210 0075021 0101144 0040210 
@C1020: 0075021 0130740 0130740 0131000 0131000 0131035 0070736 0101042 
@C1030: 0071032 0075034 0101146 0040210 0074000 0000000 0000000 0000000 
@C1040: 0000000 0000000 0000000 0000000 0000000 0000361 0000403 0000424 
@C1050: 0001051 0000000 0000003 0000003 0000003 0000006 0000003 0000000 
@C1060: 0000011 0000001 0000011 0000002 0000011 0000000 0000014 0000002 
@C1070: 0000006 0001072 0000014 0000000 0000014 0000000 0000000 0000006 
@C1100: 0000014 0000003 0000014 0051125 0100000 0040174 0100271 0111131 
@C1110: 0045114 0105136 0040201 0101126 0040000 0101114 0111132 0041114 
@C1120: 0130201 0071113 0100000 0040210 0041127 0074000 0000361 0000000 
@C1130: 0177777 0000002 0000003 0000004 0000006 0000007 0000010 0000011 
@C1140: 0000012 0000013 0000014 0020000 0100002 0100003 0100004 0076000 
@C1150: 0000174 0076174 0100200 0076200 0100174 0100000 0000000 0000002 
@C1160: 0177775 0000003 0000004 0177767 0000012 0001750 0000001 0000002 
@C1170: 0000001 0000002 0000011 0000001 0001175 0000001 0000002 0000002 
@C1200: 0000001 0000002 0000001 0177776 0177776 0177776 0177776 0000002 
@C1210: 0000002 0000001 0000002 0000001 0177776 0177776 0177776 0177776 
@C1220: 0000002 0000002 0000001 0000001 0000001 0000002 0177776 0177776 
@C1230: 0177776 0000002 0000001 0000001 0000002 0000001 0000002 0000002 
@C1240: 0177776 0177776 0000002 0000001 0000002 0000001 0000002 0000001 
@C1250: 0000002 0177776 0000002 0000001 0177776 0177776 0000002 0177776 
@C1260: 0177776 0177776 0177776 0001252 0051303 0101263 0045271 0101163 
@C1270: 0041304 0100000 0071302 0100001 0041305 0131271 0131304 0071271 
@C1300: 0104001 0075303 0100001 0074000 0000000 0000000 0051337 0111263 
@C1310: 0045311 0100000 0071336 0041341 0101311 0111340 0045317 0100000 
@C1320: 0115341 0134000 0071324 0075336 0101317 0111340 0045327 0100000 
@C1330: 0115341 0134000 0071334 0075336 0105341 0075337 0100001 0074000 
@C1340: 0000000 0000000 0051422 0100001 0041340 0100000 0041423 0101160 
@C1350: 0041424 0101423 0075306 0071413 0101161 0111423 0041423 0131424 
@C1360: 0071351 0101161 0041340 0100000 0041423 0101160 0041424 0101423 
@C1370: 0075306 0071413 0100001 0111423 0041423 0131424 0071367 0101162 
@C1400: 0041340 0100000 0075306 0071413 0101157 0041340 0101157 0075306 
@C1410: 0071413 0100000 0075422 0111170 0134000 0071420 0105164 0075422 
@C1420: 0101164 0075422 0074000 0000000 0000000 0051454 0041505 0101511 
@C1430: 0115504 0071155 0105507 0110001 0041506 0101510 0045441 0101512 
@C1440: 0045442 0100000 0040000 0131441 0131442 0131506 0071441 0101512 
@C1450: 0111507 0045512 0131504 0101505 0074000 0051503 0041505 0101512 
@C1460: 0115507 0045512 0101504 0114001 0041504 0105507 0110001 0041506 
@C1470: 0101510 0045475 0101512 0045474 0100000 0040000 0131474 0131475 
@C1500: 0131506 0071474 0101505 0074000 0000000 0000000 0000000 0000007 
@C1510: 0001774 0000012 0001513 0000000 0000000 0000000 0000000 0000000 
@C1520: 0000000 0000000 0000000 0000000 0000000 0000000 0000000 0000000 
@C1530: 0000000 0000000 0000000 0000000 0000000 0000000 0000000 0000000 
@C1540: 0000000 0000000 0000000 0000000 0000000 0000000 0000000 0000000 
@C1550: 0000000 0000000 0000000 0000000 0000000 0000000 0000000 0000000 
@C1560: 0000000 0000000 0000000 0000000 0000000 0000000 0000000 0000000 
@C1570: 0000000 0000000 0000000 0000000 0000000 0000000 0000000 0000000 
@C1600: 0000000 0000000 0000000 0000000 0000000 0000000 0000000 0000000 
@C1610: 0000000 0000000 0000000 0000000 0000000 0000000 0000000 0000000 
@C1620: 0000000 0000000 0001621 0051774 0041775 0075425 0030000 0075342 
@C1630: 0041776 0101776 0115164 0134000 0071636 0075641 0101776 0042001 
@C1640: 0075770 0101776 0111164 0134000 0071646 0075651 0101776 0042001 
@C1650: 0075770 0075264 0071654 0075657 0100000 0042001 0075770 0101775 
@C1660: 0071725 0105165 0042001 0100000 0041777 0101163 0042000 0101263 
@C1670: 0111777 0045674 0045700 0046002 0100000 0071677 0075720 0101170 
@C1700: 0040000 0030000 0104000 0031775 0104001 0075623 0114001 0042004 
@C1710: 0116001 0071714 0102004 0042001 0102002 0045717 0104001 0040000 
@C1720: 0131777 0132000 0071667 0102001 0075770 0101165 0042001 0100000 
@C1730: 0041777 0101163 0042000 0101263 0111777 0045740 0045744 0046002 
@C1740: 0100000 0071743 0075763 0101171 0040000 0030000 0100001 0075623 
@C1750: 0110001 0042004 0116001 0071755 0075757 0102004 0042001 0102002 
@C1760: 0045762 0104001 0040000 0131777 0132000 0071733 0102001 0075770 
@C1770: 0030000 0030000 0102001 0075455 0074000 0000000 0000000 0000000 
@C2000: 0000000 0000000 0000000 0000000 0000000 0052061 0100210 0030001 
@C2010: 0040210 0105165 0042062 0104001 0042063 0101163 0042064 0100000 
@C2020: 0042065 0101263 0046025 0046031 0046037 0100000 0072030 0076047 
@C2030: 0101170 0040000 0074067 0104001 0075623 0042066 0104001 0040000 
@C2040: 0102066 0116062 0072047 0102066 0042062 0102065 0042063 0132025 
@C2050: 0132031 0132037 0132065 0132064 0072025 0100210 0030001 0040210 
@C2060: 0102063 0074000 0000000 0000000 0000000 0000000 0000000 0104044 
@C2070: 0042123 0042124 0102075 0076077 0076067 0002076 0177776 0052121 
@C2100: 0046122 0102123 0042361 0102124 0042362 0102122 0046107 0100000 
@C2110: 0076311 0132122 0046113 0100000 0072121 0102123 0112310 0042123 
@C2120: 0076101 0074000 0000000 0000000 0000000 0002126 0125074 0125074 
@C2130: 0100363 0104377 0125074 0000060 0104317 0004077 0000000 0021000 
@C2140: 0104273 0104214 0021063 0042000 0000374 0104167 0177777 0040400 
@C2150: 0021077 0110263 0114307 0002014 0000174 0000017 0010714 0012000 
@C2160: 0100303 0104373 0000363 0104000 0112300 0125074 0021003 0125074 
@C2170: 0042063 0177777 0000360 0000000 0050314 0125074 0104314 0000000 
@C2200: 0104274 0125074 0104307 0125074 0010377 0125074 0000377 0177777 
@C2210: 0025077 0125074 0004373 0125074 0104277 0125074 0002714 0177777 
@C2220: 0052400 0125074 0042300 0177777 0042377 0177777 0002227 0001000 
@C2230: 0011000 0030000 0004000 0011000 0030000 0007000 0011000 0172267 
@C2240: 0006400 0004400 0172267 0003000 0000000 0030000 0000000 0000000 
@C2250: 0030000 0000000 0000000 0005110 0000400 0004400 0005110 0001000 
@C2260: 0011000 0024267 0004000 0011000 0172267 0003400 0004400 0034110 
@C2270: 0003400 0004400 0030000 0003400 0004400 0024267 0003400 0004400 
@C2300: 0172267 0000000 0000000 0034110 0000400 0004400 0030000 0002304 
@C2310: 0007400 0052360 0112125 0046314 0100000 0042363 0104042 0042364 
@C2320: 0102307 0046354 0110001 0046351 0110001 0046356 0100000 0000677 
@C2330: 0102363 0072351 0102363 0170001 0042363 0102354 0115161 0046354 
@C2340: 0102351 0115161 0046351 0102356 0115161 0046356 0132364 0072326 
@C2350: 0076360 0100000 0112362 0001677 0100000 0112361 0024000 0076332 
@C2360: 0074000 0000000 0000000 0000000 0000000  None    None    None   
@S0000: zero
@S0000: const_0
@S0001: one
@S0001: const_1
@S0040: main
@S0042: c_15
@S0043: c_32
@S0044: c_scope_edge
@S0045: c_msg_x_pos
@S0046: refresh_loop
@S0056: rl_continue_game
@S0064: set_game_over
@S0067: draw_game_board
@S0074: x_grid_loop
@S0111: y_grid_loop
@S0122: draw_game_state
@S0134: gb_loop
@S0134: gb_x_inst
@S0136: gb_y_inst
@S0140: gb_gs_inst
@S0142: ca_addr
@S0144: gb_state_sp
@S0160: draw_current_player
@S0170: dcp_ca_addr
@S0173: draw_game_board_ret
@S0174: move_number
@S0175: next_x_addr
@S0176: next_y_addr
@S0177: next_gb_state_addr
@S0200: light_gun_mailbox
@S0201: loop_count
@S0202: x_arg
@S0203: y_arg
@S0204: x_addr_arg
@S0205: y_addr_arg
@S0206: n_segments
@S0207: gb_state_arg
@S0210: which_player
@S0211: player_state_x_addr
@S0212: player_state_y_addr
@S0213: player_state_x_ptr
@S0214: player_state_y_ptr
@S0215: player_icon_table
@S0216: dct0
@S0217: dct1
@S0220: state_msg_tablep
@S0221: state_msg_table
@S0226: msg_cross_play
@S0237: msg_naught_play
@S0250: msg_x_win
@S0256: msg_o_win
@S0264: msg_draw
@S0271: gb_table_start
@S0272: gb0_x
@S0273: gb0_y
@S0274: gb0_state
@S0275: gb1_x
@S0276: gb1_y
@S0277: gb1_state
@S0300: gb2_x
@S0301: gb2_y
@S0302: gb2_state
@S0303: gb3_x
@S0304: gb3_y
@S0305: gb3_state
@S0306: gb4_x
@S0307: gb4_y
@S0310: gb4_state
@S0311: gb5_x
@S0312: gb5_y
@S0313: gb5_state
@S0314: gb6_x
@S0315: gb6_y
@S0316: gb6_state
@S0317: gb7_x
@S0320: gb7_y
@S0321: gb7_state
@S0322: gb8_x
@S0323: gb8_y
@S0324: gb8_state
@S0325: draw_x_line
@S0335: next_x_seg
@S0343: draw_x_line_ret
@S0344: draw_y_line
@S0345: next_y_seg
@S0360: draw_y_line_ret
@S0361: draw_dot
@S0366: dd_y_arg
@S0374: dd_x_arg
@S0402: draw_dot_ret
@S0403: draw_cross
@S0406: dc_y_arg
@S0414: dc_x_arg
@S0423: draw_cross_ret
@S0424: draw_naught
@S0427: dn_y_arg
@S0435: dn_x1_arg
@S0445: draw_naught_ret
@S0446: draw_win
@S0451: dw_y_arg
@S0457: dw_x_arg
@S0464: draw_win_ret
@S0465: draw_tie
@S0470: dt_y_arg
@S0476: dt_x_arg
@S0503: draw_tie_ret
@S0504: draw_reset_symbol
@S0513: draw_reset_symbol_ret
@S0514: light_gun_cell_hit
@S0520: lgh_x1_arg
@S0526: lgh_y1_arg
@S0540: light_gun_cell_hit_ret
@S0541: lcl_cell_x
@S0542: lcl_cell_y
@S0543: lcl_gun_num
@S0544: alternate_play_cell
@S0556: apc_ca0
@S0557: apc_table_ts
@S0563: alternate_play_cell_ret
@S0564: lcl_aplay_cell_num
@S0565: user_play_cell
@S0577: upc_ca0
@S0600: upc_table_ts
@S0610: upc_move_zero
@S0612: upc_cleanup
@S0613: user_play_cell_ret
@S0614: lcl_uplay_cell_num
@S0615: table_play_move
@S0622: tpm_fetch_move_table
@S0630: tpm_store_move
@S0632: table_play_move_ret
@S0633: lcl_tpm_user_move
@S0634: lcl_tpm_table_move
@S0635: auto_play_move
@S0645: apm_copy_src
@S0647: apm_test_dot
@S0653: apm_its_a_dot
@S0656: apm_test_naught
@S0663: apm_its_a_naught
@S0665: apm_test_cross
@S0672: apm_its_a_cross
@S0673: apm_copy_dst
@S0715: apm_fetch_icon_fn
@S0716: apm_store_move
@S0720: apm_ret
@S0721: apm_panic
@S0722: lcl_apm_copy_count
@S0723: lcl_apm_cell_state
@S0724: lcl_cell_for_move
@S0725: is_there_winner
@S0736: itw_outer_loop
@S0740: itw_st_ca
@S0753: itw_inner_loop
@S0753: itw_cell_ts
@S0755: test_dot
@S0761: its_a_dot
@S0763: test_naught
@S0770: its_a_naught
@S0771: test_cross
@S0776: its_a_cross
@S0777: itw_inner_loop_test_end
@S1000: itw_inc_gb
@S1013: naught_win
@S1016: cross_win
@S1021: itw_next_outer_loop
@S1032: its_a_tie
@S1034: is_there_winner_ret
@S1035: lcl_tb_loop_count
@S1036: lcl_cell_loop_count
@S1037: lcl_naught_count
@S1040: lcl_cross_count
@S1041: lcl_dot_count
@S1042: lcl_total_dots
@S1043: lcl_cell_number
@S1044: lcl_cell_state
@S1045: dot_fn_addr
@S1046: cross_fn_addr
@S1047: naught_fn_addr
@S1050: analysis_table_start
@S1051: analysis_table
@S1051: at0
@S1053: at1
@S1055: at2
@S1057: at3
@S1061: at4
@S1063: at5
@S1065: at6
@S1067: at7
@S1071: first_move_table_start
@S1072: first_move_table
@S1103: init_game_board
@S1113: igb_loop
@S1114: igb_table_ts
@S1125: init_game_board_ret
@S1126: lcl_init_val
@S1127: g_game_over
@S1130: const_0n
@S1131: const_2
@S1132: const_3
@S1133: const_4
@S1134: const_6
@S1135: const_7
@S1136: const_8
@S1137: const_9
@S1140: const_10
@S1141: const_11
@S1142: const_12
@S1143: const_2_cell
@S1144: const_x_win
@S1145: const_o_win
@S1146: const_draw
@S1147: horiz_line_seg
@S1150: vert_line_seg
@S1151: diag_up_right_seg
@S1152: diag_dn_left_seg
@S1153: diag_dn_right_seg
@S1154: diag_up_left_seg
@S1155: panic_stop
@S1157: c_2
@S1160: c_2n
@S1161: c_3
@S1162: c_4
@S1163: c_8n
@S1164: c_10
@S1165: c_1000
@S1166: c_XX
@S1167: c_oh
@S1170: player
@S1171: opponent
@S1172: BRD_SIZE
@S1173: BRDS_COUNT
@S1174: first_boardp
@S1175: board2
@S1206: board3
@S1217: board_row_x_win
@S1230: board_col_o_win
@S1241: board_2_4_6_diagonal
@S1252: board4
@S1263: boardp
@S1264: isMovesLeft
@S1271: iML_bptr
@S1276: iML_lp
@S1302: iML_empty
@S1303: isMovesLeftRet
@S1304: iML_cnt
@S1305: iML_ret
@S1306: equ3
@S1311: rd_brd1
@S1317: rd_brd2
@S1324: equ3_brd3
@S1327: rd_brd3
@S1334: equ3_ret_equal
@S1336: equ3_ret_not_equal
@S1337: equ3_ret
@S1340: equ3_arg_stride
@S1341: equ3_lcl_first_read
@S1342: evaluate_board
@S1343: eval_chk_row
@S1351: eval_row_loop
@S1354: eval_chk_nxt_row
@S1361: eval_chk_col
@S1367: eval_col_loop
@S1372: eval_chk_nxt_col
@S1377: eval_chk_diagonal0
@S1404: eval_chk_diagonal1
@S1413: eval_score_players
@S1416: eval_opp_win
@S1420: eval_player_win
@S1422: eval_ret
@S1423: eval_lcl_nxt_cell
@S1424: eval_lcl_loop_count
@S1425: push_minmax
@S1441: push_src
@S1442: push_dst
@S1454: push_ret
@S1455: pop_minmax
@S1474: pop_src
@S1475: pop_dst
@S1503: pop_ret
@S1504: push_lcl_depth
@S1505: push_pop_lcl_acc_stash
@S1506: push_pop_word_count
@S1507: frame_size
@S1510: minimax_retp
@S1511: stack_size
@S1512: stackp
@S1513: stack0
@S1621: eos
@S1622: stack_endp
@S1623: minimax
@S1631: minmax_test_max
@S1636: minmax_max_won
@S1641: minmax_test_min
@S1646: minmax_min_won
@S1651: minmax_test_tie
@S1654: minmax_tie
@S1657: minmax_prepare_scan
@S1661: minmax_isMax
@S1667: minmax_loop1
@S1674: minmax_rd1
@S1677: minmax_empty_cell1
@S1700: minmax_wr1
@S1714: minmax_not_best0
@S1717: minmax_undo_move0
@S1720: minmax_loop1_end
@S1725: minmax_not_isMax
@S1733: minmax_loop2
@S1740: minmax_rd2
@S1743: minmax_empty_cell2
@S1744: minmax_wr2
@S1755: minmax_best2
@S1757: minmax_not_best2
@S1762: minmax_undo_move2
@S1763: minmax_loop2_end
@S1770: minmax_exit
@S1774: minmax_ret
@S1775: minmax_lcl_isMax
@S1776: minmax_lcl_score
@S1777: minmax_lcl_next_cell
@S2000: minmax_lcl_loop_cnt
@S2001: minmax_lcl_best
@S2002: minmax_lcl_undo_move
@S2003: minmax_lcl_data_end
@S2004: mm_lcl_ret_val
@S2005: findBestMove
@S2025: fBM_fetch_cell
@S2030: fBM_try_move
@S2031: fBM_set_cell
@S2037: fBM_clear_cell
@S2047: fBM_next_loop
@S2061: fBM_ret
@S2062: fBM_lcl_best_value
@S2063: fBM_lcl_best_move
@S2064: fBM_lcl_loop_count
@S2065: fBM_lcl_current_cell
@S2066: fBM_lcl_tmp_score
@S2067: unit_test_main
@S2075: msgp
@S2076: msg
@S2077: draw_str
@S2101: ds_loop
@S2107: ds_get_char
@S2113: ds_test_str_end
@S2121: ds_ret
@S2122: ds_lcl_charp
@S2123: ds_argx
@S2124: ds_argy
@S2125: SixteenSegmentFlexop
@S2126: SixteenSegmentFlexo
@S2126: flexo_ucase
@S2226: seg_tab_startp
@S2227: seg00x
@S2230: seg00y
@S2231: seg00d
@S2232: seg01x
@S2233: seg01y
@S2234: seg01d
@S2235: seg02x
@S2236: seg02y
@S2237: seg02d
@S2240: seg03x
@S2241: seg03y
@S2242: seg03d
@S2243: seg04x
@S2244: seg04y
@S2245: seg04d
@S2246: seg05x
@S2247: seg05y
@S2250: seg05d
@S2251: seg06x
@S2252: seg06y
@S2253: seg06d
@S2254: seg07x
@S2255: seg07y
@S2256: seg07d
@S2257: seg08x
@S2260: seg08y
@S2261: seg08d
@S2262: seg09x
@S2263: seg09y
@S2264: seg09d
@S2265: seg10x
@S2266: seg10y
@S2267: seg10d
@S2270: seg11x
@S2271: seg11y
@S2272: seg11d
@S2273: seg12x
@S2274: seg12y
@S2275: seg12d
@S2276: seg13x
@S2277: seg13y
@S2300: seg13d
@S2301: seg14x
@S2302: seg14y
@S2303: seg14d
@S2304: seg15x
@S2305: seg15y
@S2306: seg15d
@S2307: seg_tab_endp
@S2310: char_spacing
@S2311: draw_16seg_char
@S2314: d16c_rd
@S2326: d16s_loop
@S2332: d16s_loop_continue
@S2351: d16c_draw_seg
@S2351: d16c_read_seg_taby
@S2354: d16c_read_seg_tabx
@S2356: d16c_read_seg_tabdxy
@S2360: d16c_ret
@S2361: d16c_argx
@S2362: d16c_argy
@S2363: d16c_lcl_seg_map
@S2364: d16c_lcl_loop_cnt
@S1677: scope_vector
@S0677: scope_point
@S0001: XX
@S0002: Oh
@S-001: None
@S0060: WIDTH_16SEG
@S0110: HEIGHT_16SEG
@S0010: OFFSET_16SEG
@S7400: SPACING_16SEG
@S172267: DOWN_LEFT
@S5110: UP_RIGHT
@S30000: HORIZ_RIGHT
@S34110: UP_RIGHT_DIAG
@S24267: DOWN_RIGHT_DIAG
@S1000: P0x
@S11000: P0y
@S4000: P1x
@S11000: P1y
@S7000: P2x
@S11000: P2y
@S6400: P3x
@S4400: P3y
@S6000: P4x
@S0000: P4y
@S3000: P5x
@S0000: P5y
@S0000: P6x
@S0000: P6y
@S0400: P7x
@S4400: P7y
@S3400: P8x
@S4400: P8y
@E0053: print: "is_there_a_winner returns %ao, which_player = 0o%o", 0o000210
@E0060: print: "light gun hit at cell %d", 0o000200
@E0066: print: "set g_game_over flag to 0o%o", 0o001127
@E0536: print: "light gun %o hit x=%o, y=%o, cell=%ao", 0o000543, 0o000541, 0o000542
@E0631: print: "User move to cell %d; Table-driven move to cell offset %d / 3, ts 0o%o 0o%ao", 0o000633, 0o000634, 0o000630
@E0715: exec: print_experiment(cm, cb, "move game board player %d to cell %d, function 0o%o to gb offset 0o%o", ("player", "lcl_cell_for_move", "apm_fetch_icon_fn", "apm_store_move"), 0)
@E0721: print: "APM_Panic Halt: not dot, cross or naught in auto_play_move: lcl_apm_cell_state=0o%o", 0o000723
@E1015: print: "naught win"
@E1020: print: "cross win"
@E1033: print: "game tie"
@E1156: print: "panic stop"
@E1701: exec: print_experiment(cm, cb, "Trying  game piece %d to cell %d, count %d, isMax==True", ("player", "minmax_lcl_next_cell", "minmax_lcl_loop_cnt"), "push_lcl_depth")
@E2031: print: "fBM: try  empty cell %d, player=%d", 0o002065, 0o001170
@E2046: print: "fBM new Best Move: score %d, cell %d, loop: %d", 0o002066, 0o002065, 0o002064
@E2061: print: "fBM findBestMove for player %d returns move to cell %ad, score=%d", 0o001170, 0o002062
@N0002:  draw a point on all scopes
@N0040:  call the init subroutine
@N0041:  branch to main display refresh loop
@N0042:  constants
@N0044:  close to the edge of the scope screen
@N0047:  negative value means "game over"
@N0051:  check to see if this user move ended the game
@N0052:  if which_player is not zero, then the game has ended
@N0055:  negative means no more moves
@N0060:  do something with the light gun hit!  ; this call is for person-vs-computer play
@N0062:  mark the mailbox as empty
@N0064:  the game_over flag starts set to zero by init_game_board
@N0065:  But when the game is over, we set it to -1
@N0067:  two horizontal lines first
@N0077:  segment count should be negative, ie, we will incr the value until positive
@N0105:  two vertical lines next
@N0114:  segment count should be negative, ie, we will incr the value until positive
@N0122:  nine passes; var should be 8; loop count is negative
@N0144:  draw the X, O or dot; this call may have a side-effect of seeing a light-gun hit
@N0145:  increment pointers and loop count for the next pass
@N0160:  see definition for this number
@N0161:  clear the sign bit in case of "Game Over"
@N0164:  set the location to draw a string
@N0170:  get the pointer to the string into ACC
@N0171:  "print" the string on the screen
@N0172:  draw the symbol to call for a game reset
@N0173:  return from the 'board display' subroutine
@N0174:  count the number of moves
@N0175:  ephemeral loop state variables
@N0200:  used to pass light-gun hits back from the drawing routine.  Negative means "no hit"
@N0201:  used only in top-level routines for drawing the game board
@N0202:  Arguments to pass into routines
@N0204:  pointer to x_addr
@N0210:  The var, less the sign bit, is used to index player_icon_table below
@N0211:  These two constants control where the X or O indicator lands on the screen
@N0215:  The table is a pointer to subroutine entry points
@N0220: dct3:       .word draw_tie
@N0226:             .flexl "PLAYER X"
@N0237:             .flexl "PLAYER O"
@N0250:             .flexl "X WIN"
@N0256:             .flexl "O WIN"
@N0264:             .flexl "DRAW"
@N0271:  whether the cell contains a dot, a naught or a cross
@N0272:  Game Board State
@N0325:  save the return address
@N0327:  shift from 0-15 axis to -8 to +7
@N0330:  multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0331:  initialize vector gen
@N0333:  shift from 0-15 axis to -8 to +7
@N0335:  re-fetch the next x_arg
@N0336:  multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0337:  Draw a segment with x=ACC
@N0341:  increment the segment counter
@N0344:  save the return address
@N0346:  shift from 0-15 axis to -8 to +7
@N0347:  multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0350:  initialize vector gen with the y-coord in ACC
@N0352:  shift from 0-15 axis to -8 to +7
@N0353:  gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0354:  Draw a segment with x=ACC
@N0356:  increment the segment counter
@N0361:  save return address
@N0362:  test to see if there's another move allowed
@N0363:  if the var is negative, we're done playing
@N0364:  assuming the game's not over, we continue to draw
@N0370:  multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0371:  initialize point gen with the y-coord in ACC
@N0375:  shift from 0-15 axis to -8 to +7
@N0376:  gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0377:  Draw a pont with x=ACC
@N0400:  read the light gun
@N0401:  call a subroutine to handle the light gun.  The gun number is in ACC
@N0403:  args are passed as addresses
@N0407:  shift from 0-15 axis to -8 to +7
@N0410:  multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0411:  initialize vector gen with the y-coord in ACC
@N0415:  shift from 0-15 axis to -8 to +7
@N0416:  gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0417:  Draw a segment with x=ACC
@N0420:  Draw a segment with x=ACC
@N0421:  Draw a segment with x=ACC
@N0422:  Draw a segment with x=ACC
@N0424:  args are passed as addresses
@N0430:  shift from 0-15 axis to -8 to +7
@N0431:  multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0432:  initialize vector gen with the y-coord in ACC
@N0436:  shift from 0-15 axis to -8 to +7; plus an offset
@N0437:  gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0440:  Draw a segment with x=ACC
@N0441:  Draw a segment with x=ACC
@N0442:  shift the x-pos two cells right
@N0443:  Draw a segment with x=ACC
@N0444:  Draw a segment with x=ACC
@N0446:  args are passed as addresses
@N0452:  shift from 0-15 axis to -8 to +7
@N0453:  multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0454:  initialize vector gen with the y-coord in ACC
@N0460:  shift from 0-15 axis to -8 to +7
@N0461:  gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0462:  Draw a segment with x=ACC
@N0463:  Draw a segment with x=ACC
@N0464:           rc diag_dn_right_seg  ; Draw a segment with x=ACC
@N0465:  args are passed as addresses
@N0471:  shift from 0-15 axis to -8 to +7
@N0472:  multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0473:  initialize vector gen with the y-coord in ACC
@N0477:  shift from 0-15 axis to -8 to +7
@N0500:  gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0501:  Draw a segment with x=ACC
@N0502:  Draw a segment with x=ACC
@N0505:  put the point at game-board coord (1, 1)
@N0507:  initialize point gen with the y-coord in ACC
@N0510:  Draw a pont with x=ACC
@N0511:  read the light gun
@N0512:  call a subroutine to handle the light gun.
@N0514:  The light gun number is passed to this routine in ACC
@N0520:  load the x value of the cell's address in the grid
@N0521:  divide the cell x address by four to get 1, 2, or 3
@N0522:  change from one-base to zero-base
@N0524:  repeat the process for the y coordinate
@N0526:  load the y value of the cell's address in the grid
@N0527:  divide the cell y address by four to get 1, 2, or 3
@N0530:  invert to get negative number
@N0531:  change from one-base to zero-base and invert order
@N0533:  multiply y by three, i.e., double then address
@N0535:  add x to get the cell number in the range 0-8
@N0536:  sp alternate_play_cell   ; do something with the light gun hit!; this call is for two-person play
@N0537:  test to see if it's Game Over
@N0541:  temp vars for figuring the cell number in light_gun_cell_hit
@N0544:  are the only ones with dots in them, and that's all the light gun can see
@N0545:  figure the pointer to the first cell draw function in game table
@N0546:   thats table_start + 3*cwll_num + 2
@N0547:  multiply cell number by three for a table offset
@N0553:  figure out what the new cell should be
@N0556:  ACC should now contain the address of the X or O display routine
@N0557:  store the display routine to the game state table
@N0560:  now switch to the other player for the next move
@N0561:  xor a 1 into the LSB; i.e. 0->1 or 1->0
@N0565:  The number of the cell being played is in ACC
@N0566:  figure the pointer to the first cell draw function in game table
@N0567:   thats table_start + 3*cell_num + 2
@N0570:  multiply cell number by three for a table offset
@N0574:  figure out what the new cell should be
@N0577:  ACC should now contain the address of the X or O display routine
@N0600:  store the display routine to the game state table
@N0601:  check to see if this user move ended the game
@N0602:  negative means no more moves
@N0603:  by updating the icon on the game board.
@N0604:  test if this is Move Zero, i.e., the first user move
@N0605:  branch for first move, fall through for subsequent moves
@N0615:  AC contains the cell number of the first human move
@N0616:  stash the arg
@N0622:  fetch the offset of the computer move that will be used to respond
@N0627:  this is wired to have the machine move Naught
@N0630:  update the game state table
@N0631:  no-op for Print
@N0635:  set up to call findBestMove
@N0637:  the game piece is offset three from the table start
@N0647:  test if it's a Dot
@N0654:  store -1 for "unplayed"
@N0656:  retrieve the cell state
@N0657:  test if it's an X
@N0663:  load the value for a Naught
@N0666:  test if it's an X
@N0671:  huh, it's not a dot, cross or naught
@N0672:  load value for a cross
@N0673:  fall through to finish the copy step
@N0674:  step the destination once
@N0675:  step the source three times
@N0701:  around the loop again
@N0702:  human player wired as Cross, the computer plays Nought
@N0706:  return the cell number for the Best Move in ACC
@N0710:  multiply cell number by three
@N0712:  point to cell state in game board table
@N0715:  this address should be dynamically set, not fixed to "naught"
@N0717:  for debug
@N0725:      or -0 if it's 'game over']
@N0726:  set up the outer loop
@N0730:  prepare pointers into the analysis table
@N0734:  initialize with negative zero to simplify zero-detect later
@N0735:  count all the unplayed cells
@N0736:  set up the inner loop
@N0740:  load the starting cell number from the table
@N0745:  move to the gb_state val in gb table
@N0746:  pointer to first entry for this try in the gb table
@N0753:  fetch whatever is in this cell
@N0755:  test if it's a Dot
@N0763:  retrieve the cell state
@N0764:  test if it's an X
@N0772:  test if it's an X
@N0777:  move to next cell in the inner loop
@N1000:  add whatever the analysis table says is the increment
@N1003:  end of inner loop
@N1004:  test to see if there's a winner
@N1013:  02 with the sign bit
@N1014:  mark the game as "over" and a Win
@N1017:  mark the game as "over" and a Win
@N1021:  now move to next entry in outer loop
@N1027:  .print "unplayed cells=0d%d", lcl_total_dots
@N1030:  negative zero means its a tie (i.e., zero dots found)
@N1031:  so if it's not negative, we're done
@N1032:  table offset 04 with the sign bit
@N1033:  mark the game as "over" and a Draw
@N1035:  local variables
@N1045:  static addresses
@N1050:  or diagonal possible win combinations.
@N1051:  start cell  ; horizontal cells
@N1052:  increment
@N1053:  start cell
@N1054:  increment
@N1055:  start cell
@N1056:  increment
@N1057:  start cell  ; vertical cells
@N1060:  increment
@N1061:  start cell
@N1062:  increment
@N1063:  start cell
@N1064:  increment
@N1065:  start cell  ; up-right diagonal
@N1066:  increment
@N1067:  start cell  ; up-left diagonal
@N1070:  increment
@N1071:  directly index the game state table.
@N1072:   0
@N1073:   1
@N1074:   2
@N1075:   3
@N1076:   4
@N1077:   5
@N1100:   6
@N1101:   7
@N1102:   8
@N1103:  Initialize the game state
@N1104:  Reset the Move Counter to Zero
@N1106:  calculate the offset into the game state table for this cell
@N1107:  offset to third table entry
@N1110:  store the pointer to the first entry
@N1111:  nine passes; var should be 8; loop count is negative
@N1113:  fetch the address to use for the initial function pointer for each cell
@N1114:  set a table entry to the default pointer
@N1115:  advance the pointer to the next entry
@N1121:  around the loop until we've hit all nine entries
@N1124:  clear the "game over" flag
@N1125: ;;;;;
@N1130:  Constants
@N1141:  loop counter for 12 iterations
@N1143:  decimal value of screen coord corresponding to two cells in width
@N1144:  two plus sign bit
@N1145:  two plus sign bit
@N1146:  three plus sign bit
@N1147:  +32 in the top half of the word
@N1150:  +32 in the bottom half of the word
@N1155:  ---------------------------------------
@N1157:  Constants
@N1160:  for a loop of three
@N1163:  for a loop of nine passes
@N1165:  BigNum
@N1170: Default state to start the game: player = 'x', opponent = 'o';
@N1172:  nine words per each boar layouts
@N1173:  set the count to do just one board
@N1174:    6  7  8
@N1175:  0
@N1200:  3
@N1203:  6
@N1206:  0
@N1211:  3
@N1214:  6
@N1217:  0
@N1222:  3
@N1225:  6
@N1230:  0
@N1233:  3
@N1236:  6
@N1241:  0
@N1244:  3
@N1247:  6
@N1252:  0
@N1255:  3
@N1260:  6
@N1263:  board2 to scan all the games
@N1264:  are no empty cells
@N1266:  store a pointer to the start of the game board
@N1271:  read the cell under test; If the cell is empty, there are move moves, we can stop
@N1272:  branch if the cell is empty, ie, neither X or O.
@N1273:  non-empty cell; prepare to return positive
@N1275:  update the pointer to the next cell
@N1276:  increment the loop count
@N1277:  branch if not done yet
@N1300:  no empty cells; return -1
@N1302:  return One for more moves left
@N1304:  loop counter
@N1305:  return code
@N1306:  a winner is complete.
@N1307:  add base pointer to the board array to offset
@N1311:  read the first element
@N1313:  remember what's in the first cell
@N1314:  calculate address for second cell by adding stride
@N1317:  read the second element
@N1320:  compare it to the first element read
@N1322:  negative zero means they're the same; so test the third cell
@N1323:  otherwise, bail out
@N1332:  negative zero means they're the same
@N1334:  return negative one or two
@N1337:  fall through to equ3_ret
@N1340:  local vars and arguments
@N1342:  This routine takes no input arguments
@N1343:  check rows for a win; stride of three, starting at zero
@N1344:  set the equ3 stride to one, i.e., three adjacent horizontal cells
@N1345:  set the equ3 starting cell to row zero
@N1347:  initialize loop counter; prepare to go around the loop three times
@N1351:  place offset of first cell to check in AC
@N1352:  check one row
@N1353:  match -- figure out who won
@N1354:  next row is three cells forward
@N1355:  compute the first cell of the next row
@N1360:  branch if there's another row to check, fall through if we've checked three rows
@N1361:  check cols for a win; stride of three, starting at zero
@N1362:  set the equ3 stride to three, i.e., three adjacent vertical cells
@N1363:  set the equ3 starting cell to col zero
@N1365:  initialize loop counter; prepare to go around the loop three times
@N1367:  place offset of first cell to check in AC
@N1370:  check one row
@N1371:  match -- figure out who won
@N1372:  next col is one cell forward
@N1373:  compute the first cell of the next row
@N1376:  branch if there's another row to check, fall through if we've checked three rows
@N1377:  there are only two diagonals, no loops here; just test 0, 4, 8 then 2, 4, 6
@N1400:  set the equ3 stride to four, i.e., 0, 4, 8 diagonal cells
@N1401:  set the equ3 starting cell to col zero
@N1402:  check one row
@N1403:  match -- figure out who won
@N1405:  set the equ3 stride to two, i.e., 2, 4, 6 diagonal cells
@N1406:  set the equ3 starting cell to cell 2
@N1407:  check one row
@N1410:  match -- figure out who won
@N1411:  nobody won; return 0
@N1413:  test to see if the current Player is the one that was found to have three winning cells
@N1416:  score an opponent win as -10
@N1420:  score a Player win as +10
@N1422:  .print "  Evaluate_Score returns %ad"
@N1425:  pointer by the size of the frame
@N1426:  stash the AC
@N1430:  test to be sure we're not running over the allocated space
@N1431:  branch if overflow
@N1434:  initialize the loop counter
@N1435:  fetch the "source pointer"
@N1437:  fetch the "destination pointer"
@N1441:  filled in above
@N1446:  around the loop until the entire stack frame is copied
@N1447:  update the stack pointer for next time
@N1453:  retrieve the AC
@N1454:  subroutine return
@N1456:  stash the AC
@N1457:  back up the stack pointer
@N1467:  initialize the loop counter
@N1470:  fetch the "destination pointer"
@N1472:  fetch the "source pointer"
@N1474:  filled in above
@N1501:  around the loop until the entire stack frame is copied
@N1502:  retrieve the AC
@N1506:  this var is the copy-word counter for push and pop
@N1507:  calculate the size of a single push on the stack
@N1510:  Here's the address of the minimax local data to be pushed onto stack
@N1511:  I've allocated ten frames below for use of the stack
@N1513:  frame 0
@N1522:  frame 1
@N1531:  frame 2
@N1540:  frame 3
@N1547:  frame 4
@N1556:  frame 5
@N1565:  frame 6
@N1574:  frame 7
@N1603:  frame 8
@N1612:  frame 9
@N1621:  end of stack
@N1623:  Min is -1, passed in AC
@N1625:  store state on "the stack"
@N1626:  no-op
@N1627:  figure out how we're doing
@N1631:  test if Maximizer has won
@N1633:  test to see if score is +10
@N1634:  branch if yes
@N1636:  .print "Maximizer Won, score %d", minmax_lcl_score
@N1637:  set up the return code
@N1640:  all done
@N1643:  test to see if score is -10
@N1644:  branch if yes
@N1646:  .print "Minimizer Won, score %d", minmax_lcl_score
@N1647:  set up the return code
@N1650:  all done
@N1651:  test if there are more moves to go
@N1652:  Negative means "no more empty cells"
@N1655:  set up the return code
@N1656:  bail out
@N1660:  branch if isMax == False
@N1661:  ======== This section is "isMax == True" =============
@N1662:  initialize to Most Negative
@N1663:  prepare to scan all cells starting w/zero
@N1665:  loop nine times
@N1667:  get the base board ptr to read the next cell
@N1673:  this is only used _after_ the recursive call, and will need to be restored from stack
@N1674:  fetch the next cell
@N1675:  continue if the cell is empty
@N1676:  go to the next loop step if the cell is not empty
@N1677:  fetch the Player marker
@N1700:  ... and write it into the cell
@N1701:  no-op
@N1702:  load negative zero, i.e. all ones
@N1703:  Sum Digits, i.e., xor, will reverse isMax
@N1704:  load -1 to signal isMax should be False
@N1705:  .exec print_indent(cm, "starting recursive call to minimax: isMax==True-branch, cell at %d, depth: %d, loop_count: %d" % (cm.rd(rl("minmax_lcl_next_cell")), cm.rd(rl("push_lcl_depth")), cm.rd(rl("minmax_lcl_loop_cnt"))), rl("push_lcl_depth"))
@N1706:  push_lcl_depth       ; reduce the score by the calling depth
@N1707:  very local storage for the minimax return call
@N1710:  determine if this was the "best" score so far
@N1711:  branch if we've seen a better score already
@N1712:  save this result as the Best Score So Far
@N1714:  remember that modified instruction addresses are effectively local variables, so restore this one from the stack
@N1715: .exec print_experiment(cm, cb, "Undoing game piece %d in cell %d at 0o%o, isMax==True", ("player", "minmax_lcl_next_cell", "minmax_lcl_undo_move"), "push_lcl_depth")
@N1716:  undo the trial move
@N1720:  get ready for the next cell iteration
@N1722:  go around again if the loop cnt is not exhausted
@N1723:  return the best score found in AC
@N1724:  all done with this pass of isMax == True
@N1725:  ======== This section is "isMax == False" =============
@N1726:  initialize to Most Positive
@N1727:  prepare to scan all cells starting w/zero
@N1731:  loop nine times
@N1733:  get the base board ptr to read the next cell
@N1737:  store this address on the 'stack' for now
@N1740:  fetch the next cell
@N1741:  continue if the cell is empty
@N1742:  go to the next loop step if the cell is not empty
@N1743:  fetch the Opponent marker
@N1744:  ... and write it into the cell
@N1745:  no-op
@N1746:  load -1 to signal isMax should be True
@N1747:  .exec print_indent(cm, "starting recursive call to minimax: isMax==False-branch, cell at %d, depth: %d, loop_count: %d" % (cm.rd(rl("minmax_lcl_next_cell")), cm.rd(rl("push_lcl_depth")), cm.rd(rl("minmax_lcl_loop_cnt"))), rl("push_lcl_depth"))
@N1750:   push_lcl_depth       ; increase the (negative) score by the calling depth
@N1751:  very local storage for the minimax return value
@N1752:  determine if this was the "best" score so far
@N1754:  branch if we've seen a better score already
@N1755:  save this result as the Best Score So Far
@N1757:  remember that modified instruction addresses are effectively local variables, so restore this one from the stack
@N1760:  .exec print_experiment(cm, cb, "Undoing game piece %d in cell %d at 0o%o, isMax==False", ("player", "minmax_lcl_next_cell", "minmax_lcl_undo_move"), "push_lcl_depth")
@N1761:  undo the trial move
@N1763:  get ready for the next cell iteration
@N1765:  go around again if the loop cnt is not exhausted
@N1766:  return the best score found in AC
@N1767:  all done with this pass of isMax == False
@N1770:  no-op for .exec
@N1771:  this is a no-op
@N1772:  .exec print_board(cm, rl("boardp"), rl("push_lcl_depth"), rl("player") )
@N1773:  note that we stash and retrieve the AC during PoP
@N1775:  a "stack frame" must store from minmax_ret to minmax_lcl_data_end
@N2003:  this is just a marker for the end of data to be pushed
@N2005:  doing what, we reverse the "player" bit temporarily.
@N2006:  switch the display to the machine player
@N2007:  xor a 1 into the LSB; i.e. 0->1 or 1->0
@N2011:  initialize the 'best stuff' detector
@N2013:  .print "Starting findBestMove, player=%d, opponent=%d", player, opponent
@N2021:  we always start from cell zero`
@N2025:  read the current cell into AC
@N2026:  if the cell is empty, go on to try out a move
@N2027:  take a pass on this non-empty cell, go on to the next one
@N2031:  try out a move on this cell
@N2032:  be careful to not trigger unintended recursion...
@N2033:  tell Minimax to try for a Min score on this cell
@N2034:  call the optimizer; best-score comes back in AC
@N2035:  stash the score for now
@N2036:  undo the trial move, then evaluate the results of minimax
@N2040:  compare the new result with previous best
@N2041:  branch if the old one was better; i.e., skip updating the eval_score_players
@N2044:  save the New Best Score
@N2045:  and remember how we got here, i.e., which cell we tried
@N2054:  go 'round the loop again
@N2055:  now switch the display back to the original (human) player
@N2056:  xor a 1 into the LSB; i.e. 0->1 or 1->0
@N2060:  when we're done with the loop, return the best move found (not the score, the cell that played best)
@N2062:  best score found so far
@N2063:  remember the move that resulted in the best score
@N2067:   */
@N2074: si 0
@N2077:  ds_argx and ds_argy give the initial (x, y) location
@N2100:  save the character pointer passed in the ACC
@N2105:  walk the string from start to finish
@N2107:  fetch the next character in the string
@N2110:  actually draw the character!
@N2111:  prepare for next char in loop
@N2114:  test for a negative number as the marker for the string end; branch out if done
@N2122:  pointer to the next character to display
@N2125:  segments should be lit for each symbol.
@N2126:  /* # */
@N2127:  /* # */
@N2130:  /* E */
@N2131:  /* 8 */
@N2132:  /* # */
@N2133:  /* _ */
@N2134:  /* A */
@N2135:  /* 3 */
@N2136:  /* (space) */
@N2137:  /* : */
@N2140:  /* S */
@N2141:  /* 4 */
@N2142:  /* I */
@N2143:  /* / */
@N2144:  /* U */
@N2145:  /* 2 */
@N2146:  /* (del) */
@N2147:  /* ) */
@N2150:  /* D */
@N2151:  /* 5 */
@N2152:  /* R */
@N2153:  /* 1 */
@N2154:  /* J */
@N2155:  /* 7 */
@N2156:  /* N */
@N2157:  /* ( */
@N2160:  /* F */
@N2161:  /* 6 */
@N2162:  /* C */
@N2163:  /* - */
@N2164:  /* K */
@N2165:  /* # */
@N2166:  /* T */
@N2167:  /* # */
@N2170:  /* Z */
@N2171:  /* (del) */
@N2172:  /* L */
@N2173:  /* (space) */
@N2174:  /* W */
@N2175:  /* # */
@N2176:  /* H */
@N2177:  /* (space) */
@N2200:  /* Y */
@N2201:  /* # */
@N2202:  /* P */
@N2203:  /* # */
@N2204:  /* Q */
@N2205:  /* # */
@N2206:  /* O */
@N2207:  /* (del) */
@N2210:  /* B */
@N2211:  /* # */
@N2212:  /* G */
@N2213:  /* # */
@N2214:  /* 9 */
@N2215:  /* # */
@N2216:  /* M */
@N2217:  /* (del) */
@N2220:  /* X */
@N2221:  /* # */
@N2222:  /* V */
@N2223:  /* (del) */
@N2224:  /* 0 */
@N2225:  /* (del) */
@N2226:  // segment in the 16-segment display character.
@N2227:    {P0, P1}
@N2232:    {P1, P2},
@N2235:    {P2, P3},
@N2240:    {P3, P4},
@N2243:    {P4, P5},
@N2246:    {P5, P6},
@N2251:    {P6, P7},
@N2254:    {P7, P0},
@N2257:    {P0, P8},
@N2262:    {P1, P8},
@N2265:    {P2, P8},
@N2270:    {P3, P8},
@N2273:    {P4, P8},
@N2276:    {P5, P8},
@N2301:    {P6, P8},
@N2304:    {P7, P8},
@N2311:  Character position is given by the args d16c_argx, d16c_argy.
@N2312:  add the table start addr to the offset in ACC
@N2314:  fetch the bit map
@N2316:  prep for 16 times around the loop
@N2320:  walk the segment table back to front
@N2321:  first table entry
@N2322:         td tmp_tabx
@N2323:  second table entry
@N2324:         td tmp_taby
@N2325:  third table entry
@N2326:  no op
@N2327:         ca 0
@N2330:  end of debug hack
@N2331:  branch if most significant bit is on
@N2333:  shift AC left by one bit
@N2340:         td tmp_tabx
@N2343:         td tmp_taby
@N2350:  bail out when count exhausted
@N2351:  the SI uses the AC to set Y coord
@N2353:  initialize vector gen with the y-coord in ACC
@N2354:  the RC uses AC to set X coord and mem address for the vector length
@N2360: ; Return from draw_16seg_char
@N2365:  *********************************************************************************************************/
