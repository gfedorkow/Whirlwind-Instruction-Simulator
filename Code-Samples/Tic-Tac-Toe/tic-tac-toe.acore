
; *** Core Image ***
%File: tic-tac-toe.ww
%TapeID: 
@C0000: 0000000 0000001  None    None    None    None    None    None   
@C0040: 0075071 0074046 0000017 0000040 0073300 0062000 0074055 0100166 
@C0050: 0070046 0074553 0104001 0040166 0074046 0050161 0105115 0040167 
@C0060: 0101120 0040171 0101115 0040170 0105125 0040174 0074313 0101124 
@C0070: 0040171 0130167 0070062 0105115 0040167 0101120 0040170 0101115 
@C0100: 0040171 0105125 0040174 0074332 0101124 0040170 0130167 0070077 
@C0110: 0105122 0040167 0100257 0040163 0110001 0040164 0110001 0040165 
@C0120: 0104001 0040166 0100163 0040172 0100164 0040173 0100165 0044130 
@C0130: 0100000 0044132 0074000 0100163 0111116 0040163 0100164 0111116 
@C0140: 0040164 0100165 0111116 0040165 0130167 0070122 0100176 0175121 
@C0150: 0110206 0044156 0104044 0042100 0104045 0042077 0100000 0076053 
@C0160: 0074472 0074000 0000000 0000000 0000000 0000000 0177776 0000000 
@C0170: 0000000 0000000 0000000 0000000 0000000 0000000 0000000 0000007 
@C0200: 0000001 0000177 0000200 0000204 0000371 0000412 0000207 0000214 
@C0210: 0000225 0000236 0000244 0000252 0000054 0000044 0000006 0000052 
@C0220: 0000002 0000024 0000010 0000072 0177776 0000054 0000044 0000006 
@C0230: 0000052 0000002 0000024 0000010 0000060 0177776 0000072 0000010 
@C0240: 0000046 0000014 0000030 0177776 0000060 0000010 0000046 0000014 
@C0250: 0000030 0177776 0000022 0000024 0000006 0000046 0177776 0000260 
@C0260: 0000004 0000014 0000347 0000010 0000014 0000347 0000014 0000014 
@C0270: 0000347 0000004 0000010 0000347 0000010 0000010 0000347 0000014 
@C0300: 0000010 0000347 0000004 0000004 0000347 0000010 0000004 0000347 
@C0310: 0000014 0000004 0000347 0050331 0100171 0115122 0154014 0001677 
@C0320: 0100170 0115122 0040170 0100170 0154014 0025133 0130170 0130174 
@C0330: 0070323 0074000 0050346 0100171 0115122 0154014 0001677 0100170 
@C0340: 0115122 0154014 0025134 0130171 0130174 0070333 0074000 0050370 
@C0350: 0100176 0070370 0100173 0044354 0100000 0115122 0154014 0000677 
@C0360: 0100172 0044362 0100000 0115122 0154014 0024000 0014000 0070502 
@C0370: 0074000 0050411 0100173 0044374 0100000 0115122 0154014 0001677 
@C0400: 0100172 0044402 0100000 0115122 0154014 0025135 0025136 0025140 
@C0410: 0025137 0074000 0050433 0100173 0044415 0100000 0115122 0154014 
@C0420: 0001677 0100172 0044423 0100000 0115123 0154014 0025135 0025137 
@C0430: 0111127 0025140 0025136 0074000 0050452 0100173 0044437 0100000 
@C0440: 0115122 0154014 0001677 0100172 0044445 0100000 0115122 0154014 
@C0450: 0025135 0025140 0074000 0050471 0100173 0044456 0100000 0115122 
@C0460: 0154014 0001677 0100172 0044464 0100000 0115122 0154014 0025136 
@C0470: 0025137 0074000 0050501 0105121 0154014 0000677 0024000 0014000 
@C0500: 0071071 0074000 0050526 0040531 0100172 0044506 0100000 0160002 
@C0510: 0114001 0040527 0100173 0044514 0100000 0160002 0031114 0111116 
@C0520: 0040530 0155001 0110530 0110527 0040166 0074713 0074000 0000000 
@C0530: 0000000 0000000 0050551 0040552 0155001 0110552 0110257 0111115 
@C0540: 0044545 0100203 0110176 0044544 0100000 0040000 0100176 0030001 
@C0550: 0040176 0074000 0000000 0050601 0040602 0155001 0110602 0110257 
@C0560: 0111115 0044566 0100203 0110176 0044565 0100000 0040000 0074713 
@C0570: 0070600 0100162 0134000 0070576 0074623 0074600 0100602 0074603 
@C0600: 0130162 0074000 0000000 0050620 0040621 0101057 0110621 0044610 
@C0610: 0100000 0040622 0110257 0111143 0044616 0100205 0040000 0030000 
@C0620: 0074000 0000000 0000000 0050706 0100257 0111115 0044633 0101247 
@C0630: 0044661 0105122 0040710 0100000 0040711 0135033 0134000 0070641 
@C0640: 0074644 0131027 0104001 0074661 0100711 0135035 0134000 0070651 
@C0650: 0074653 0101153 0074661 0100711 0135034 0134000 0070660 0074707 
@C0660: 0101152 0040000 0130661 0130633 0130633 0130633 0130710 0070633 
@C0670: 0101153 0041154 0101152 0041155 0075767 0040712 0154001 0110712 
@C0700: 0111143 0110257 0044704 0100205 0040000 0030000 0074000 0074000 
@C0710: 0000000 0000000 0000000 0051022 0105121 0041023 0101036 0044726 
@C0720: 0110001 0044766 0104000 0041030 0105115 0041024 0100000 0041031 
@C0730: 0155001 0111031 0110257 0111115 0044741 0100000 0041025 0041026 
@C0740: 0041027 0100000 0041032 0135033 0134000 0070747 0074751 0131027 
@C0750: 0131030 0101032 0135035 0134000 0070756 0074757 0131025 0101032 
@C0760: 0135034 0134000 0070764 0074765 0131026 0100741 0110000 0040741 
@C0770: 0131024 0070741 0101116 0135025 0071001 0101116 0135026 0071004 
@C1000: 0075007 0101131 0040176 0075007 0101130 0040176 0075007 0130726 
@C1010: 0130726 0130766 0130766 0131023 0070724 0101030 0071020 0075022 
@C1020: 0101132 0040176 0074000 0000000 0000000 0000000 0000000 0000000 
@C1030: 0000000 0000000 0000000 0000347 0000371 0000412 0001037 0000000 
@C1040: 0000003 0000003 0000003 0000006 0000003 0000000 0000011 0000001 
@C1050: 0000011 0000002 0000011 0000000 0000014 0000002 0000006 0001060 
@C1060: 0000014 0000000 0000014 0000000 0000000 0000006 0000014 0000003 
@C1070: 0000014 0051112 0100000 0040162 0100257 0111115 0045102 0105122 
@C1100: 0040167 0101113 0040000 0101102 0111116 0041102 0130167 0071101 
@C1110: 0100000 0040176 0074000 0000347 0177777 0000002 0000003 0000004 
@C1120: 0000006 0000007 0000010 0000011 0000012 0000013 0000014 0020000 
@C1130: 0100002 0100003 0100004 0076000 0000174 0076174 0100200 0076200 
@C1140: 0100174 0100000 0000000 0000002 0177775 0000003 0000004 0177767 
@C1150: 0000012 0001750 0000001 0000002 0000001 0000002 0000011 0000001 
@C1160: 0001161 0000001 0000002 0000002 0000001 0000002 0000001 0177776 
@C1170: 0177776 0177776 0177776 0000002 0000002 0000001 0000002 0000001 
@C1200: 0177776 0177776 0177776 0177776 0000002 0000002 0000001 0000001 
@C1210: 0000001 0000002 0177776 0177776 0177776 0000002 0000001 0000001 
@C1220: 0000002 0000001 0000002 0000002 0177776 0177776 0000002 0000001 
@C1230: 0000002 0000001 0000002 0000001 0000002 0177776 0000002 0000001 
@C1240: 0177776 0177776 0000002 0177776 0177776 0177776 0177776 0001236 
@C1250: 0051267 0101247 0045255 0101147 0041270 0100000 0071266 0100001 
@C1260: 0041271 0131255 0131270 0071255 0104001 0075267 0100001 0074000 
@C1270: 0000000 0000000 0051323 0111247 0045275 0100000 0071322 0041325 
@C1300: 0101275 0111324 0045303 0100000 0115325 0134000 0071310 0075322 
@C1310: 0101303 0111324 0045313 0100000 0115325 0134000 0071320 0075322 
@C1320: 0105325 0075323 0100001 0074000 0000000 0000000 0051406 0100001 
@C1330: 0041324 0100000 0041407 0101144 0041410 0101407 0075272 0071377 
@C1340: 0101145 0111407 0041407 0131410 0071335 0101145 0041324 0100000 
@C1350: 0041407 0101144 0041410 0101407 0075272 0071377 0100001 0111407 
@C1360: 0041407 0131410 0071353 0101146 0041324 0100000 0075272 0071377 
@C1370: 0101143 0041324 0101143 0075272 0071377 0100000 0075406 0111154 
@C1400: 0134000 0071404 0105150 0075406 0101150 0075406 0074000 0000000 
@C1410: 0000000 0051440 0041471 0101475 0115470 0071141 0105473 0110001 
@C1420: 0041472 0101474 0045425 0101476 0045426 0100000 0040000 0131425 
@C1430: 0131426 0131472 0071425 0101476 0111473 0045476 0131470 0101471 
@C1440: 0074000 0051467 0041471 0101476 0115473 0045476 0101470 0114001 
@C1450: 0041470 0105473 0110001 0041472 0101474 0045461 0101476 0045460 
@C1460: 0100000 0040000 0131460 0131461 0131472 0071460 0101471 0074000 
@C1470: 0000000 0000000 0000000 0000007 0001756 0000012 0001477 0000000 
@C1500: 0000000 0000000 0000000 0000000 0000000 0000000 0000000 0000000 
@C1510: 0000000 0000000 0000000 0000000 0000000 0000000 0000000 0000000 
@C1520: 0000000 0000000 0000000 0000000 0000000 0000000 0000000 0000000 
@C1530: 0000000 0000000 0000000 0000000 0000000 0000000 0000000 0000000 
@C1540: 0000000 0000000 0000000 0000000 0000000 0000000 0000000 0000000 
@C1550: 0000000 0000000 0000000 0000000 0000000 0000000 0000000 0000000 
@C1560: 0000000 0000000 0000000 0000000 0000000 0000000 0000000 0000000 
@C1570: 0000000 0000000 0000000 0000000 0000000 0000000 0000000 0000000 
@C1600: 0000000 0000000 0000000 0000000 0000000 0000000 0001605 0051756 
@C1610: 0041757 0075411 0030000 0075326 0041760 0101760 0115150 0134000 
@C1620: 0071622 0075625 0101760 0041763 0075752 0101760 0111150 0134000 
@C1630: 0071632 0075635 0101760 0041763 0075752 0075250 0071640 0075643 
@C1640: 0100000 0041763 0075752 0101757 0071707 0105151 0041763 0100000 
@C1650: 0041761 0101147 0041762 0101247 0111761 0045660 0045664 0045764 
@C1660: 0100000 0071663 0075702 0101154 0040000 0030000 0104001 0075607 
@C1670: 0114001 0041766 0115763 0071676 0101766 0041763 0101764 0045701 
@C1700: 0104001 0040000 0131761 0131762 0071653 0101763 0075752 0101151 
@C1710: 0041763 0100000 0041761 0101147 0041762 0101247 0111761 0045722 
@C1720: 0045726 0045764 0100000 0071725 0075745 0101155 0040000 0030000 
@C1730: 0100001 0075607 0110001 0041766 0115763 0071737 0075741 0101766 
@C1740: 0041763 0101764 0045744 0104001 0040000 0131761 0131762 0071715 
@C1750: 0101763 0075752 0030000 0030000 0101763 0075441 0074000 0000000 
@C1760: 0000000 0000000 0000000 0000000 0000000 0000000 0000000 0052035 
@C1770: 0105151 0042036 0104001 0042037 0101147 0042040 0100000 0042041 
@C2000: 0101247 0046004 0046010 0046016 0100000 0072007 0076026 0101154 
@C2010: 0040000 0074055 0104001 0075607 0042042 0104001 0040000 0102042 
@C2020: 0116036 0072026 0102042 0042036 0102041 0042037 0132004 0132010 
@C2030: 0132016 0132041 0132040 0072004 0102037 0074000 0000000 0000000 
@C2040: 0000000 0000000 0000000 0104044 0042077 0042100 0102051 0076053 
@C2050: 0076043 0002052 0177776 0052075 0046076 0102077 0042335 0102100 
@C2060: 0042336 0102076 0046063 0100000 0076265 0132076 0046067 0100000 
@C2070: 0072075 0102077 0112264 0042077 0076055 0074000 0000000 0000000 
@C2100: 0000000 0002102 0125074 0125074 0100363 0104377 0125074 0000060 
@C2110: 0104317 0004077 0000000 0021000 0104273 0104214 0021063 0042000 
@C2120: 0000374 0104167 0177777 0040400 0021077 0110263 0114307 0002014 
@C2130: 0000174 0000017 0010714 0012000 0100303 0104373 0000363 0104000 
@C2140: 0112300 0125074 0021003 0125074 0042063 0177777 0000360 0000000 
@C2150: 0050314 0125074 0104314 0000000 0104274 0125074 0104307 0125074 
@C2160: 0010377 0125074 0000377 0177777 0025077 0125074 0004373 0125074 
@C2170: 0104277 0125074 0002714 0177777 0052400 0125074 0042300 0177777 
@C2200: 0042377 0177777 0002203 0001000 0011000 0030000 0004000 0011000 
@C2210: 0030000 0007000 0011000 0172267 0006400 0004400 0172267 0003000 
@C2220: 0000000 0030000 0000000 0000000 0030000 0000000 0000000 0005110 
@C2230: 0000400 0004400 0005110 0001000 0011000 0024267 0004000 0011000 
@C2240: 0172267 0003400 0004400 0034110 0003400 0004400 0030000 0003400 
@C2250: 0004400 0024267 0003400 0004400 0172267 0000000 0000000 0034110 
@C2260: 0000400 0004400 0030000 0002260 0007400 0052334 0112101 0046270 
@C2270: 0100000 0042337 0104042 0042340 0102263 0046330 0110001 0046325 
@C2300: 0110001 0046332 0100000 0000677 0102337 0072325 0102337 0170001 
@C2310: 0042337 0102330 0115145 0046330 0102325 0115145 0046325 0102332 
@C2320: 0115145 0046332 0132340 0072302 0076334 0100000 0112336 0001677 
@C2330: 0100000 0112335 0024000 0076306 0074000 0000000 0000000 0000000 
@C2340: 0000000  None    None    None    None    None    None    None   
@S0000: zero
@S0000: const_0
@S0001: one
@S0001: const_1
@S0040: main
@S0042: c_15
@S0043: c_32
@S0044: c_scope_edge
@S0045: c_msg_x_pos
@S0046: refresh_loop
@S0055: draw_game_board
@S0062: x_grid_loop
@S0077: y_grid_loop
@S0110: draw_game_state
@S0122: gb_loop
@S0122: gb_x_inst
@S0124: gb_y_inst
@S0126: gb_gs_inst
@S0130: ca_addr
@S0132: gb_state_sp
@S0146: draw_current_player
@S0156: dcp_ca_addr
@S0161: draw_game_board_ret
@S0162: move_number
@S0163: next_x_addr
@S0164: next_y_addr
@S0165: next_gb_state_addr
@S0166: light_gun_mailbox
@S0167: loop_count
@S0170: x_arg
@S0171: y_arg
@S0172: x_addr_arg
@S0173: y_addr_arg
@S0174: n_segments
@S0175: gb_state_arg
@S0176: which_player
@S0177: player_state_x_addr
@S0200: player_state_y_addr
@S0201: player_state_x_ptr
@S0202: player_state_y_ptr
@S0203: player_icon_table
@S0204: dct0
@S0205: dct1
@S0206: state_msg_tablep
@S0207: state_msg_table
@S0214: msg_cross_play
@S0225: msg_naught_play
@S0236: msg_x_win
@S0244: msg_o_win
@S0252: msg_draw
@S0257: gb_table_start
@S0260: gb0_x
@S0261: gb0_y
@S0262: gb0_state
@S0263: gb1_x
@S0264: gb1_y
@S0265: gb1_state
@S0266: gb2_x
@S0267: gb2_y
@S0270: gb2_state
@S0271: gb3_x
@S0272: gb3_y
@S0273: gb3_state
@S0274: gb4_x
@S0275: gb4_y
@S0276: gb4_state
@S0277: gb5_x
@S0300: gb5_y
@S0301: gb5_state
@S0302: gb6_x
@S0303: gb6_y
@S0304: gb6_state
@S0305: gb7_x
@S0306: gb7_y
@S0307: gb7_state
@S0310: gb8_x
@S0311: gb8_y
@S0312: gb8_state
@S0313: draw_x_line
@S0323: next_x_seg
@S0331: draw_x_line_ret
@S0332: draw_y_line
@S0333: next_y_seg
@S0346: draw_y_line_ret
@S0347: draw_dot
@S0354: dd_y_arg
@S0362: dd_x_arg
@S0370: draw_dot_ret
@S0371: draw_cross
@S0374: dc_y_arg
@S0402: dc_x_arg
@S0411: draw_cross_ret
@S0412: draw_naught
@S0415: dn_y_arg
@S0423: dn_x1_arg
@S0433: draw_naught_ret
@S0434: draw_win
@S0437: dw_y_arg
@S0445: dw_x_arg
@S0452: draw_win_ret
@S0453: draw_tie
@S0456: dt_y_arg
@S0464: dt_x_arg
@S0471: draw_tie_ret
@S0472: draw_reset_symbol
@S0501: draw_reset_symbol_ret
@S0502: light_gun_cell_hit
@S0506: lgh_x1_arg
@S0514: lgh_y1_arg
@S0526: light_gun_cell_hit_ret
@S0527: lcl_cell_x
@S0530: lcl_cell_y
@S0531: lcl_gun_num
@S0532: alternate_play_cell
@S0544: apc_ca0
@S0545: apc_table_ts
@S0551: alternate_play_cell_ret
@S0552: lcl_aplay_cell_num
@S0553: user_play_cell
@S0565: upc_ca0
@S0566: upc_table_ts
@S0576: upc_move_zero
@S0600: upc_cleanup
@S0601: user_play_cell_ret
@S0602: lcl_uplay_cell_num
@S0603: table_play_move
@S0610: tpm_fetch_move_table
@S0616: tpm_store_move
@S0620: table_play_move_ret
@S0621: lcl_tpm_user_move
@S0622: lcl_tpm_table_move
@S0623: auto_play_move
@S0633: apm_copy_src
@S0635: apm_test_dot
@S0641: apm_its_a_dot
@S0644: apm_test_naught
@S0651: apm_its_a_naught
@S0653: apm_test_cross
@S0660: apm_its_a_cross
@S0661: apm_copy_dst
@S0703: apm_fetch_icon_fn
@S0704: apm_store_move
@S0706: apm_ret
@S0707: apm_panic
@S0710: lcl_apm_copy_count
@S0711: lcl_apm_cell_state
@S0712: lcl_cell_for_move
@S0713: is_there_winner
@S0724: itw_outer_loop
@S0726: itw_st_ca
@S0741: itw_inner_loop
@S0741: itw_cell_ts
@S0743: test_dot
@S0747: its_a_dot
@S0751: test_naught
@S0756: its_a_naught
@S0757: test_cross
@S0764: its_a_cross
@S0765: itw_inner_loop_test_end
@S0766: itw_inc_gb
@S1001: naught_win
@S1004: cross_win
@S1007: itw_next_outer_loop
@S1020: its_a_tie
@S1022: is_there_winner_ret
@S1023: lcl_tb_loop_count
@S1024: lcl_cell_loop_count
@S1025: lcl_naught_count
@S1026: lcl_cross_count
@S1027: lcl_dot_count
@S1030: lcl_total_dots
@S1031: lcl_cell_number
@S1032: lcl_cell_state
@S1033: dot_fn_addr
@S1034: cross_fn_addr
@S1035: naught_fn_addr
@S1036: analysis_table_start
@S1037: analysis_table
@S1037: at0
@S1041: at1
@S1043: at2
@S1045: at3
@S1047: at4
@S1051: at5
@S1053: at6
@S1055: at7
@S1057: first_move_table_start
@S1060: first_move_table
@S1071: init_game_board
@S1101: igb_loop
@S1102: igb_table_ts
@S1112: init_game_board_ret
@S1113: lcl_init_val
@S1114: const_0n
@S1115: const_2
@S1116: const_3
@S1117: const_4
@S1120: const_6
@S1121: const_7
@S1122: const_8
@S1123: const_9
@S1124: const_10
@S1125: const_11
@S1126: const_12
@S1127: const_2_cell
@S1130: const_x_win
@S1131: const_o_win
@S1132: const_draw
@S1133: horiz_line_seg
@S1134: vert_line_seg
@S1135: diag_up_right_seg
@S1136: diag_dn_left_seg
@S1137: diag_dn_right_seg
@S1140: diag_up_left_seg
@S1141: panic_stop
@S1143: c_2
@S1144: c_2n
@S1145: c_3
@S1146: c_4
@S1147: c_8n
@S1150: c_10
@S1151: c_1000
@S1152: c_XX
@S1153: c_oh
@S1154: player
@S1155: opponent
@S1156: BRD_SIZE
@S1157: BRDS_COUNT
@S1160: first_boardp
@S1161: board2
@S1172: board3
@S1203: board_row_x_win
@S1214: board_col_o_win
@S1225: board_2_4_6_diagonal
@S1236: board4
@S1247: boardp
@S1250: isMovesLeft
@S1255: iML_bptr
@S1262: iML_lp
@S1266: iML_empty
@S1267: isMovesLeftRet
@S1270: iML_cnt
@S1271: iML_ret
@S1272: equ3
@S1275: rd_brd1
@S1303: rd_brd2
@S1310: equ3_brd3
@S1313: rd_brd3
@S1320: equ3_ret_equal
@S1322: equ3_ret_not_equal
@S1323: equ3_ret
@S1324: equ3_arg_stride
@S1325: equ3_lcl_first_read
@S1326: evaluate_board
@S1327: eval_chk_row
@S1335: eval_row_loop
@S1340: eval_chk_nxt_row
@S1345: eval_chk_col
@S1353: eval_col_loop
@S1356: eval_chk_nxt_col
@S1363: eval_chk_diagonal0
@S1370: eval_chk_diagonal1
@S1377: eval_score_players
@S1402: eval_opp_win
@S1404: eval_player_win
@S1406: eval_ret
@S1407: eval_lcl_nxt_cell
@S1410: eval_lcl_loop_count
@S1411: push_minmax
@S1425: push_src
@S1426: push_dst
@S1440: push_ret
@S1441: pop_minmax
@S1460: pop_src
@S1461: pop_dst
@S1467: pop_ret
@S1470: push_lcl_depth
@S1471: push_pop_lcl_acc_stash
@S1472: push_pop_word_count
@S1473: frame_size
@S1474: minimax_retp
@S1475: stack_size
@S1476: stackp
@S1477: stack0
@S1605: eos
@S1606: stack_endp
@S1607: minimax
@S1615: minmax_test_max
@S1622: minmax_max_won
@S1625: minmax_test_min
@S1632: minmax_min_won
@S1635: minmax_test_tie
@S1640: minmax_tie
@S1643: minmax_prepare_scan
@S1645: minmax_isMax
@S1653: minmax_loop1
@S1660: minmax_rd1
@S1663: minmax_empty_cell1
@S1664: minmax_wr1
@S1676: minmax_not_best0
@S1701: minmax_undo_move0
@S1702: minmax_loop1_end
@S1707: minmax_not_isMax
@S1715: minmax_loop2
@S1722: minmax_rd2
@S1725: minmax_empty_cell2
@S1726: minmax_wr2
@S1737: minmax_best2
@S1741: minmax_not_best2
@S1744: minmax_undo_move2
@S1745: minmax_loop2_end
@S1752: minmax_exit
@S1756: minmax_ret
@S1757: minmax_lcl_isMax
@S1760: minmax_lcl_score
@S1761: minmax_lcl_next_cell
@S1762: minmax_lcl_loop_cnt
@S1763: minmax_lcl_best
@S1764: minmax_lcl_undo_move
@S1765: minmax_lcl_data_end
@S1766: mm_lcl_ret_val
@S1767: findBestMove
@S2004: fBM_fetch_cell
@S2007: fBM_try_move
@S2010: fBM_set_cell
@S2016: fBM_clear_cell
@S2026: fBM_next_loop
@S2035: fBM_ret
@S2036: fBM_lcl_best_value
@S2037: fBM_lcl_best_move
@S2040: fBM_lcl_loop_count
@S2041: fBM_lcl_current_cell
@S2042: fBM_lcl_tmp_score
@S2043: unit_test_main
@S2051: msgp
@S2052: msg
@S2053: draw_str
@S2055: ds_loop
@S2063: ds_get_char
@S2067: ds_test_str_end
@S2075: ds_ret
@S2076: ds_lcl_charp
@S2077: ds_argx
@S2100: ds_argy
@S2101: SixteenSegmentFlexop
@S2102: SixteenSegmentFlexo
@S2102: flexo_ucase
@S2202: seg_tab_startp
@S2203: seg00x
@S2204: seg00y
@S2205: seg00d
@S2206: seg01x
@S2207: seg01y
@S2210: seg01d
@S2211: seg02x
@S2212: seg02y
@S2213: seg02d
@S2214: seg03x
@S2215: seg03y
@S2216: seg03d
@S2217: seg04x
@S2220: seg04y
@S2221: seg04d
@S2222: seg05x
@S2223: seg05y
@S2224: seg05d
@S2225: seg06x
@S2226: seg06y
@S2227: seg06d
@S2230: seg07x
@S2231: seg07y
@S2232: seg07d
@S2233: seg08x
@S2234: seg08y
@S2235: seg08d
@S2236: seg09x
@S2237: seg09y
@S2240: seg09d
@S2241: seg10x
@S2242: seg10y
@S2243: seg10d
@S2244: seg11x
@S2245: seg11y
@S2246: seg11d
@S2247: seg12x
@S2250: seg12y
@S2251: seg12d
@S2252: seg13x
@S2253: seg13y
@S2254: seg13d
@S2255: seg14x
@S2256: seg14y
@S2257: seg14d
@S2260: seg15x
@S2261: seg15y
@S2262: seg15d
@S2263: seg_tab_endp
@S2264: char_spacing
@S2265: draw_16seg_char
@S2270: d16c_rd
@S2302: d16s_loop
@S2306: d16s_loop_continue
@S2325: d16c_draw_seg
@S2325: d16c_read_seg_taby
@S2330: d16c_read_seg_tabx
@S2332: d16c_read_seg_tabdxy
@S2334: d16c_ret
@S2335: d16c_argx
@S2336: d16c_argy
@S2337: d16c_lcl_seg_map
@S2340: d16c_lcl_loop_cnt
@S1677: scope_vector
@S0677: scope_point
@S0001: XX
@S0002: Oh
@S-001: None
@S0060: WIDTH_16SEG
@S0110: HEIGHT_16SEG
@S0010: OFFSET_16SEG
@S7400: SPACING_16SEG
@S172267: DOWN_LEFT
@S5110: UP_RIGHT
@S30000: HORIZ_RIGHT
@S34110: UP_RIGHT_DIAG
@S24267: DOWN_RIGHT_DIAG
@S1000: P0x
@S11000: P0y
@S4000: P1x
@S11000: P1y
@S7000: P2x
@S11000: P2y
@S6400: P3x
@S4400: P3y
@S6000: P4x
@S0000: P4y
@S3000: P5x
@S0000: P5y
@S0000: P6x
@S0000: P6y
@S0400: P7x
@S4400: P7y
@S3400: P8x
@S4400: P8y
@E0051: print: "light gun hit at cell %d", 0o000166
@E0524: print: "light gun %o hit x=%o, y=%o, cell=%ao", 0o000531, 0o000527, 0o000530
@E0617: print: "User move to cell %d; Table-driven move to cell offset %d / 3, ts 0o%o 0o%ao", 0o000621, 0o000622, 0o000616
@E0703: exec: print_experiment(cm, cb, "move game board player %d to cell %d, function 0o%o to gb offset 0o%o", ("player", "lcl_cell_for_move", "apm_fetch_icon_fn", "apm_store_move"), 0)
@E0707: print: "not dot, cross or naught in auto_play_move: lcl_apm_cell_state=0o%o", 0o000711
@E1003: print: "naught win"
@E1006: print: "cross win"
@E1015: print: "unplayed cells=0o%o", 0o001030
@E1021: print: "game tie"
@E1142: print: "panic stop"
@E1665: exec: print_experiment(cm, cb, "Trying  game piece %d to cell %d, count %d, isMax==True", ("player", "minmax_lcl_next_cell", "minmax_lcl_loop_cnt"), "push_lcl_depth")
@E2010: print: "fBM: try  empty cell %d, player=%d", 0o002041, 0o001154
@E2025: print: "fBM new Best Move: score %d, cell %d, loop: %d", 0o002042, 0o002041, 0o002040
@E2035: print: "fBM findBestMove for player %d returns move to cell %ad, score=%d", 0o001154, 0o002036
@N0002:  draw a point on all scopes
@N0040:  call the init subroutine
@N0041:  branch to main display refresh loop
@N0042:  constants
@N0044:  close to the edge of the scope screen
@N0051:  do something with the light gun hit!  ; this call is for person-vs-computer play
@N0053:  mark the mailbox as empty
@N0055:  two horizontal lines first
@N0065:  segment count should be negative, ie, we will incr the value until positive
@N0073:  two vertical lines next
@N0102:  segment count should be negative, ie, we will incr the value until positive
@N0110:  nine passes; var should be 8; loop count is negative
@N0132:  draw the X, O or dot; this call may have a side-effect of seeing a light-gun hit
@N0133:  increment pointers and loop count for the next pass
@N0146:  see definition for this number
@N0147:  clear the sign bit in case of "Game Over"
@N0152:  set the location to draw a string
@N0156:  get the pointer to the string into ACC
@N0157:  "print" the string on the screen
@N0160:  draw the symbol to call for a game reset
@N0161:  return from the 'board display' subroutine
@N0162:  count the number of moves
@N0163:  ephemeral loop state variables
@N0166:  used to pass light-gun hits back from the drawing routine.  Negative means "no hit"
@N0167:  used only in top-level routines for drawing the game board
@N0170:  Arguments to pass into routines
@N0172:  pointer to x_addr
@N0176:  The var, less the sign bit, is used to index player_icon_table below
@N0177:  These two constants control where the X or O indicator lands on the screen
@N0203:  The table is a pointer to subroutine entry points
@N0206: dct3:       .word draw_tie
@N0214:             .flexl "PLAYER X"
@N0225:             .flexl "PLAYER O"
@N0236:             .flexl "X WIN"
@N0244:             .flexl "O WIN"
@N0252:             .flexl "DRAW"
@N0257:  whether the cell contains a dot, a naught or a cross
@N0260:  Game Board State
@N0313:  save the return address
@N0315:  shift from 0-15 axis to -8 to +7
@N0316:  multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0317:  initialize vector gen
@N0321:  shift from 0-15 axis to -8 to +7
@N0323:  re-fetch the next x_arg
@N0324:  multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0325:  Draw a segment with x=ACC
@N0327:  increment the segment counter
@N0332:  save the return address
@N0334:  shift from 0-15 axis to -8 to +7
@N0335:  multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0336:  initialize vector gen with the y-coord in ACC
@N0340:  shift from 0-15 axis to -8 to +7
@N0341:  gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0342:  Draw a segment with x=ACC
@N0344:  increment the segment counter
@N0347:  save return address
@N0350:  test to see if there's another move allowed
@N0351:  if the var is negative, we're done playing
@N0352:  assuming the game's not over, we continue to draw
@N0356:  multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0357:  initialize point gen with the y-coord in ACC
@N0363:  shift from 0-15 axis to -8 to +7
@N0364:  gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0365:  Draw a pont with x=ACC
@N0366:  read the light gun
@N0367:  call a subroutine to handle the light gun.  The gun number is in ACC
@N0371:  args are passed as addresses
@N0375:  shift from 0-15 axis to -8 to +7
@N0376:  multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0377:  initialize vector gen with the y-coord in ACC
@N0403:  shift from 0-15 axis to -8 to +7
@N0404:  gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0405:  Draw a segment with x=ACC
@N0406:  Draw a segment with x=ACC
@N0407:  Draw a segment with x=ACC
@N0410:  Draw a segment with x=ACC
@N0412:  args are passed as addresses
@N0416:  shift from 0-15 axis to -8 to +7
@N0417:  multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0420:  initialize vector gen with the y-coord in ACC
@N0424:  shift from 0-15 axis to -8 to +7; plus an offset
@N0425:  gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0426:  Draw a segment with x=ACC
@N0427:  Draw a segment with x=ACC
@N0430:  shift the x-pos two cells right
@N0431:  Draw a segment with x=ACC
@N0432:  Draw a segment with x=ACC
@N0434:  args are passed as addresses
@N0440:  shift from 0-15 axis to -8 to +7
@N0441:  multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0442:  initialize vector gen with the y-coord in ACC
@N0446:  shift from 0-15 axis to -8 to +7
@N0447:  gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0450:  Draw a segment with x=ACC
@N0451:  Draw a segment with x=ACC
@N0452:           rc diag_dn_right_seg  ; Draw a segment with x=ACC
@N0453:  args are passed as addresses
@N0457:  shift from 0-15 axis to -8 to +7
@N0460:  multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0461:  initialize vector gen with the y-coord in ACC
@N0465:  shift from 0-15 axis to -8 to +7
@N0466:  gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
@N0467:  Draw a segment with x=ACC
@N0470:  Draw a segment with x=ACC
@N0473:  put the point at game-board coord (1, 1)
@N0475:  initialize point gen with the y-coord in ACC
@N0476:  Draw a pont with x=ACC
@N0477:  read the light gun
@N0500:  call a subroutine to handle the light gun.
@N0502:  The light gun number is passed to this routine in ACC
@N0506:  load the x value of the cell's address in the grid
@N0507:  divide the cell x address by four to get 1, 2, or 3
@N0510:  change from one-base to zero-base
@N0512:  repeat the process for the y coordinate
@N0514:  load the y value of the cell's address in the grid
@N0515:  divide the cell y address by four to get 1, 2, or 3
@N0516:  invert to get negative number
@N0517:  change from one-base to zero-base and invert order
@N0521:  multiply y by three, i.e., double then address
@N0523:  add x to get the cell number in the range 0-8
@N0524:  sp alternate_play_cell   ; do something with the light gun hit!; this call is for two-person play
@N0525:  test to see if it's Game Over
@N0527:  temp vars for figuring the cell number in light_gun_cell_hit
@N0532:  are the only ones with dots in them, and that's all the light gun can see
@N0533:  figure the pointer to the first cell draw function in game table
@N0534:   thats table_start + 3*cwll_num + 2
@N0535:  multiply cell number by three for a table offset
@N0541:  figure out what the new cell should be
@N0544:  ACC should now contain the address of the X or O display routine
@N0545:  store the display routine to the game state table
@N0546:  now switch to the other player for the next move
@N0547:  xor a 1 into the LSB; i.e. 0->1 or 1->0
@N0553:  The number of the cell being played is in ACC
@N0554:  figure the pointer to the first cell draw function in game table
@N0555:   thats table_start + 3*cell_num + 2
@N0556:  multiply cell number by three for a table offset
@N0562:  figure out what the new cell should be
@N0565:  ACC should now contain the address of the X or O display routine
@N0566:  store the display routine to the game state table
@N0567:  check to see if this user move ended the game
@N0570:  negative means it's a tie; no more moves
@N0571:  by updating the icon on the game board.
@N0572:  test if this is Move Zero, i.e., the first user move
@N0573:  branch for first move, fall through for subsequent moves
@N0603:  AC contains the cell number of the first human move
@N0604:  stash the arg
@N0610:  fetch the offset of the computer move that will be used to respond
@N0615:  this is wired to have the machine move Naught
@N0616:  update the game state table
@N0617:  no-op for Print
@N0623:  set up to call findBestMove
@N0625:  the game piece is offset three from the table start
@N0635:  test if it's a Dot
@N0642:  store -1 for "unplayed"
@N0644:  retrieve the cell state
@N0645:  test if it's an X
@N0651:  load the value for a Naught
@N0654:  test if it's an X
@N0657:  huh, it's not a dot, cross or naught
@N0660:  load value for a cross
@N0661:  fall through to finish the copy step
@N0662:  step the destination once
@N0663:  step the source three times
@N0667:  around the loop again
@N0670:  human player wired as Cross, the computer plays Nought
@N0674:  return the cell number for the Best Move in ACC
@N0676:  multiply cell number by three
@N0700:  point to cell state in game board table
@N0703:  this address should be dynamically set, not fixed to "naught"
@N0705:  for debug
@N0713:  The second part also can determine if the game is tied, i.e., no open cells left to play
@N0714:  set up the outer loop
@N0716:  prepare pointers into the analysis table
@N0722:  initialize with negative zero to simply zero-detect later
@N0723:  count all the unplayed cells
@N0724:  set up the inner loop
@N0726:  load the starting cell number from the table
@N0733:  move to the gb_state val in gb table
@N0734:  pointer to first entry for this try in the gb table
@N0741:  fetch whatever is in this cell
@N0743:  test if it's a Dot
@N0751:  retrieve the cell state
@N0752:  test if it's an X
@N0760:  test if it's an X
@N0765:  move to next cell in the inner loop
@N0766:  add whatever the analysis table says is the increment
@N0771:  end of inner loop
@N0772:  test to see if there's a winner
@N1001:  02 with the sign bit
@N1002:  mark the game as "over" and a Win
@N1005:  mark the game as "over" and a Win
@N1007:  now move to next entry in outer loop
@N1016:  negative zero means its a tie (i.e., zero dots found)
@N1017:  so if it's not negative, we're done
@N1020:  table offset 04 with the sign bit
@N1021:  mark the game as "over" and a Draw
@N1023:  local variables
@N1033:  static addresses
@N1036:  or diagonal possible win combinations.
@N1037:  start cell  ; horizontal cells
@N1040:  increment
@N1041:  start cell
@N1042:  increment
@N1043:  start cell
@N1044:  increment
@N1045:  start cell  ; vertical cells
@N1046:  increment
@N1047:  start cell
@N1050:  increment
@N1051:  start cell
@N1052:  increment
@N1053:  start cell  ; up-right diagonal
@N1054:  increment
@N1055:  start cell  ; up-left diagonal
@N1056:  increment
@N1057:  directly index the game state table.
@N1060:   0
@N1061:   1
@N1062:   2
@N1063:   3
@N1064:   4
@N1065:   5
@N1066:   6
@N1067:   7
@N1070:   8
@N1071:  Initialize the game state
@N1072:  Reset the Move Counter to Zero
@N1074:  calculate the offset into the game state table for this cell
@N1075:  offset to third table entry
@N1076:  store the pointer to the first entry
@N1077:  nine passes; var should be 8; loop count is negative
@N1101:  fetch the address to use for the initial function pointer for each cell
@N1102:  set a table entry to the default pointer
@N1103:  advance the pointer to the next entry
@N1107:  around the loop until we've hit all nine entries
@N1112: ;;;;;
@N1114:  Constants
@N1125:  loop counter for 12 iterations
@N1127:  decimal value of screen coord corresponding to two cells in width
@N1130:  two plus sign bit
@N1131:  two plus sign bit
@N1132:  three plus sign bit
@N1133:  +32 in the top half of the word
@N1134:  +32 in the bottom half of the word
@N1141:  ---------------------------------------
@N1143:  Constants
@N1144:  for a loop of three
@N1147:  for a loop of nine passes
@N1151:  BigNum
@N1154: Default state to start the game: player = 'x', opponent = 'o';
@N1156:  nine words per each boar layouts
@N1157:  set the count to do just one board
@N1160:    6  7  8
@N1161:  0
@N1164:  3
@N1167:  6
@N1172:  0
@N1175:  3
@N1200:  6
@N1203:  0
@N1206:  3
@N1211:  6
@N1214:  0
@N1217:  3
@N1222:  6
@N1225:  0
@N1230:  3
@N1233:  6
@N1236:  0
@N1241:  3
@N1244:  6
@N1247:  board2 to scan all the games
@N1250:  are no empty cells
@N1252:  store a pointer to the start of the game board
@N1255:  read the cell under test; If the cell is empty, there are move moves, we can stop
@N1256:  branch if the cell is empty, ie, neither X or O.
@N1257:  non-empty cell; prepare to return positive
@N1261:  update the pointer to the next cell
@N1262:  increment the loop count
@N1263:  branch if not done yet
@N1264:  no empty cells; return -1
@N1266:  return One for more moves left
@N1270:  loop counter
@N1271:  return code
@N1272:  a winner is complete.
@N1273:  add base pointer to the board array to offset
@N1275:  read the first element
@N1277:  remember what's in the first cell
@N1300:  calculate address for second cell by adding stride
@N1303:  read the second element
@N1304:  compare it to the first element read
@N1306:  negative zero means they're the same; so test the third cell
@N1307:  otherwise, bail out
@N1316:  negative zero means they're the same
@N1320:  return negative one or two
@N1323:  fall through to equ3_ret
@N1324:  local vars and arguments
@N1326:  This routine takes no input arguments
@N1327:  check rows for a win; stride of three, starting at zero
@N1330:  set the equ3 stride to one, i.e., three adjacent horizontal cells
@N1331:  set the equ3 starting cell to row zero
@N1333:  initialize loop counter; prepare to go around the loop three times
@N1335:  place offset of first cell to check in AC
@N1336:  check one row
@N1337:  match -- figure out who won
@N1340:  next row is three cells forward
@N1341:  compute the first cell of the next row
@N1344:  branch if there's another row to check, fall through if we've checked three rows
@N1345:  check cols for a win; stride of three, starting at zero
@N1346:  set the equ3 stride to three, i.e., three adjacent vertical cells
@N1347:  set the equ3 starting cell to col zero
@N1351:  initialize loop counter; prepare to go around the loop three times
@N1353:  place offset of first cell to check in AC
@N1354:  check one row
@N1355:  match -- figure out who won
@N1356:  next col is one cell forward
@N1357:  compute the first cell of the next row
@N1362:  branch if there's another row to check, fall through if we've checked three rows
@N1363:  there are only two diagonals, no loops here; just test 0, 4, 8 then 2, 4, 6
@N1364:  set the equ3 stride to four, i.e., 0, 4, 8 diagonal cells
@N1365:  set the equ3 starting cell to col zero
@N1366:  check one row
@N1367:  match -- figure out who won
@N1371:  set the equ3 stride to two, i.e., 2, 4, 6 diagonal cells
@N1372:  set the equ3 starting cell to cell 2
@N1373:  check one row
@N1374:  match -- figure out who won
@N1375:  nobody won; return 0
@N1377:  test to see if the current Player is the one that was found to have three winning cells
@N1402:  score an opponent win as -10
@N1404:  score a Player win as +10
@N1406:  .print "  Evaluate_Score returns %ad"
@N1411:  pointer by the size of the frame
@N1412:  stash the AC
@N1414:  test to be sure we're not running over the allocated space
@N1415:  branch if overflow
@N1420:  initialize the loop counter
@N1421:  fetch the "source pointer"
@N1423:  fetch the "destination pointer"
@N1425:  filled in above
@N1432:  around the loop until the entire stack frame is copied
@N1433:  update the stack pointer for next time
@N1437:  retrieve the AC
@N1440:  subroutine return
@N1442:  stash the AC
@N1443:  back up the stack pointer
@N1453:  initialize the loop counter
@N1454:  fetch the "destination pointer"
@N1456:  fetch the "source pointer"
@N1460:  filled in above
@N1465:  around the loop until the entire stack frame is copied
@N1466:  retrieve the AC
@N1472:  this var is the copy-word counter for push and pop
@N1473:  calculate the size of a single push on the stack
@N1474:  Here's the address of the minimax local data to be pushed onto stack
@N1475:  I've allocated ten frames below for use of the stack
@N1477:  frame 0
@N1506:  frame 1
@N1515:  frame 2
@N1524:  frame 3
@N1533:  frame 4
@N1542:  frame 5
@N1551:  frame 6
@N1560:  frame 7
@N1567:  frame 8
@N1576:  frame 9
@N1605:  end of stack
@N1607:  Min is -1, passed in AC
@N1611:  store state on "the stack"
@N1612:  no-op
@N1613:  figure out how we're doing
@N1615:  test if Maximizer has won
@N1617:  test to see if score is +10
@N1620:  branch if yes
@N1622:  .print "Maximizer Won, score %d", minmax_lcl_score
@N1623:  set up the return code
@N1624:  all done
@N1627:  test to see if score is -10
@N1630:  branch if yes
@N1632:  .print "Minimizer Won, score %d", minmax_lcl_score
@N1633:  set up the return code
@N1634:  all done
@N1635:  test if there are more moves to go
@N1636:  Negative means "no more empty cells"
@N1641:  set up the return code
@N1642:  bail out
@N1644:  branch if isMax == False
@N1645:  ======== This section is "isMax == True" =============
@N1646:  initialize to Most Negative
@N1647:  prepare to scan all cells starting w/zero
@N1651:  loop nine times
@N1653:  get the base board ptr to read the next cell
@N1657:  this is only used _after_ the recursive call, and will need to be restored from stack
@N1660:  fetch the next cell
@N1661:  continue if the cell is empty
@N1662:  go to the next loop step if the cell is not empty
@N1663:  fetch the Player marker
@N1664:  ... and write it into the cell
@N1665:  no-op
@N1666:  load -1 to signal isMax should be False
@N1667:  .exec print_indent(cm, "starting recursive call to minimax: isMax==True-branch, cell at %d, depth: %d, loop_count: %d" % (cm.rd(rl("minmax_lcl_next_cell")), cm.rd(rl("push_lcl_depth")), cm.rd(rl("minmax_lcl_loop_cnt"))), rl("push_lcl_depth"))
@N1670:  push_lcl_depth       ; reduce the score by the calling depth
@N1671:  very local storage for the minimax return call
@N1672:  determine if this was the "best" score so far
@N1673:  branch if we've seen a better score already
@N1674:  save this result as the Best Score So Far
@N1676:  remember that modified instruction addresses are effectively local variables, so restore this one from the stack
@N1677: .exec print_experiment(cm, cb, "Undoing game piece %d in cell %d at 0o%o, isMax==True", ("player", "minmax_lcl_next_cell", "minmax_lcl_undo_move"), "push_lcl_depth")
@N1700:  undo the trial move
@N1702:  get ready for the next cell iteration
@N1704:  go around again if the loop cnt is not exhausted
@N1705:  return the best score found in AC
@N1706:  all done with this pass of isMax == True
@N1707:  ======== This section is "isMax == False" =============
@N1710:  initialize to Most Positive
@N1711:  prepare to scan all cells starting w/zero
@N1713:  loop nine times
@N1715:  get the base board ptr to read the next cell
@N1721:  store this address on the 'stack' for now
@N1722:  fetch the next cell
@N1723:  continue if the cell is empty
@N1724:  go to the next loop step if the cell is not empty
@N1725:  fetch the Opponent marker
@N1726:  ... and write it into the cell
@N1727:  no-op
@N1730:  load -1 to signal isMax should be True
@N1731:  .exec print_indent(cm, "starting recursive call to minimax: isMax==False-branch, cell at %d, depth: %d, loop_count: %d" % (cm.rd(rl("minmax_lcl_next_cell")), cm.rd(rl("push_lcl_depth")), cm.rd(rl("minmax_lcl_loop_cnt"))), rl("push_lcl_depth"))
@N1732:   push_lcl_depth       ; increase the (negative) score by the calling depth
@N1733:  very local storage for the minimax return value
@N1734:  determine if this was the "best" score so far
@N1736:  branch if we've seen a better score already
@N1737:  save this result as the Best Score So Far
@N1741:  remember that modified instruction addresses are effectively local variables, so restore this one from the stack
@N1742:  .exec print_experiment(cm, cb, "Undoing game piece %d in cell %d at 0o%o, isMax==False", ("player", "minmax_lcl_next_cell", "minmax_lcl_undo_move"), "push_lcl_depth")
@N1743:  undo the trial move
@N1745:  get ready for the next cell iteration
@N1747:  go around again if the loop cnt is not exhausted
@N1750:  return the best score found in AC
@N1751:  all done with this pass of isMax == False
@N1752:  no-op for .exec
@N1753:  this is a no-op
@N1754:  .exec print_board(cm, rl("boardp"), rl("push_lcl_depth"), rl("player") )
@N1755:  note that we stash and retrieve the AC during PoP
@N1757:  a "stack frame" must store from minmax_ret to minmax_lcl_data_end
@N1765:  this is just a marker for the end of data to be pushed
@N1767:  the assumption on calling this routine is that there's at least one move available to be tried
@N1770:  initialize the 'best stuff' detector
@N1772:  .print "Starting findBestMove, player=%d, opponent=%d", player, opponent
@N2000:  we always start from cell zero`
@N2004:  read the current cell into AC
@N2005:  if the cell is empty, go on to try out a move
@N2006:  take a pass on this non-empty cell, go on to the next one
@N2010:  try out a move on this cell
@N2011:  this doesn't work yet -- unintended recursion...
@N2012:  tell Minimax to try for a Min score on this cell
@N2013:  call the optimizer; best-score comes back in AC
@N2014:  stash the score for now
@N2015:  undo the trial move, then evaluate the results of minimax
@N2017:  compare the new result with previous best
@N2020:  branch if the old one was better; i.e., skip updating the eval_score_players
@N2023:  save the New Best Score
@N2024:  and remember how we got here, i.e., which cell we tried
@N2033:  go 'round the loop again
@N2034:  when we're done with the loop, return the best move found (not the score, the cell that played best)
@N2036:  best score found so far
@N2037:  remember the move that resulted in the best score
@N2043:   */
@N2050: si 0
@N2053:  ds_argx and ds_argy give the initial (x, y) location
@N2054:  save the character pointer passed in the ACC
@N2061:  walk the string from start to finish
@N2063:  fetch the next character in the string
@N2064:  actually draw the character!
@N2065:  prepare for next char in loop
@N2070:  test for a negative number as the marker for the string end; branch out if done
@N2076:  pointer to the next character to display
@N2101:  segments should be lit for each symbol.
@N2102:  /* # */
@N2103:  /* # */
@N2104:  /* E */
@N2105:  /* 8 */
@N2106:  /* # */
@N2107:  /* _ */
@N2110:  /* A */
@N2111:  /* 3 */
@N2112:  /* (space) */
@N2113:  /* : */
@N2114:  /* S */
@N2115:  /* 4 */
@N2116:  /* I */
@N2117:  /* / */
@N2120:  /* U */
@N2121:  /* 2 */
@N2122:  /* (del) */
@N2123:  /* ) */
@N2124:  /* D */
@N2125:  /* 5 */
@N2126:  /* R */
@N2127:  /* 1 */
@N2130:  /* J */
@N2131:  /* 7 */
@N2132:  /* N */
@N2133:  /* ( */
@N2134:  /* F */
@N2135:  /* 6 */
@N2136:  /* C */
@N2137:  /* - */
@N2140:  /* K */
@N2141:  /* # */
@N2142:  /* T */
@N2143:  /* # */
@N2144:  /* Z */
@N2145:  /* (del) */
@N2146:  /* L */
@N2147:  /* (space) */
@N2150:  /* W */
@N2151:  /* # */
@N2152:  /* H */
@N2153:  /* (space) */
@N2154:  /* Y */
@N2155:  /* # */
@N2156:  /* P */
@N2157:  /* # */
@N2160:  /* Q */
@N2161:  /* # */
@N2162:  /* O */
@N2163:  /* (del) */
@N2164:  /* B */
@N2165:  /* # */
@N2166:  /* G */
@N2167:  /* # */
@N2170:  /* 9 */
@N2171:  /* # */
@N2172:  /* M */
@N2173:  /* (del) */
@N2174:  /* X */
@N2175:  /* # */
@N2176:  /* V */
@N2177:  /* (del) */
@N2200:  /* 0 */
@N2201:  /* (del) */
@N2202:  // segment in the 16-segment display character.
@N2203:    {P0, P1}
@N2206:    {P1, P2},
@N2211:    {P2, P3},
@N2214:    {P3, P4},
@N2217:    {P4, P5},
@N2222:    {P5, P6},
@N2225:    {P6, P7},
@N2230:    {P7, P0},
@N2233:    {P0, P8},
@N2236:    {P1, P8},
@N2241:    {P2, P8},
@N2244:    {P3, P8},
@N2247:    {P4, P8},
@N2252:    {P5, P8},
@N2255:    {P6, P8},
@N2260:    {P7, P8},
@N2265:  Character position is given by the args d16c_argx, d16c_argy.
@N2266:  add the table start addr to the offset in ACC
@N2270:  fetch the bit map
@N2272:  prep for 16 times around the loop
@N2274:  walk the segment table back to front
@N2275:  first table entry
@N2276:         td tmp_tabx
@N2277:  second table entry
@N2300:         td tmp_taby
@N2301:  third table entry
@N2302:  no op
@N2303:         ca 0
@N2304:  end of debug hack
@N2305:  branch if most significant bit is on
@N2307:  shift AC left by one bit
@N2314:         td tmp_tabx
@N2317:         td tmp_taby
@N2324:  bail out when count exhausted
@N2325:  the SI uses the AC to set Y coord
@N2327:  initialize vector gen with the y-coord in ACC
@N2330:  the RC uses AC to set X coord and mem address for the vector length
@N2334: ; Return from draw_16seg_char
@N2341:  *********************************************************************************************************/
