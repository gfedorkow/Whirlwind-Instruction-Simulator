
; Tic Tac toe
; Guy Fedorkow
; Sep 26, 2024

; Simple game of tic-tac-toe written in Whirlwind assembly code.
; The game displays on the WW CRT, and can be played with the light gun
; (As of Sep 26, it's a two-person game, i.e., i alternates X and O plays)

; Geometry
; the basic game board is laid out on a 16x16 grid as follows:

;  cell 0   | cell 1   |  cell 2
;  @(4,12)  | @(8,12)  |  @(12,12)
; --------------------------------
;  cell 3   | cell 4   |  cell 5
;  @(4,8)   | @(8,8)   |  @(12,8)
; --------------------------------
;  cell 6   | cell 7   |  cell 8
;  @(4,4)   | @(8,4)   |  @(12,4)

;----------- old layout ----------
;  cell 6   | cell 7   |  cell 8
;  @(4,12)  | @(8,12)  |  @(12,12)
; --------------------------------
;  cell 3   | cell 4   |  cell 5
;  @(4,8)   | @(8,8)   |  @(12,8)
; --------------------------------
;  cell 0   | cell 1   |  cell 2
;  @(4,4)   | @(8,4)   |  @(12,4)
;-------------------------------

          .org 0
zero:
const_0:  .word 0
one:
const_1:  .word 1


; constants for SI graphics instruction
            .pp scope_vector, 0o1677   ; draw a vector on all scopes
            .pp scope_point, 0o0677   ; draw a point on all scopes



            .org 0o40
;

main:       sp init_game_board      ; call the init subroutine
            sp refresh_loop         ; branch to main display refresh loop

; constants
c_15:       .word 15
c_32:       .word 32
c_scope_edge: .word 950 * 32        ; close to the edge of the scope screen
c_msg_x_pos:  .word 800 * 32

refresh_loop: sp draw_game_board

            ca light_gun_mailbox
            cp refresh_loop
            .print "light gun hit at cell %d", light_gun_mailbox
            sp user_play_cell   ; do something with the light gun hit!  ; this call is for person-vs-computer play
            cs one
            ts light_gun_mailbox  ; mark the mailbox as empty

            sp refresh_loop



; ************* Refresh the game board display ********************
; draw the tic-tac-toe grid
; two horizontal lines first
draw_game_board:
            ta draw_game_board_ret
            cs const_2
            ts loop_count
            ca const_6
            ts y_arg
x_grid_loop:
            ca const_2
            ts x_arg
            cs const_11
            ts n_segments  ; segment count should be negative, ie, we will incr the value until positive
            sp draw_x_line

            ca const_10
            ts y_arg          
            ao loop_count
            cp x_grid_loop

; two vertical lines next
            cs const_2
            ts loop_count
            ca const_6
            ts x_arg
y_grid_loop:
            ca const_2
            ts y_arg
            cs const_11
            ts n_segments  ; segment count should be negative, ie, we will incr the value until positive
            sp draw_y_line

            ca const_10
            ts x_arg          
            ao loop_count
            cp y_grid_loop

; Draw the game_state, ie, dots, naughts, or crosses
draw_game_state:
            cs const_8  ; nine passes; var should be 8; loop count is negative
            ts loop_count
            ca gb_table_start
            ts next_x_addr
            ad const_1        
            ts next_y_addr
            ad const_1
            ts next_gb_state_addr
            cs one
            ts light_gun_mailbox
gb_loop:
gb_x_inst:  ca next_x_addr
            ts x_addr_arg
gb_y_inst:  ca next_y_addr
            ts y_addr_arg
gb_gs_inst: ca next_gb_state_addr
            td ca_addr
ca_addr:    ca 0
            td gb_state_sp
gb_state_sp: sp 0   ; draw the X, O or dot; this call may have a side-effect of seeing a light-gun hit

            ; increment pointers and loop count for the next pass
            ca next_x_addr
            ad const_3
            ts next_x_addr
            ca next_y_addr
            ad const_3
            ts next_y_addr
            ca next_gb_state_addr
            ad const_3
            ts next_gb_state_addr
            ao loop_count
            cp gb_loop

draw_current_player:            ; draw an alpha string at the bottom of the screen to show the state of the game
            ca which_player     ; see definition for this number
            md const_7          ; clear the sign bit in case of "Game Over"
            ad state_msg_tablep
            td dcp_ca_addr

            cs c_scope_edge     ; set the location to draw a string
            ts ds_argy
            cs c_msg_x_pos
            ts ds_argx
dcp_ca_addr:
            ca 0        ; get the pointer to the string into ACC
            sp draw_str   ; "print" the string on the screen

            sp draw_reset_symbol  ; draw the symbol to call for a game reset

draw_game_board_ret:    ; return from the 'board display' subroutine
            sp 0


; Global variables
move_number: .word 0    ; count the number of moves
          
; ephemeral loop state variables
next_x_addr:  .word 0
next_y_addr:  .word 0
next_gb_state_addr: .word 0
light_gun_mailbox:  .word -1  ; used to pass light-gun hits back from the drawing routine.  Negative means "no hit"

loop_count:  ; used only in top-level routines for drawing the game board
          .word 0


; Arguments to pass into routines
x_arg:    .word 0
y_arg:    .word 0
x_addr_arg:    .word 0   ; pointer to x_addr
y_addr_arg:    .word 0
n_segments: .word 0
gb_state_arg: .word 0

;  Game Play State
; this var is zero or one to show which player is on-deck for the next move
; But it can also be set to negative to say "Game Over", or 2 to say Win, three to say Draw/Tie
; The var, less the sign bit, is used to index player_icon_table below
which_player:   .word 0     

player_state_x_addr:  .word 7   ; These two constants control where the X or O indicator lands on the screen
player_state_y_addr:  .word 1
player_state_x_ptr:   .word player_state_x_addr
player_state_y_ptr:   .word player_state_y_addr

; Static lookup table to find how to draw the current player state
; The table is a pointer to subroutine entry points
player_icon_table: .word dct0
dct0:       .word draw_cross
dct1:       .word draw_naught
;dct2:       .word draw_win
;dct3:       .word draw_tie

state_msg_tablep:  .word state_msg_table
state_msg_table:
            .word msg_cross_play
            .word msg_naught_play
            .word msg_x_win
            .word msg_o_win
            .word msg_draw


msg_cross_play:
;            .flexl "PLAYER X"
            .word 0o000054
            .word 0o000044
            .word 0o000006
            .word 0o000052
            .word 0o000002
            .word 0o000024
            .word 0o000010
            .word 0o000072
            .word -1

msg_naught_play:
;            .flexl "PLAYER O"
            .word 0o054
            .word 0o044
            .word 0o006
            .word 0o052
            .word 0o002
            .word 0o024
            .word 0o010
            .word 0o060
            .word -1

msg_x_win:
;            .flexl "X WIN"
            .word 0o072
            .word 0o010
            .word 0o046
            .word 0o014
            .word 0o030
            .word -1

msg_o_win:
;            .flexl "O WIN"
            .word 0o060
            .word 0o010
            .word 0o046
            .word 0o014
            .word 0o030
            .word -1

msg_draw:
;            .flexl "DRAW"
            .word 0o022
            .word 0o024
            .word 0o006
            .word 0o046
            .word -1



; Game State Variables
; The Game Table is a nine-entry array that has one entry for each cell of the game board.
; The position of each cell on the game board is static, but the "state" var shows
; whether the cell contains a dot, a naught or a cross
gb_table_start: .word gb0_x
; Game Board State
gb0_x:    .word 4
gb0_y:    .word 12
gb0_state: .word draw_dot
gb1_x:    .word 8
gb1_y:    .word 12
gb1_state: .word draw_dot
gb2_x:    .word 12
gb2_y:    .word 12
gb2_state: .word draw_dot
gb3_x:    .word 4
gb3_y:    .word 8
gb3_state: .word draw_dot
gb4_x:    .word 8
gb4_y:    .word 8
gb4_state: .word draw_dot
gb5_x:    .word 12
gb5_y:    .word 8
gb5_state: .word draw_dot
gb6_x:    .word 4
gb6_y:    .word 4
gb6_state: .word draw_dot
gb7_x:    .word 8
gb7_y:    .word 4
gb7_state: .word draw_dot
gb8_x:    .word 12
gb8_y:    .word 4
gb8_state: .word draw_dot



; subroutine to draw a horizontal line
draw_x_line:
          ta draw_x_line_ret  ; save the return address
          ca y_arg
          su const_8    ; shift from 0-15 axis to -8 to +7
          slr 12        ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
          si scope_vector    ; initialize vector gen
          ca x_arg
          su const_8    ; shift from 0-15 axis to -8 to +7
          ts x_arg
next_x_seg:
          ca x_arg      ; re-fetch the next x_arg
          slr 12        ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
          
          rc horiz_line_seg  ; Draw a segment with x=ACC
          ao x_arg
          ao n_segments  ; increment the segment counter
          cp next_x_seg
draw_x_line_ret:
          sp 0

; subroutine to draw a vertical line
draw_y_line:
          ta draw_y_line_ret  ; save the return address
next_y_seg:          
          ca y_arg
          su const_8    ; shift from 0-15 axis to -8 to +7
          slr 12        ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
          si scope_vector    ; initialize vector gen with the y-coord in ACC
          ca x_arg
          su const_8    ; shift from 0-15 axis to -8 to +7
          slr 12        ; gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
          
          rc vert_line_seg  ; Draw a segment with x=ACC
          ao y_arg
          ao n_segments  ; increment the segment counter
          cp next_y_seg
draw_y_line_ret:          
          sp 0




; subroutine to draw a light-gun dot in an unplayed game cell
; the args into this routine are addresses of x and y locations, not
; the locations themselves
draw_dot:
            ta draw_dot_ret   ; save return address
            ca which_player     ; test to see if there's another move allowed
            cp draw_dot_ret     ; if the var is negative, we're done playing
            
            ca y_addr_arg       ; assuming the game's not over, we continue to draw
            td dd_y_arg
dd_y_arg:   ca 0
            su const_8
            slr 12        ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
            si scope_point    ; initialize point gen with the y-coord in ACC
            ca x_addr_arg
            td dd_x_arg
dd_x_arg:   ca 0
            su const_8    ; shift from 0-15 axis to -8 to +7
            slr 12        ; gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
            rc 0          ; Draw a pont with x=ACC
            rd 0          ; read the light gun
            cp light_gun_cell_hit    ; call a subroutine to handle the light gun.  The gun number is in ACC
draw_dot_ret: 
            sp 0


; draw an "X" centered on the screen at the position of the x and y args
; args are passed as addresses  
draw_cross:
          ta draw_cross_ret
          
          ca y_addr_arg
          td dc_y_arg
dc_y_arg:  ca 0
          su const_8    ; shift from 0-15 axis to -8 to +7
          slr 12        ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
          si scope_vector    ; initialize vector gen with the y-coord in ACC
          ca x_addr_arg
          td dc_x_arg
dc_x_arg: ca 0
          su const_8    ; shift from 0-15 axis to -8 to +7
          slr 12        ; gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
          
          rc diag_up_right_seg  ; Draw a segment with x=ACC
          rc diag_dn_left_seg   ; Draw a segment with x=ACC
          rc diag_up_left_seg   ; Draw a segment with x=ACC
          rc diag_dn_right_seg  ; Draw a segment with x=ACC
draw_cross_ret:
          sp 0

; draw an "naught" (i.e. a diamond) centered on the screen at the position of the x and y args
; args are passed as addresses  
draw_naught:
            ta draw_naught_ret
            
            ca y_addr_arg
            td dn_y_arg
dn_y_arg:  ca 0
            su const_8    ; shift from 0-15 axis to -8 to +7
            slr 12        ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
            si scope_vector    ; initialize vector gen with the y-coord in ACC
            ca x_addr_arg
            td dn_x1_arg
dn_x1_arg: ca 0
            su const_9    ; shift from 0-15 axis to -8 to +7; plus an offset
            slr 12        ; gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
            
            rc diag_up_right_seg  ; Draw a segment with x=ACC
            rc diag_dn_right_seg  ; Draw a segment with x=ACC
            
            ad const_2_cell   ; shift the x-pos two cells right
            rc diag_up_left_seg  ; Draw a segment with x=ACC
            rc diag_dn_left_seg  ; Draw a segment with x=ACC
          
draw_naught_ret:
            sp 0

; placeholder to draw a Win symbol centered on the screen at the position of the x and y args
; args are passed as addresses  
draw_win:
          ta draw_win_ret
          
          ca y_addr_arg
          td dw_y_arg
dw_y_arg:  ca 0
          su const_8    ; shift from 0-15 axis to -8 to +7
          slr 12        ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
          si scope_vector    ; initialize vector gen with the y-coord in ACC
          ca x_addr_arg
          td dw_x_arg
dw_x_arg: ca 0
          su const_8    ; shift from 0-15 axis to -8 to +7
          slr 12        ; gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
          
          rc diag_up_right_seg  ; Draw a segment with x=ACC
;          rc diag_dn_left_seg   ; Draw a segment with x=ACC
          rc diag_up_left_seg   ; Draw a segment with x=ACC
;          rc diag_dn_right_seg  ; Draw a segment with x=ACC
draw_win_ret:
          sp 0

; placeholder to draw a Tie symbol centered on the screen at the position of the x and y args
; args are passed as addresses  
draw_tie:
          ta draw_tie_ret
          
          ca y_addr_arg
          td dt_y_arg
dt_y_arg:  ca 0
          su const_8    ; shift from 0-15 axis to -8 to +7
          slr 12        ; multiply by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
          si scope_vector    ; initialize vector gen with the y-coord in ACC
          ca x_addr_arg
          td dt_x_arg
dt_x_arg: ca 0
          su const_8    ; shift from 0-15 axis to -8 to +7
          slr 12        ; gb_state_arg by 128 to get +/- 1024 screen coords, multiply by 64 to get to bit 0
          
;          rc diag_up_right_seg  ; Draw a segment with x=ACC
          rc diag_dn_left_seg   ; Draw a segment with x=ACC
;          rc diag_up_left_seg   ; Draw a segment with x=ACC
          rc diag_dn_right_seg  ; Draw a segment with x=ACC
draw_tie_ret:
          sp 0


draw_reset_symbol:
            ta draw_reset_symbol_ret
            cs const_7; put the point at game-board coord (1, 1)
            slr 12
            ; ACC contains the coord; use the same number for x and y
            si scope_point    ; initialize point gen with the y-coord in ACC
            rc 0          ; Draw a pont with x=ACC
            rd 0          ; read the light gun
            cp init_game_board    ; call a subroutine to handle the light gun. 

draw_reset_symbol_ret:
            sp 0



; ***************************  User Interaction ***********************

; Handle a user light_gun hit on one of the game cells 
; Remember that this is called only from the routine that draws a
; dot in the middle of a cell on the game grid.
; This routine converts the y_address from screen polarity (more positive is up)
; to Game Board polarity (numbered from top=0 to bottom=2) by subtracting the 
; light gun coord from three.
; The light gun number is passed to this routine in ACC 
light_gun_cell_hit:
            ta light_gun_cell_hit_ret

            ts lcl_gun_num
            ca x_addr_arg
            td lgh_x1_arg
lgh_x1_arg: ca 0        ; load the x value of the cell's address in the grid
            srr 2       ; divide the cell x address by four to get 1, 2, or 3
            su const_1    ; change from one-base to zero-base
            ts lcl_cell_x

            ca y_addr_arg   ; repeat the process for the y coordinate
            td lgh_y1_arg
lgh_y1_arg: ca 0        ; load the y value of the cell's address in the grid
            srr 2       ; divide the cell y address by four to get 1, 2, or 3
            sd const_0n ; invert to get negative number
            ad const_3    ; change from one-base to zero-base and invert order
            ts lcl_cell_y
            slh 1       ; multiply y by three, i.e., double then address
            ad lcl_cell_y
            ad lcl_cell_x  ; add x to get the cell number in the range 0-8

            .print "light gun %o hit x=%o, y=%o, cell=%ao", lcl_gun_num, lcl_cell_x, lcl_cell_y

            ; the cell number of thie hit is passed below in ACC
            ; sp alternate_play_cell   ; do something with the light gun hit!; this call is for two-person play
            ts light_gun_mailbox
            ; sp user_play_cell   ; do something with the light gun hit!  ; this call is for person-vs-computer play

            sp is_there_winner       ; test to see if it's Game Over

light_gun_cell_hit_ret: sp 0

; temp vars for figuring the cell number in light_gun_cell_hit
lcl_cell_x: .word 0
lcl_cell_y: .word 0
lcl_gun_num: .word 0


; "Play" a cell
; This routine does a simple two-person-style play; each light gun hit simply alternates
; between X and O
; The Cell Number to play is passed in the ACC
; Note that this routine can only be called on a previously-unplayed cell, 'cause those
; are the only ones with dots in them, and that's all the light gun can see
alternate_play_cell:
            ta alternate_play_cell_ret

            ts lcl_aplay_cell_num    ; figure the pointer to the first cell draw function in game table
            slh 1                   ;  thats table_start + 3*cwll_num + 2
            ad lcl_aplay_cell_num    ; multiply cell number by three for a table offset
            ad gb_table_start
            ad const_2
            td apc_table_ts

            ca player_icon_table    ; figure out what the new cell should be
            ad which_player
            td apc_ca0
apc_ca0:    ca 0                    ; ACC should now contain the address of the X or O display routine
apc_table_ts: ts 0                  ; store the display routine to the game state table

            ; now switch to the other player for the next move
            ca which_player
            sd const_1              ; xor a 1 into the LSB; i.e. 0->1 or 1->0
            ts which_player

alternate_play_cell_ret:
            sp 0
lcl_aplay_cell_num: .word 0



; This routine plays person against computer; each light gun hit plays an Cross,
; then the machine plays Naught
; Note that this routine can only be called on a previously-unplayed cell, 'cause those
; are the only ones with dots in them, and that's all the light gun can see.
; The number of the cell being played is in ACC
user_play_cell:
            ta user_play_cell_ret

            ts lcl_uplay_cell_num    ; figure the pointer to the first cell draw function in game table
            slh 1                   ;  thats table_start + 3*cell_num + 2
            ad lcl_uplay_cell_num    ; multiply cell number by three for a table offset
            ad gb_table_start
            ad const_2
            td upc_table_ts

            ca player_icon_table    ; figure out what the new cell should be
            ad which_player
            td upc_ca0
upc_ca0:    ca 0                    ; ACC should now contain the address of the X or O display routine
upc_table_ts: ts 0                  ; store the display routine to the game state table

            sp is_there_winner      ; check to see if this user move ended the game
            cp upc_cleanup          ; negative means it's a tie; no more moves

            ; now switch to the other player for the next move
            ; table_play_move is used to optimize the first move by a simple table lookup
            ; auto_play_move calls minimax to figure the best move, then makes the move
            ; by updating the icon on the game board.
            ca move_number
            dm 0            ; test if this is Move Zero, i.e., the first user move
            cp upc_move_zero  ; branch for first move, fall through for subsequent moves

            sp auto_play_move
            sp upc_cleanup

upc_move_zero:
            ca lcl_uplay_cell_num
            sp table_play_move

upc_cleanup:
            ao move_number
user_play_cell_ret:
            sp 0
lcl_uplay_cell_num: .word 0


; The first move is optimized to avoid MinMax. by using a Table lookup
; AC contains the cell number of the first human move
table_play_move:
            ta table_play_move_ret
            ts lcl_tpm_user_move        ; stash the arg

            ca first_move_table_start
            ad lcl_tpm_user_move
            td tpm_fetch_move_table
tpm_fetch_move_table:
            ca 0                    ; fetch the offset of the computer move that will be used to respond
            ts lcl_tpm_table_move
            ad gb_table_start
            ad c_2
            td tpm_store_move
            ca dct1                 ; this is wired to have the machine move Naught
tpm_store_move:
            ts 0                    ; update the game state table
            .print "User move to cell %d; Table-driven move to cell offset %d / 3, ts 0o%o 0o%ao", lcl_tpm_user_move, lcl_tpm_table_move, tpm_store_move
            sd zero   ; no-op for Print

table_play_move_ret:
            sp 0

lcl_tpm_user_move:
            .word 0
lcl_tpm_table_move:
            .word 0



; set up to call findBestMove
auto_play_move:
            ta apm_ret
            ca gb_table_start
            ad const_2       ; the game piece is offset three from the table start 
            td apm_copy_src
            ca boardp
            td apm_copy_dst
            cs const_8
            ts lcl_apm_copy_count

apm_copy_src: ca 0
            ts lcl_apm_cell_state

apm_test_dot:   dm dot_fn_addr      ; test if it's a Dot
            dm 0
            cp apm_its_a_dot
            sp apm_test_naught
apm_its_a_dot:  ao lcl_dot_count
            cs one                 ; store -1 for "unplayed"
            sp apm_copy_dst

apm_test_naught: ca lcl_apm_cell_state  ; retrieve the cell state
            dm naught_fn_addr      ; test if it's an X
            dm 0
            cp apm_its_a_naught
            sp apm_test_cross
apm_its_a_naught:  ca c_oh           ; load the value for a Naught
            sp apm_copy_dst

apm_test_cross: ca lcl_apm_cell_state
            dm cross_fn_addr      ; test if it's an X
            dm 0
            cp apm_its_a_cross
            sp apm_panic           ; huh, it's not a dot, cross or naught
apm_its_a_cross: ca c_XX             ; load value for a cross
            ; fall through to finish the copy step

apm_copy_dst: ts 0
            ao apm_copy_dst  ; step the destination once
            ao apm_copy_src  ; step the source three times
            ao apm_copy_src
            ao apm_copy_src
            ao lcl_apm_copy_count
            cp apm_copy_src  ; around the loop again
            ; finished copying

            ; this ought to test who's playing whom, but the code below has the
            ; human player wired as Cross, the computer plays Nought
            ca c_oh
            ts player
            ca c_XX
            ts opponent
            ; .exec print_board(cm, rl("boardp"), rl("push_lcl_depth"), rl("player"), "calling findBestMove")
            sp findBestMove    ; return the cell number for the Best Move in ACC
            ts lcl_cell_for_move

            ; prepare to make the suggested move permanent in the game board
            slr 1               ; multiply cell number by three
            ad lcl_cell_for_move
            ad c_2              ; point to cell state in game board table
            ad gb_table_start
            td apm_store_move

            ; ca player           ;  "player" is (1, 2) for (X, O); offset for player_tab (0, 1) for (X, O)
            ; su one
            ; ad player_icon_table  ; form a pointer to the icon table
            ; td apm_fetch_icon_fn
            ; ca dct1                 ; the code above should be "put back" to compute the right icon
            ; td apm_fetch_icon_fn

            .exec print_experiment(cm, cb, "move game board player %d to cell %d, function 0o%o to gb offset 0o%o", ("player", "lcl_cell_for_move", "apm_fetch_icon_fn", "apm_store_move"), 0)

apm_fetch_icon_fn:
            ca dct1    ; this address should be dynamically set, not fixed to "naught"
apm_store_move:
            ts 0
            sd zero  ; for debug

apm_ret:
            sp 0

apm_panic:
            .print "not dot, cross or naught in auto_play_move: lcl_apm_cell_state=0o%o", lcl_apm_cell_state
            sp 0

lcl_apm_copy_count:
            .word 0
lcl_apm_cell_state:
            .word 0
lcl_cell_for_move:
            .word 0

;;;;;;;;;;;;;;;;;

; Analyze game for a winner
; This is done by counting X and O in each horiz & vert row, plus the two diagonals.
; The routine is controlled by a table giving the start cell and increment.  For each
; table entry, we count three cells in the game_board state array
; This routing contains two nested loops, the outer one that walks the analysis table,
; and the inner one that counts three cells
; This long subroutine goes in two parts 
;   a) count what's in each cell on each row, column and diagonal (eight in all)
;   b) then see if anyone won
;   [future part c might determine if anyone could win on the next round]
; The second part also can determine if the game is tied, i.e., no open cells left to play
is_there_winner:
            ta is_there_winner_ret
            ; set up the outer loop
            cs const_7
            ts lcl_tb_loop_count
            ca analysis_table_start  ; prepare pointers into the analysis table
            td itw_st_ca
            ad const_1
            td itw_inc_gb
            cs const_0          ; initialize with negative zero to simply zero-detect later
            ts lcl_total_dots        ; count all the unplayed cells

            ; set up the inner loop
itw_outer_loop: cs const_2
            ts lcl_cell_loop_count
itw_st_ca:  ca 0        ; load the starting cell number from the table
            ts lcl_cell_number
            slh 1
            ad lcl_cell_number
            ad gb_table_start
            ad const_2          ; move to the gb_state val in gb table
            td itw_cell_ts      ; pointer to first entry for this try in the gb table

            ca const_0
            ts lcl_naught_count
            ts lcl_cross_count
            ts lcl_dot_count

itw_inner_loop:
itw_cell_ts: ca 0               ; fetch whatever is in this cell
            ts lcl_cell_state
test_dot:   dm dot_fn_addr      ; test if it's a Dot
            dm 0
            cp its_a_dot
            sp test_naught
its_a_dot:  ao lcl_dot_count
            ao lcl_total_dots

test_naught: ca lcl_cell_state  ; retrieve the cell state
            dm naught_fn_addr      ; test if it's an X
            dm 0
            cp its_a_naught
            sp test_cross
its_a_naught:  ao lcl_naught_count

test_cross: ca lcl_cell_state
            dm cross_fn_addr      ; test if it's an X
            dm 0
            cp its_a_cross
            sp itw_inner_loop_test_end
its_a_cross: ao lcl_cross_count

itw_inner_loop_test_end:
            ; move to next cell in the inner loop
            ca itw_cell_ts      
itw_inc_gb: ad 0                ; add whatever the analysis table says is the increment
            ts itw_cell_ts
            ao lcl_cell_loop_count
            cp itw_inner_loop   ; end of inner loop

            ; .print "analysis loop %o, dots=%o, crosses=%o, naughts=%o", lcl_tb_loop_count, lcl_dot_count, lcl_cross_count, lcl_naught_count
            ; test to see if there's a winner
            ca const_3
            dm lcl_naught_count 
            cp naught_win
            ca const_3
            dm lcl_cross_count 
            cp cross_win
            sp itw_next_outer_loop

naught_win: ca const_o_win            ; 02 with the sign bit
            ts which_player         ; mark the game as "over" and a Win
            .print "naught win"
            sp itw_next_outer_loop

cross_win:  ca const_x_win
            ts which_player         ; mark the game as "over" and a Win
            .print "cross win"
            sp itw_next_outer_loop

            ; now move to next entry in outer loop
itw_next_outer_loop:
            ao itw_st_ca
            ao itw_st_ca
            ao itw_inc_gb
            ao itw_inc_gb
            ao lcl_tb_loop_count
            cp itw_outer_loop

            .print "unplayed cells=0o%o", lcl_total_dots
            ca lcl_total_dots
            cp its_a_tie            ; negative zero means its a tie (i.e., zero dots found)
            sp is_there_winner_ret  ; so if it's not negative, we're done

its_a_tie:  ca const_draw            ; table offset 04 with the sign bit
            .print "game tie"
            ts which_player         ; mark the game as "over" and a Draw

is_there_winner_ret:
            sp 0


; local variables
lcl_tb_loop_count: .word 0
lcl_cell_loop_count: .word 0
lcl_naught_count: .word 0
lcl_cross_count:  .word 0
lcl_dot_count:    .word 0
lcl_total_dots:   .word 0
lcl_cell_number:  .word 0
lcl_cell_state:   .word 0

; static addresses
dot_fn_addr:    .word draw_dot
cross_fn_addr:  .word draw_cross
naught_fn_addr: .word draw_naught


; This table gives the instructions for analyzing each horizontal, vertical
; or diagonal possible win combinations.
analysis_table_start:
            .word analysis_table
analysis_table:
at0:        .word 0     ; start cell  ; horizontal cells
            .word 1 * 3    ; increment
at1:        .word 3     ; start cell
            .word 1 * 3     ; increment
at2:        .word 6     ; start cell
            .word 1 * 3     ; increment
at3:        .word 0     ; start cell  ; vertical cells
            .word 3 * 3     ; increment
at4:        .word 1     ; start cell
            .word 3 * 3     ; increment
at5:        .word 2     ; start cell
            .word 3 * 3     ; increment
at6:        .word 0     ; start cell  ; up-right diagonal
            .word 4 * 3     ; increment
at7:        .word 2     ; start cell  ; up-left diagonal
            .word 2 * 3     ; increment


; This table identifies a pre-computed machine response
; to each of the possible first player moves
; i.e., if the player puts a cross in cell zero, respond
; with a naught in cell 4.
; Cell numbers are multiplied by three so they can be used to
; directly index the game state table.
first_move_table_start:
            .word first_move_table
first_move_table:
            .word 4 * 3  ;  0
            .word 0 * 3  ;  1
            .word 4 * 3  ;  2
            .word 0 * 3  ;  3
            .word 0 * 3  ;  4
            .word 2 * 3  ;  5
            .word 4 * 3  ;  6
            .word 1 * 3  ;  7
            .word 4 * 3  ;  8


;;;;;;;;;;;;;;;;
; Set all the game board cells to "unplayed"
; Initialize the game state
init_game_board:
            ta init_game_board_ret

            ca zero                 ; Reset the Move Counter to Zero
            ts move_number

            ca gb_table_start       ; calculate the offset into the game state table for this cell
            ad const_2              ; offset to third table entry
            td igb_table_ts         ; store the pointer to the first entry

            cs const_8  ; nine passes; var should be 8; loop count is negative
            ts loop_count
igb_loop:   ca lcl_init_val         ; fetch the address to use for the initial function pointer for each cell   
igb_table_ts: ts 0                  ; set a table entry to the default pointer
            ca igb_table_ts         ; advance the pointer to the next entry
            ad const_3
            ts igb_table_ts
            ao loop_count
            cp igb_loop             ; around the loop until we've hit all nine entries

            ca const_0
            ts which_player

            ;;;;;
            ; debug - pre-populate two moves
;            ca dct0  ; X icon
;            ts gb0_state
;            ca dct1  ; O icon
;            ts gb1_state
;            ca dct1  ; O icon
;            ts gb2_state
;            ca dct0  ; X icon
;            ts gb3_state
;            ca dct1  ; O icon
;            ts gb4_state
;            ca dct0  ; X icon
;            ts gb7_state

            ;;;;;;
init_game_board_ret:
            sp 0
lcl_init_val: .word draw_dot

; ****************************************


; Constants
const_0n: .word 0o177777
const_2:  .word 2
const_3:  .word 3
const_4:  .word 4
const_6:  .word 6
const_7:  .word 7
const_8:  .word 8
const_9:  .word 9
const_10: .word 10
const_11: .word 11    ; loop counter for 12 iterations
const_12: .word 12
const_2_cell: .word 8192   ; decimal value of screen coord corresponding to two cells in width

const_x_win: .word 0o100002      ; two plus sign bit
const_o_win: .word 0o100003      ; two plus sign bit
const_draw:  .word 0o100004     ; three plus sign bit


; these two constants give the delta values to draw a "maximum short vector"
horiz_line_seg:    .word 0o174 * 0o400   ; +32 in the top half of the word
vert_line_seg:     .word 0o174            ; +32 in the bottom half of the word
diag_up_right_seg: .word 0o174 * 0o400 + 0o174
diag_dn_left_seg:  .word 0o200 * 0o400 + 0o200
diag_dn_right_seg: .word 0o174 * 0o400 + 0o200
diag_up_left_seg:  .word 0o200 * 0o400 + 0o174


; ---------------------------------------

panic_stop:
        ca 0
        .print "panic stop"
        si 0


        ; ;these are the values to be placed in a cell on the board to show
        ; who's playing which position
        .pp XX, 1
        .pp Oh, 2
        .pp None, -1

; Constants
c_2:    .word  2
c_2n:   .word -2    ; for a loop of three
c_3:    .word  3
c_4:    .word  4
c_8n:   .word -8    ; for a loop of nine passes
c_10:   .word 10
c_1000: .word 1000  ; BigNum
c_XX:   .word XX
c_oh:   .word Oh

; Global Variables
;Default state to start the game: player = 'x', opponent = 'o';
player:    .word XX
opponent:  .word Oh



;#define GAME1
;#ifdef GAME1
;    char board[3][3] = 
;     { 
;         { '_', 'o', 'x' }, 
;         { 'x', 'o', '_' }, 
;         { '_', '_', '_' } 
;     }; 
; #endif
; #ifdef GAME2
;    // X should win this game in one move, but it will try every possible alternative before figuring it out 
;    char board[3][3] = 
;    { 
;        { '_', 'o', 'x' }, 
;        { '_', 'o', 'x' }, 
;        { '_', '_', '_' } 
;    }; 
; #endif


; pointers - yuck :-(  This cell points to the first of several board layouts
BRD_SIZE:   .word board3 - board2  ; nine words per each boar layouts
; BRDS_COUNT: .word -5    ; six test board layouts (so far!)
; BRDS_COUNT: .word (first_boardp - boardp) / (board3 - board2) + 1    ; six test board layouts (so far!)
BRDS_COUNT: .word 1       ; set the count to do just one board


; Board Layout
;   0  1  2
;   3  4  5
;   6  7  8

first_boardp: .word board2

;        { 'x', 'o', 'o' }, 
;        { 'x', 'o', 'x' }, 
;        { '_', '_', '_' } 
board2: .word  XX       ; 0
        .word  Oh
        .word  Oh
        .word  XX       ; 3
        .word  Oh
        .word  XX
        .word  None     ; 6
        .word  None
        .word  None

; X plays next, but Oh wins in one move
;        { '_', 'o', 'o' }, 
;        { 'x', 'o', 'x' }, 
;        { '_', '_', '_' } 
board3: .word  None     ; 0
        .word  Oh
        .word  Oh
        .word  XX       ; 3
        .word  Oh
        .word  XX
        .word  None     ; 6
        .word  None
        .word  None

; Test evaluate_board, Rows
; First row is Not a Win, second row should detect a win by X
;        { '_', 'o', 'o' }, 
;        { 'x', 'x', 'x' }, 
;        { 'o', '_', '_' } 
board_row_x_win:
        .word  None     ; 0
        .word  Oh
        .word  Oh
        .word  XX       ; 3
        .word  XX
        .word  XX
        .word  Oh       ; 6
        .word  None
        .word  None

; Test evaluate_board, Cols
; First col is Not a Win, second col should detect a win by 0
;        { '_', 'o', 'x' }, 
;        { 'x', 'o', 'x' }, 
;        { 'o', 'o', '_' } 
board_col_o_win:
        .word  None     ; 0
        .word  Oh
        .word  XX
        .word  XX       ; 3
        .word  Oh
        .word  XX
        .word  Oh       ; 6
        .word  Oh
        .word  None

; Test evaluate_board, 2-4-6 diagonal
;        { '_', 'o', 'x' }, 
;        { 'o', 'x', 'o' }, 
;        { 'x', 'o', '_' } 
board_2_4_6_diagonal:
        .word  None     ; 0
        .word  Oh
        .word  XX
        .word  Oh       ; 3
        .word  XX
        .word  Oh
        .word  XX       ; 6
        .word  Oh
        .word  None

; X plays next, and 'should' play cell 8
;        { 'o', 'x', '_' }, 
;        { '_', 'o', '_' }, 
;        { '_', '_', '_' } 
board4: .word  Oh     ; 0
        .word  XX
        .word  None
        .word  None       ; 3
        .word  Oh
        .word  None
        .word  None     ; 6
        .word  None
        .word  None


boardp: .word board4   ; board2 to scan all the games

; // This function returns true if there are moves 
; // remaining on the board. It returns false if 
; // there are no moves left to play. 
; bool isMovesLeft() 
; { 
;     for (int i = 0; i<3; i++) 
;         for (int j = 0; j<3; j++) 
;             if (board[i][j]=='_') 
;                 return true; 
;     //printf("IsMovesLeft --> false\n");
;     return false; 
; } 
; IsMovesLeft returns positive if there are more moves, negative if there
; are no empty cells
isMovesLeft:
        ta isMovesLeftRet
        ca boardp
        td iML_bptr         ; store a pointer to the start of the game board
        ca c_8n
        ts iML_cnt
iML_bptr: ca 0              ; read the cell under test; If the cell is empty, there are move moves, we can stop
        cp iML_empty        ; branch if the cell is empty, ie, neither X or O.  

        ca one              ; non-empty cell; prepare to return positive
        ts iML_ret
        ao iML_bptr         ; update the pointer to the next cell
iML_lp: ao iML_cnt          ; increment the loop count
        cp iML_bptr          ; branch if not done yet

        cs one              ; no empty cells; return -1
        sp isMovesLeftRet

iML_empty:
        ca one              ; return One for more moves left

isMovesLeftRet:
        sp 0
     
; local variables
iML_cnt:  .word 0           ; loop counter
iML_ret:  .word 0           ; return code


; Helper routine for Evaluate_Board
; Check three adjacent cells to determine if they have the same player identifier
; Return the negative of the value if it's the same, or +1 if different (or if all three are -1, unoccupied)
; The offset from the start of the table is in ACC, the stride is in the "local"
; variable equ3_arg_stride
; The return value in the AC is inverted to make the test one level up a step
; simpler...  -1 or -2 means the row contains all X's or O's, +1 means they're not all
; the same.  The caller can then branch on negative to determine if the search for
; a winner is complete.
equ3:
        ta equ3_ret
        ad boardp       ; add base pointer to the board array to offset
        td rd_brd1
rd_brd1: ca 0            ; read the first element
        cp equ3_ret_not_equal
        ts equ3_lcl_first_read    ; remember what's in the first cell

        ca rd_brd1      ; calculate address for second cell by adding stride
        ad equ3_arg_stride
        td rd_brd2
rd_brd2: ca 0           ; read the second element
        su equ3_lcl_first_read    ; compare it to the first element read
        dm zero
        cp equ3_brd3    ; negative zero means they're the same; so test the third cell
        sp equ3_ret_not_equal   ; otherwise, bail out

equ3_brd3:
        ca rd_brd2
        ad equ3_arg_stride
        td rd_brd3
rd_brd3: ca 0
        su equ3_lcl_first_read
        dm zero
        cp equ3_ret_equal     ; negative zero means they're the same
        sp equ3_ret_not_equal

equ3_ret_equal:
        cs equ3_lcl_first_read  ; return negative one or two
        sp equ3_ret

equ3_ret_not_equal:
        ca one
        ; fall through to equ3_ret

equ3_ret:
        sp 0
; local vars and arguments
equ3_arg_stride:
        .word 0
equ3_lcl_first_read:
        .word 0




; // This is the evaluation function as discussed 
; // in the previous article ( http://goo.gl/sJgv68 ) 
; int evaluate() {
; 
;     // Checking for Rows for X or O victory. 
;     for (int row = 0; row<3; row++) 
;     { 
;         if (board[row][0]==board[row][1] &&   // stride = +1
;             board[row][1]==board[row][2]) 
;         { 
;             if (board[row][0]==player) 
;                 return +10; 
;             else if (board[row][0]==opponent) 
;                 return -10; 
;         } 
;     } 
;   
;     // Checking for Columns for X or O victory. 
;     for (int col = 0; col<3; col++) 
;     { 
;         if (board[0][col]==board[1][col] &&  // stride = +3  
;             board[1][col]==board[2][col]) 
;         { 
;             if (board[0][col]==player) 
;                 return +10; 
;             else if (board[0][col]==opponent) 
;                 return -10; 
;         } 
;     } 
;   
;     // Checking for Diagonals for X or O victory. 
;     if (board[0][0]==board[1][1] && board[1][1]==board[2][2])  // stride = +4 
;     { 
;         if (board[0][0]==player) 
;             return +10; 
;         else if (board[0][0]==opponent) 
;             return -10; 
;     } 
;   
;     if (board[0][2]==board[1][1] && board[1][1]==board[2][0])   // stride = +2
;     { 
;         if (board[0][2]==player) 
;             return +10; 
;         else if (board[0][2]==opponent) 
;             return -10; 
;     } 
;   
;     // Else if none of them have won then return 0 
;     return 0; 
; } 

; Evaluate the current board for win, lose or incomplete
; If it's a Win for the Player, return +10; if it's a Lose for the Player, return -10
; If the game is undecided, return zero
; This routine takes no input arguments
evaluate_board:
        ta eval_ret
eval_chk_row:
        ; check rows for a win; stride of three, starting at zero
        ca one
        ts equ3_arg_stride      ; set the equ3 stride to one, i.e., three adjacent horizontal cells
        ca zero                 ; set the equ3 starting cell to row zero
        ts eval_lcl_nxt_cell
        ca c_2n                 ; initialize loop counter; prepare to go around the loop three times
        ts eval_lcl_loop_count
eval_row_loop:
        ca eval_lcl_nxt_cell    ; place offset of first cell to check in AC
        sp equ3                 ; check one row
        cp eval_score_players    ; match -- figure out who won

eval_chk_nxt_row:
        ca c_3                  ; next row is three cells forward
        ad eval_lcl_nxt_cell    ; compute the first cell of the next row
        ts eval_lcl_nxt_cell
        ao eval_lcl_loop_count
        cp eval_row_loop        ; branch if there's another row to check, fall through if we've checked three rows

        ; no one won on rows, so go on to check columns

eval_chk_col:
        ; check cols for a win; stride of three, starting at zero
        ca c_3
        ts equ3_arg_stride      ; set the equ3 stride to three, i.e., three adjacent vertical cells
        ca zero                 ; set the equ3 starting cell to col zero
        ts eval_lcl_nxt_cell
        ca c_2n                 ; initialize loop counter; prepare to go around the loop three times
        ts eval_lcl_loop_count
eval_col_loop:
        ca eval_lcl_nxt_cell    ; place offset of first cell to check in AC
        sp equ3                 ; check one row
        cp eval_score_players    ; match -- figure out who won

eval_chk_nxt_col:
        ca one                  ; next col is one cell forward
        ad eval_lcl_nxt_cell    ; compute the first cell of the next row
        ts eval_lcl_nxt_cell
        ao eval_lcl_loop_count
        cp eval_col_loop        ; branch if there's another row to check, fall through if we've checked three rows

        ; there are only two diagonals, no loops here; just test 0, 4, 8 then 2, 4, 6
eval_chk_diagonal0:
        ca c_4
        ts equ3_arg_stride      ; set the equ3 stride to four, i.e., 0, 4, 8 diagonal cells
        ca zero                 ; set the equ3 starting cell to col zero
        sp equ3                 ; check one row
        cp eval_score_players    ; match -- figure out who won

eval_chk_diagonal1:
        ca c_2
        ts equ3_arg_stride     ; set the equ3 stride to two, i.e., 2, 4, 6 diagonal cells
        ca c_2                 ; set the equ3 starting cell to cell 2
        sp equ3                ; check one row
        cp eval_score_players    ; match -- figure out who won

        ; nobody won; return 0
        ca zero
        sp eval_ret

        ; somebody won; check if it's the Player or Opponent
        ; The winner cell is -1 or -2 in AC; convert that to a score (recall equ3 results are inverted)
        ; depending on whether who's Player and who's Opponent at the moment
eval_score_players:
        ad player           ; test to see if the current Player is the one that was found to have three winning cells
        dm zero
        cp eval_player_win

eval_opp_win:
        cs c_10             ; score an opponent win as -10
        sp eval_ret

eval_player_win:
        ca c_10             ; score a Player win as +10        
        sp eval_ret

eval_ret:
        ; .print "  Evaluate_Score returns %ad"
        sp 0
eval_lcl_nxt_cell:
        .word 0
eval_lcl_loop_count:
        .word 0


; ================  MINIMAX Section =====================
;
; Two helper functions to save state for recursive calls
; to "push" onto the stack, we copy all the local minimax variables to
; where ever the stack pointer is pointing, then increment the stack
; pointer by the size of the frame
push_minmax:
        ta push_ret
        ts push_pop_lcl_acc_stash  ; stash the AC
        ca stack_size
        su push_lcl_depth          ; test to be sure we're not running over the allocated space
        cp panic_stop              ; branch if overflow

        cs frame_size
        ad one
        ts push_pop_word_count     ; initialize the loop counter
        ca minimax_retp            ; fetch the "source pointer"
        td push_src
        ca stackp                  ; fetch the "destination pointer"
        td push_dst

push_src:                          ; copy loop
        ca 0                       ; filled in above
push_dst:
        ts 0
        ao push_src
        ao push_dst
        ao push_pop_word_count
        cp push_src                ; around the loop until the entire stack frame is copied

        ca stackp                  ; update the stack pointer for next time
        ad frame_size
        td stackp
        ao push_lcl_depth

        ca push_pop_lcl_acc_stash  ; retrieve the AC
push_ret:
        sp 0                       ; subroutine return


pop_minmax:
        ta pop_ret
        ts push_pop_lcl_acc_stash  ; stash the AC
        ca stackp                  ; back up the stack pointer
        su frame_size
        td stackp
        ca push_lcl_depth
        su one
        ts push_lcl_depth

        cs frame_size
        ad one
        ts push_pop_word_count     ; initialize the loop counter
        ca minimax_retp            ; fetch the "destination pointer"
        td pop_dst
        ca stackp                  ; fetch the "source pointer"
        td pop_src

pop_src:                          ; copy loop
        ca 0                       ; filled in above
pop_dst:
        ts 0
        ao pop_src
        ao pop_dst
        ao push_pop_word_count
        cp pop_src                ; around the loop until the entire stack frame is copied

        ca push_pop_lcl_acc_stash  ; retrieve the AC
pop_ret:
        sp 0

push_lcl_depth:
        .word  0
push_pop_lcl_acc_stash:
        .word 0
push_pop_word_count:             ; this var is the copy-word counter for push and pop
        .word 0

; calculate the size of a single push on the stack
frame_size:  .word minmax_lcl_data_end - minmax_ret
minimax_retp:    ; Here's the address of the minimax local data to be pushed onto stack
        .word minmax_ret
stack_size:
        .word 10                ; I've allocated ten frames below for use of the stack


stackp: .word stack0
stack0: .word 0   ; frame 0
        .word 0
        .word 0
        .word 0
        .word 0
        .word 0
        .word 0
        .word 0   ; frame 1
        .word 0
        .word 0
        .word 0
        .word 0
        .word 0
        .word 0
        .word 0   ; frame 2
        .word 0
        .word 0
        .word 0
        .word 0
        .word 0
        .word 0
        .word 0   ; frame 3
        .word 0
        .word 0
        .word 0
        .word 0
        .word 0
        .word 0
        .word 0   ; frame 4
        .word 0
        .word 0
        .word 0
        .word 0
        .word 0
        .word 0
        .word 0   ; frame 5
        .word 0
        .word 0
        .word 0
        .word 0
        .word 0
        .word 0
        .word 0   ; frame 6
        .word 0
        .word 0
        .word 0
        .word 0
        .word 0
        .word 0
        .word 0   ; frame 7
        .word 0
        .word 0
        .word 0
        .word 0
        .word 0
        .word 0
        .word 0   ; frame 8
        .word 0
        .word 0
        .word 0
        .word 0
        .word 0
        .word 0
        .word 0   ; frame 9
        .word 0
        .word 0
        .word 0
        .word 0
        .word 0
        .word 0
eos:    .word 0   ; end of stack
stack_endp: .word eos




; // This is the minimax function. It considers all 
; // the possible ways the game can go and returns 
; // the value of the board 
; int minimax(int depth, bool isMax) 
; { 
;     int score = evaluate(board); 
;     int m;
;     int best;
;   
;     ; printf("%sMinimax Start\n", indent[depth+1]);
;     // If Maximizer has won the game return his/her 
;     // evaluated score 
;     if (score == 10) {
;         return score; 
;         ; printf("%sMaximizer wins\n", indent[depth+1]);
;     }
;   
;     // If Minimizer has won the game return his/her 
;     // evaluated score 
;     if (score == -10) {
;         ; printf("%sMinimizer Wins\n", indent[depth+1]);
;         return score; 
;     }
;   
;     // If there are no more moves and no winner then 
;     // it is a tie 
;     if (isMovesLeft(board)==false) {
;         ; printf("%sMinimax: No More Moves\n", indent[depth+1] );
;         return 0; 
;     }
;   
;     // If this maximizer's move 
;     if (isMax) 
;     { 
;         best = -1000; 
;   
;         // Traverse all cells 
;         for (int i = 0; i<3; i++) 
;         { 
;             for (int j = 0; j<3; j++) 
;            { 
;                // Check if cell is empty 
;                if (board[i][j]=='_') 
;                { 
;                    // Make the move 
;                    board[i][j] = player; 
;  
;                    // Call minimax recursively and choose 
;                    // the maximum value 
;                    //best = max( best, 
;                    //    minimax(board, depth+1, !isMax) ); 
;                    m = minimax(depth+1, !isMax);
;                    //added by guy:
;                    m -= depth;
;                    ; printf("%sminimax isMAX=%d returned score %d  ", indent[depth+1], isMax, m);
;                    if (m > best) {
;                        best = m;
;                        ; printf("%sBest Higher\n", indent[depth+1]);
;                    } else {
;                        ; printf("\n");
;                    }
;                    ; print_board(depth);
;  
;                    // Undo the move 
;                    board[i][j] = '_'; 
;                } 
;            } 
;         } 
;         return best; 
;     } 
;   
;     // If this minimizer's move 
;     else
;     { 
;         best = 1000; 
;   
;         // Traverse all cells 
;         for (int i = 0; i<3; i++) 
;         { 
;             for (int j = 0; j<3; j++) 
;             { 
;                 // Check if cell is empty 
;                 if (board[i][j]=='_') 
;                 { 
;                     // Make the move 
;                     board[i][j] = opponent; 
;   
;                     // Call minimax recursively and choose 
;                     // the minimum value 
;                     // best = min(best, 
;                     //       minimax(depth+1, !isMax)); 
;                     m = minimax(depth+1, !isMax);
;                     ; for (int s = 0; s < depth; s++) printf("  ");
;                    //added by guy:
;                     m += depth;
;                     ; printf("    minimax isMAX=%d returned score %d  ", isMax, m);
;                      if (m < best) {
;                         best = m;
;                         ; printf("Best Lower\n");
;                     } else {
;                         ; printf("\n");
;                     }
;                     ; print_board(depth);
;   
;                     // Undo the move 
;                     board[i][j] = '_'; 
;                 } 
;             } 
;         } 
;         return best; 
;     } 
; } 


; This is the recursive module that tries all the combinations to find the 
; best move.
; The routine takes one arg to say if we're trying to do Max or Min; Max is +1
; Min is -1, passed in AC
minimax:
        ta minmax_ret
        ts minmax_lcl_isMax
        sp push_minmax          ; store state on "the stack"
        ; .exec print_indent(cm, "Starting minimax: IsMax:%d, player: %d opponent %d, depth: %d" % (cm.rd(rl("minmax_lcl_isMax")), cm.rd(rl("player")), cm.rd(rl("opponent")), cm.rd(rl("push_lcl_depth"))), rl("push_lcl_depth"))
        sd zero   ; no-op
        ; .exec print_board(cm, rl("boardp"), rl("push_lcl_depth"), rl("player"), "Starting Minimax")
        sp evaluate_board       ; figure out how we're doing
        ts minmax_lcl_score

minmax_test_max:                ; test if Maximizer has won
        ca minmax_lcl_score
        su c_10
        dm 0                    ; test to see if score is +10
        cp minmax_max_won       ; branch if yes
        sp minmax_test_min

minmax_max_won:
        ; .print "Maximizer Won, score %d", minmax_lcl_score
        ca minmax_lcl_score
        ts minmax_lcl_best      ; set up the return code
        sp minmax_exit           ; all done

minmax_test_min:
        ca minmax_lcl_score
        ad c_10
        dm 0                    ; test to see if score is -10
        cp minmax_min_won       ; branch if yes
        sp minmax_test_tie

minmax_min_won:
        ; .print "Minimizer Won, score %d", minmax_lcl_score
        ca minmax_lcl_score
        ts minmax_lcl_best      ; set up the return code
        sp minmax_exit           ; all done

minmax_test_tie:
        sp isMovesLeft          ; test if there are more moves to go
        ;.print "minmax_test_tie: isMovesLeft = %ad"
        cp minmax_tie           ; Negative means "no more empty cells"
        sp minmax_prepare_scan

minmax_tie:
        ca zero
        ;.print "Minimax Tie"
        ts minmax_lcl_best      ; set up the return code
        sp minmax_exit           ; bail out

minmax_prepare_scan:
        ca minmax_lcl_isMax
        cp minmax_not_isMax     ; branch if isMax == False

        ; ======== This section is "isMax == True" =============
minmax_isMax:
        cs c_1000
        ts minmax_lcl_best      ; initialize to Most Negative
        ca zero                 ; prepare to scan all cells starting w/zero
        ts minmax_lcl_next_cell
        ca c_8n                 ; loop nine times
        ts minmax_lcl_loop_cnt
minmax_loop1:
        ca boardp               ; get the base board ptr to read the next cell
        ad minmax_lcl_next_cell
        td minmax_rd1
        td minmax_wr1
        td minmax_lcl_undo_move         ; this is only used _after_ the recursive call, and will need to be restored from stack
minmax_rd1:
        ca 0                    ; fetch the next cell
        cp minmax_empty_cell1   ; continue if the cell is empty
        sp minmax_loop1_end     ; go to the next loop step if the cell is not empty

minmax_empty_cell1:             ; here, we know the cell we tested is empty, and a candidate for analysis
        ca player               ; fetch the Player marker 
minmax_wr1: 
        ts 0                    ; ... and write it into the cell
        .exec print_experiment(cm, cb, "Trying  game piece %d to cell %d, count %d, isMax==True", ("player", "minmax_lcl_next_cell", "minmax_lcl_loop_cnt"), "push_lcl_depth")
        sd zero   ; no-op

        cs zero                 ; load negative zero, i.e. all ones    
        sd minmax_lcl_isMax     ; Sum Digits, i.e., xor, will reverse isMax
        cs one                   ; load -1 to signal isMax should be False
        ; here begins the recursion
        ; .exec print_indent(cm, "starting recursive call to minimax: isMax==True-branch, cell at %d, depth: %d, loop_count: %d" % (cm.rd(rl("minmax_lcl_next_cell")), cm.rd(rl("push_lcl_depth")), cm.rd(rl("minmax_lcl_loop_cnt"))), rl("push_lcl_depth"))
        sp minimax
        ; the following adjustment probably shouldn't be done if the answer is Zero
        su one  ; push_lcl_depth       ; reduce the score by the calling depth
        ts mm_lcl_ret_val       ; very local storage for the minimax return call
        ; .exec print_indent(cm, "finished recursive call to minimax: isMax==True-branch, cell at %d, depth: %d, loop_count: %d, score: 0o%o" % (cm.rd(rl("minmax_lcl_next_cell")), cm.rd(rl("push_lcl_depth")), cm.rd(rl("minmax_lcl_loop_cnt")), cm.rd(rl("mm_lcl_ret_val"))), rl("push_lcl_depth"))
        su minmax_lcl_best      ; determine if this was the "best" score so far
        cp minmax_not_best0     ; branch if we've seen a better score already

        ca mm_lcl_ret_val       ; save this result as the Best Score So Far
        ts minmax_lcl_best

minmax_not_best0:
        ca minmax_lcl_undo_move ; remember that modified instruction addresses are effectively local variables, so restore this one from the stack
        ;.exec print_experiment(cm, cb, "Undoing game piece %d in cell %d at 0o%o, isMax==True", ("player", "minmax_lcl_next_cell", "minmax_lcl_undo_move"), "push_lcl_depth")
        td minmax_undo_move0
        cs one                  ; undo the trial move
minmax_undo_move0:
        ts 0

minmax_loop1_end:                ; get ready for the next cell iteration
        ao minmax_lcl_next_cell
        ao minmax_lcl_loop_cnt
        ; .print "decrement loop count to %ad, depth: %d, isMax==True-branch", push_lcl_depth
        cp minmax_loop1             ; go around again if the loop cnt is not exhausted

        ca minmax_lcl_best       ; return the best score found in AC
        sp minmax_exit           ; all done with this pass of isMax == True



        ; ======== This section is "isMax == False" =============
minmax_not_isMax:
        ca c_1000
        ts minmax_lcl_best      ; initialize to Most Positive
        ca zero                 ; prepare to scan all cells starting w/zero
        ts minmax_lcl_next_cell
        ca c_8n                 ; loop nine times
        ts minmax_lcl_loop_cnt
minmax_loop2:
        ca boardp               ; get the base board ptr to read the next cell
        ad minmax_lcl_next_cell
        td minmax_rd2
        td minmax_wr2
        td minmax_lcl_undo_move ; store this address on the 'stack' for now
minmax_rd2:
        ca 0                    ; fetch the next cell
        cp minmax_empty_cell2   ; continue if the cell is empty
        sp minmax_loop2_end     ; go to the next loop step if the cell is not empty

minmax_empty_cell2:             ; here, we know the cell we tested is empty, and a candidate for analysis
        ca opponent             ; fetch the Opponent marker 
minmax_wr2: 
        ts 0                    ; ... and write it into the cell
        ; .exec print_experiment(cm, cb, "Trying  game piece %d in cell %d, count %d, isMax==False", ("opponent", "minmax_lcl_next_cell", "minmax_lcl_loop_cnt"), "push_lcl_depth")
        sd zero  ; no-op
;        cs zero                 ; load negative zero, i.e. all ones    
;        sd minmax_lcl_isMax     ; Sum Digits, i.e., xor, will reverse isMax
        ca one                   ; load -1 to signal isMax should be True
        ; here begins the recursion
        ; .exec print_indent(cm, "starting recursive call to minimax: isMax==False-branch, cell at %d, depth: %d, loop_count: %d" % (cm.rd(rl("minmax_lcl_next_cell")), cm.rd(rl("push_lcl_depth")), cm.rd(rl("minmax_lcl_loop_cnt"))), rl("push_lcl_depth"))
        sp minimax
        ; the following adjustment probably shouldn't be done if the answer is Zero
        ad one;  push_lcl_depth       ; increase the (negative) score by the calling depth
        ts mm_lcl_ret_val       ; very local storage for the minimax return value
        ; .exec print_indent(cm, "finished recursive call to minimax: isMax==False-branch, cell at %d, depth: %d, loop_count: %d, score: 0o%o" % (cm.rd(rl("minmax_lcl_next_cell")), cm.rd(rl("push_lcl_depth")), cm.rd(rl("minmax_lcl_loop_cnt")), cm.rd(rl("mm_lcl_ret_val"))), rl("push_lcl_depth"))


        su minmax_lcl_best      ; determine if this was the "best" score so far
        cp minmax_best2
        sp minmax_not_best2     ; branch if we've seen a better score already

minmax_best2:
        ca mm_lcl_ret_val       ; save this result as the Best Score So Far
        ts minmax_lcl_best

minmax_not_best2:

        ca minmax_lcl_undo_move ; remember that modified instruction addresses are effectively local variables, so restore this one from the stack
        ; .exec print_experiment(cm, cb, "Undoing game piece %d in cell %d at 0o%o, isMax==False", ("player", "minmax_lcl_next_cell", "minmax_lcl_undo_move"), "push_lcl_depth")
        td minmax_undo_move2
        cs one                  ; undo the trial move
minmax_undo_move2:
        ts 0

minmax_loop2_end:                ; get ready for the next cell iteration
        ao minmax_lcl_next_cell
        ao minmax_lcl_loop_cnt
        cp minmax_loop2             ; go around again if the loop cnt is not exhausted

        ca minmax_lcl_best       ; return the best score found in AC
        sp minmax_exit           ; all done with this pass of isMax == False


minmax_exit:
        sd zero ; no-op for .exec
        ; .exec print_indent(cm, "Exiting minimax: IsMax:%d, depth: %d, score: %d" % (cm.rd(rl("minmax_lcl_isMax")), cm.rd(rl("push_lcl_depth")), cm.rd(rl("minmax_lcl_best"))), rl("push_lcl_depth"))
        sd zero         ; this is a no-op
        ; .exec print_board(cm, rl("boardp"), rl("push_lcl_depth"), rl("player") )
        ca minmax_lcl_best

        ; note that we stash and retrieve the AC during PoP
        sp pop_minmax
minmax_ret:
        sp 0

; the 'local data' for minmax must be copied/retrieved from the "stack" for recursion
; a "stack frame" must store from minmax_ret to minmax_lcl_data_end
minmax_lcl_isMax:       .word 0
minmax_lcl_score:       .word 0
minmax_lcl_next_cell:   .word 0
minmax_lcl_loop_cnt:    .word 0
minmax_lcl_best:        .word 0
minmax_lcl_undo_move:   .word 0
minmax_lcl_data_end:    .word 0   ; this is just a marker for the end of data to be pushed

mm_lcl_ret_val:         .word 0


;   
; // This will return the best possible move for the player 
; // This routine used to return row and move with a single pointer to a struct.
; // Not a WW Kind of Thing, so I changed it to return two ints via args
; // struct Move findBestMove) 
; void findBestMove(int *move_row, int *move_col) 
; { 
;     int bestVal = -1000; 
;     int bestMove_row = -1; 
;     int bestMove_col = -1; 
;   
;     // Traverse all cells, evaluate minimax function for 
;     // all empty cells. And return the cell with optimal 
;     // value. 
;     for (int i = 0; i<3; i++) 
;     { 
;         for (int j = 0; j<3; j++) 
;         { 
;             // Check if cell is empty 
;             if (board[i][j]=='_') 
;             { 
;                 // Make the move 
;                 board[i][j] = player; 
;   
;                 // compute evaluation function for this 
;                 // move. 
;                 int moveVal = minimax(0, false); 
;   
;                 // Undo the move 
;                 board[i][j] = '_'; 
;   
;                 // If the value of the current move is 
;                 // more than the best value, then update 
;                 // best/ 
;                 printf("minimax returned %d  ", moveVal);
;                 if (moveVal > bestVal) 
;                 { 
;                     bestMove_row = i; 
;                     bestMove_col = j; 
;                     bestVal = moveVal; 
;                     printf("Best\n");
;                 } 
;                 else {
;                     printf("\n");
;                 }
;             } 
;         } 
;     } 
;   
;     printf("The value of the best Move for Player %c is : %d\n", 
;             player, bestVal); 
;   
;     *move_row = bestMove_row;
;     *move_col = bestMove_col;
;     // return // bestMove; 
; } 
;   

; findBestMove cycles through the board to find the move that results 
; in the best score for the current Player
; The routine takes no explicit argument, but assumes that Player is the
; one we're trying to advance
; the assumption on calling this routine is that there's at least one move available to be tried
; This routine can take a while, so it redraws the screen a couple of times.  To indicate who'S
; doing what, we reverse the "player" bit temporarily.
findBestMove:
        ta fBM_ret

        ; switch the display to the machine player
        ca which_player
        sd const_1              ; xor a 1 into the LSB; i.e. 0->1 or 1->0
        ts which_player

        ; initialize the 'best stuff' detector
        cs c_1000
        ts fBM_lcl_best_value
        ; .print "Starting findBestMove, player=%d, opponent=%d", player, opponent
        cs one
        ts fBM_lcl_best_move
        ca c_8n
        ts fBM_lcl_loop_count
        ca zero
        ts fBM_lcl_current_cell
        ca boardp               ; we always start from cell zero`
        td fBM_fetch_cell
        td fBM_set_cell
        td fBM_clear_cell

        ; we start the loop here, but the first test will bypass the rest of the loop if the cell is already spoken for
fBM_fetch_cell: 
        ca 0                    ; read the current cell into AC
        cp fBM_try_move         ; if the cell is empty, go on to try out a move
        sp fBM_next_loop        ; take a pass on this non-empty cell, go on to the next one

fBM_try_move:
        ca player
        ; try out a move on this cell
        .print "fBM: try  empty cell %d, player=%d", fBM_lcl_current_cell, player
fBM_set_cell:
        ts 0
        sp draw_game_board    ; be careful to not trigger unintended recursion...

        cs one                  ; tell Minimax to try for a Min score on this cell
        ; .print "fBM: call minimax, player=%d, IsMax=%ad", player
        sp minimax              ; call the optimizer; best-score comes back in AC
        ;.print "fBM: minimax returned %ad"
        ts fBM_lcl_tmp_score    ; stash the score for now

        cs one                  ; undo the trial move, then evaluate the results of minimax
fBM_clear_cell:
        ts 0

        ; see if we bested a previous score
        ca fBM_lcl_tmp_score    ; compare the new result with previous best
        su fBM_lcl_best_value   ; branch if the old one was better; i.e., skip updating the eval_score_players
        cp fBM_next_loop

        ca fBM_lcl_tmp_score
        ts fBM_lcl_best_value   ; save the New Best Score
        ca fBM_lcl_current_cell ; and remember how we got here, i.e., which cell we tried
        .print "fBM new Best Move: score %d, cell %d, loop: %d", fBM_lcl_tmp_score, fBM_lcl_current_cell, fBM_lcl_loop_count
        ts fBM_lcl_best_move

fBM_next_loop:
        ao fBM_fetch_cell
        ao fBM_set_cell
        ao fBM_clear_cell
        ao fBM_lcl_current_cell
        ao fBM_lcl_loop_count
        cp fBM_fetch_cell       ; go 'round the loop again

        ; now switch the display back to the original (human) player
        ca which_player
        sd const_1              ; xor a 1 into the LSB; i.e. 0->1 or 1->0
        ts which_player

        ; when we're done with the loop, return the best move found (not the score, the cell that played best)
        ca fBM_lcl_best_move
        .print "fBM findBestMove for player %d returns move to cell %ad, score=%d", player, fBM_lcl_best_value
fBM_ret:
        sp 0
fBM_lcl_best_value:     ; best score found so far
        .word 0
fBM_lcl_best_move:      ; remember the move that resulted in the best score
        .word 0
fBM_lcl_loop_count:
        .word 0
fBM_lcl_current_cell:
        .word 0
fBM_lcl_tmp_score:
        .word 0

; 
;=====================================================================================

; /* 16-segment character generator, originally in Core Memory Clock
;  *
;  * Guy Fedorkow, Feb 22, 2025
;  *  originally for Arduino Mega
;  *
;  */
;


unit_test_main:
            cs c_scope_edge
            ts ds_argx
            ts ds_argy
            ca msgp
            sp draw_str
            ;si 0
            sp unit_test_main


msgp:       .word msg 
msg:        .flexl "N"
            .flexl "O"
            .flexl "W"
            .flexl " "
            .flexl "I"
            .flexl "S"
            .flexl " "
            .flexl "T"
            .flexl "H"
            .flexl "E"
            .flexl " "
            .flexl "T"
            .flexl "I"
            .flexl "M"
            .flexl "E"
            .word -1


; -----------------------------------------
; draw a character string on the CRT
; AC contains a pointer to the string, terminated by the first negative 'character'
; ds_argx and ds_argy give the initial (x, y) location
draw_str:
            ta ds_ret
            td ds_lcl_charp      ; save the character pointer passed in the ACC
ds_loop:
            ca ds_argx
            ts d16c_argx
            ca ds_argy
            ts d16c_argy
            ca ds_lcl_charp     ; walk the string from start to finish
            td ds_get_char
ds_get_char:
            ca 0                ; fetch the next character in the string
            sp draw_16seg_char    ; actually draw the character!

            ao ds_lcl_charp       ; prepare for next char in loop
            td ds_test_str_end
ds_test_str_end:
            ca 0
            cp ds_ret       ; test for a negative number as the marker for the string end; branch out if done

            ca ds_argx
            ad char_spacing
            ts ds_argx
            sp ds_loop

ds_ret:
            sp 0

ds_lcl_charp: .word 0    ; pointer to the next character to display
ds_argx:    .word 0
ds_argy:    .word 0

; ---------------------------

; The following table, indexed by ASCII character, gives a bit map of which of the 16
; segments should be lit for each symbol.
SixteenSegmentFlexop:
            .word SixteenSegmentFlexo
SixteenSegmentFlexo:
flexo_ucase:
        .word 0o125074   ; /* # */
        .word 0o125074   ; /* # */
        .word 0o100363   ; /* E */
        .word 0o104377   ; /* 8 */
        .word 0o125074   ; /* # */
        .word 0o000060   ; /* _ */
        .word 0o104317   ; /* A */
        .word 0o004077   ; /* 3 */
        .word 0o000000   ; /* (space) */
        .word 0o021000   ; /* : */
        .word 0o104273   ; /* S */
        .word 0o104214   ; /* 4 */
        .word 0o021063   ; /* I */
        .word 0o042000   ; /* / */
        .word 0o000374   ; /* U */
        .word 0o104167   ; /* 2 */
        .word 0o177777   ; /* (del) */
        .word 0o040400   ; /* ) */
        .word 0o021077   ; /* D */
        .word 0o110263   ; /* 5 */
        .word 0o114307   ; /* R */
        .word 0o002014   ; /* 1 */
        .word 0o000174   ; /* J */
        .word 0o000017   ; /* 7 */
        .word 0o010714   ; /* N */
        .word 0o012000   ; /* ( */
        .word 0o100303   ; /* F */
        .word 0o104373   ; /* 6 */
        .word 0o000363   ; /* C */
        .word 0o104000   ; /* - */
        .word 0o112300   ; /* K */
        .word 0o125074   ; /* # */
        .word 0o021003   ; /* T */
        .word 0o125074   ; /* # */
        .word 0o042063   ; /* Z */
        .word 0o177777   ; /* (del) */
        .word 0o000360   ; /* L */
        .word 0o000000   ; /* (space) */
        .word 0o050314   ; /* W */
        .word 0o125074   ; /* # */
        .word 0o104314   ; /* H */
        .word 0o000000   ; /* (space) */
        .word 0o104274   ; /* Y */
        .word 0o125074   ; /* # */
        .word 0o104307   ; /* P */
        .word 0o125074   ; /* # */
        .word 0o010377   ; /* Q */
        .word 0o125074   ; /* # */
        .word 0o000377   ; /* O */
        .word 0o177777   ; /* (del) */
        .word 0o025077   ; /* B */
        .word 0o125074   ; /* # */
        .word 0o004373   ; /* G */
        .word 0o125074   ; /* # */
        .word 0o104277   ; /* 9 */
        .word 0o125074   ; /* # */
        .word 0o002714   ; /* M */
        .word 0o177777   ; /* (del) */
        .word 0o052400   ; /* X */
        .word 0o125074   ; /* # */
        .word 0o042300   ; /* V */
        .word 0o177777   ; /* (del) */
        .word 0o042377   ; /* 0 */
        .word 0o177777   ; /* (del) */


; Lower Case not used yet
;flexo_lcase:
;        .word 0o125074   ; /* # */
;        .word 0o125074   ; /* # */
;        .word 0o140140   ; /* e */
;        .word 0o104377   ; /* 8 */
;        .word 0o125074   ; /* # */
;        .word 0o021000   ; /* | */
;        .word 0o120160   ; /* a */
;        .word 0o004077   ; /* 3 */
;        .word 0o000000   ; /* (space) */
;        .word 0o104060   ; /* = */
;        .word 0o120241   ; /* s */
;        .word 0o104214   ; /* 4 */
;        .word 0o020000   ; /* i */
;        .word 0o125000   ; /* + */
;        .word 0o020140   ; /* u */
;        .word 0o104167   ; /* 2 */
;        .word 0o177777   ; /* (del) */
;        .word 0o010000   ; /* . */
;        .word 0o024034   ; /* d */
;        .word 0o110263   ; /* 5 */
;        .word 0o100100   ; /* r */
;        .word 0o002014   ; /* 1 */
;        .word 0o021140   ; /* j */
;        .word 0o000017   ; /* 7 */
;        .word 0o120100   ; /* n */
;        .word 0o040000   ; /* , */
;        .word 0o125002   ; /* f */
;        .word 0o104373   ; /* 6 */
;        .word 0o100140   ; /* c */
;        .word 0o104000   ; /* - */
;        .word 0o033000   ; /* k */
;        .word 0o125074   ; /* # */
;        .word 0o100340   ; /* t */
;        .word 0o125074   ; /* # */
;        .word 0o140040   ; /* z */
;        .word 0o177777   ; /* (del) */
;        .word 0o000300   ; /* l */
;        .word 0o000000   ; /* (space) */
;        .word 0o050110   ; /* w */
;        .word 0o125074   ; /* # */
;        .word 0o120300   ; /* h */
;        .word 0o000000   ; /* (space) */
;        .word 0o005034   ; /* y */
;        .word 0o125074   ; /* # */
;        .word 0o101301   ; /* p */
;        .word 0o125074   ; /* # */
;        .word 0o121201   ; /* q */
;        .word 0o125074   ; /* # */
;        .word 0o120140   ; /* o */
;        .word 0o177777   ; /* (del) */
;        .word 0o120340   ; /* b */
;        .word 0o125074   ; /* # */
;        .word 0o121241   ; /* g */
;        .word 0o125074   ; /* # */
;        .word 0o104277   ; /* 9 */
;        .word 0o125074   ; /* # */
;        .word 0o124110   ; /* m */
;        .word 0o177777   ; /* (del) */
;        .word 0o052400   ; /* x */
;        .word 0o125074   ; /* # */
;        .word 0o040100   ; /* v */
;        .word 0o177777   ; /* (del) */
;        .word 0o042377   ; /* 0 */
;        .word 0o177777   ; /* (del) */


; // size of 16-segment characters
            .pp WIDTH_16SEG, 0o60
            .pp HEIGHT_16SEG, 0o110
            .pp OFFSET_16SEG, 0o10  ; 0d08
            .pp SPACING_16SEG, (WIDTH_16SEG + WIDTH_16SEG/4) * 64
;
            ; Delta word for vectors
            ;  Left 8 bits are horizontal, right 8 are vertical
            ;  Of each, only the six left bits are used

            .pp DOWN_LEFT, ((127 - (OFFSET_16SEG - 3)) * 256 * 2) + (255 - HEIGHT_16SEG)
            .pp UP_RIGHT,     (OFFSET_16SEG - 3) * 256 * 2   +       HEIGHT_16SEG
            .pp HORIZ_RIGHT,       WIDTH_16SEG * 256

            .pp UP_RIGHT_DIAG,   ((OFFSET_16SEG + WIDTH_16SEG) * 256)  +        HEIGHT_16SEG
            .pp DOWN_RIGHT_DIAG, ((WIDTH_16SEG - OFFSET_16SEG) * 256)  + (255 - HEIGHT_16SEG)

;
; // these defines give the relative offsets for the points
; // that make up a 16-segment display
        .pp P0x, 64* OFFSET_16SEG
        .pp P0y, 64* HEIGHT_16SEG

        .pp P1x, 64* (OFFSET_16SEG + WIDTH_16SEG/2)  
        .pp P1y, 64* HEIGHT_16SEG

        .pp P2x, 64* (OFFSET_16SEG + WIDTH_16SEG)
        .pp P2y, 64* HEIGHT_16SEG

        .pp P3x, 64* (OFFSET_16SEG/2 + WIDTH_16SEG)
        .pp P3y, 64* HEIGHT_16SEG/2

        .pp P4x, 64* WIDTH_16SEG
        .pp P4y, 64* 0

        .pp P5x, 64* WIDTH_16SEG/2      ;  P0...P1...P2
        .pp P5y, 64* 0                  ;  .         . 
                                        ;  .         .
        .pp P6x, 64* 0                  ;  .         .
        .pp P6y, 64* 0                  ;  P7...P8...P3
                                        ;  .         .
        .pp P7x, 64* OFFSET_16SEG/2     ;  .         .
        .pp P7y, 64* HEIGHT_16SEG/2     ;  .         .
                                        ;  P6...P5...P4

        .pp P8x, 64* (OFFSET_16SEG/2 + WIDTH_16SEG/2)
        .pp P8y, 64* HEIGHT_16SEG/2

;
; // and this array gives sixteen starting points and delta for each line
; // segment in the 16-segment display character.

seg_tab_startp:
        .word seg00x

seg00x: .word P0x  ;   {P0, P1}
seg00y: .word P0y
seg00d: .word HORIZ_RIGHT

seg01x: .word P1x  ;   {P1, P2},
seg01y: .word P1y
seg01d: .word HORIZ_RIGHT

seg02x: .word P2x  ;   {P2, P3},
seg02y: .word P2y
seg02d: .word DOWN_LEFT

seg03x: .word P3x  ;   {P3, P4},
seg03y: .word P3y
seg03d: .word DOWN_LEFT

seg04x: .word P5x  ;   {P4, P5},
seg04y: .word P5y
seg04d: .word HORIZ_RIGHT

seg05x: .word P6x  ;   {P5, P6},
seg05y: .word P6y
seg05d: .word HORIZ_RIGHT

seg06x: .word P6x  ;   {P6, P7},
seg06y: .word P6y
seg06d: .word UP_RIGHT

seg07x: .word P7x  ;   {P7, P0},
seg07y: .word P7y
seg07d: .word UP_RIGHT

seg08x: .word P0x  ;   {P0, P8},
seg08y: .word P0y
seg08d: .word DOWN_RIGHT_DIAG

seg09x: .word P1x                  ;   {P1, P8},
seg09y: .word P1y
seg09d: .word DOWN_LEFT 
; 
seg10x: .word P8x                  ;   {P2, P8}, 
seg10y: .word P8y
seg10d: .word UP_RIGHT_DIAG
 
seg11x: .word P8x                  ;   {P3, P8},
seg11y: .word P8y
seg11d: .word HORIZ_RIGHT

seg12x: .word P8x                 ;   {P4, P8},  
seg12y: .word P8y
seg12d: .word DOWN_RIGHT_DIAG

seg13x: .word P8x                 ;   {P5, P8},
seg13y: .word P8y
seg13d: .word DOWN_LEFT

seg14x: .word P6x                 ;   {P6, P8},
seg14y: .word P6y
seg14d: .word UP_RIGHT_DIAG
                  
seg15x: .word P7x                  ;   {P7, P8},
seg15y: .word P7y
seg15d: .word HORIZ_RIGHT       

seg_tab_endp:
        .word seg15x
char_spacing:
        .word SPACING_16SEG


; Draw a Flexo character passed in to this routine in the ACC
; First, find the segment map for a given character.  Input is a Flexo-coded character.
; The routine returns a 16-bit int where each bit represents one stroke in the character.  If the
; bit is one, draw the stroke; if not, don't draw.
; Character position is given by the args d16c_argx, d16c_argy.
draw_16seg_char:
        ta d16c_ret

        ad SixteenSegmentFlexop     ; add the table start addr to the offset in ACC
        td d16c_rd
d16c_rd:
        ca 0                        ; fetch the bit map
        ts d16c_lcl_seg_map

        ; draw the sixteen segments, starting with the most significant bit
        cs c_15                     ; prep for 16 times around the loop
        ts d16c_lcl_loop_cnt
        ca seg_tab_endp             ; walk the segment table back to front
        td d16c_read_seg_tabx       ; first table entry
;        td tmp_tabx
        ad one
        td d16c_read_seg_taby       ; second table entry
;        td tmp_taby
        ad one
        td d16c_read_seg_tabdxy     ; third table entry

; I've commented out a bit of debug code here to draw dots at each of the junction points in the
; 16-segment figure.  Use this to verify that the line segments are the right length...
d16s_loop:
        ; this strip draws dots at the intersection points
        ca 0  ; no op
;tmp_taby:
;        ca 0
        si scope_point
;tmp_tabx:
;        ca 0
;        rc 0
        ; end of debug hack
        ca d16c_lcl_seg_map
        cp d16c_draw_seg            ; branch if most significant bit is on

d16s_loop_continue:
        ca d16c_lcl_seg_map
        clc 1                       ; shift AC left by one bit
        ts d16c_lcl_seg_map
        ca d16c_read_seg_tabx
        su c_3
        td d16c_read_seg_tabx
;        td tmp_tabx
        ca d16c_read_seg_taby
        su c_3
        td d16c_read_seg_taby
;        td tmp_taby
        ca d16c_read_seg_tabdxy
        su c_3
        td d16c_read_seg_tabdxy
        ao d16c_lcl_loop_cnt
        cp d16s_loop
        sp d16c_ret                 ; bail out when count exhausted

; on entry to this code block, the three entries in the segment table should give:
;   _tab1 = X pos'n
;   _tab2 = Y pos'n
;   _tab3 = XY Delta vector
d16c_draw_seg:                      ; branch here if we're doing a segment, then return to the loop
        ; the SI uses the AC to set Y coord
d16c_read_seg_taby:
        ca 0
        ad d16c_argy
        si scope_vector    ; initialize vector gen with the y-coord in ACC

        ; the RC uses AC to set X coord and mem address for the vector length
d16c_read_seg_tabx:
        ca 0
        ad d16c_argx
d16c_read_seg_tabdxy:
        rc 0
        sp d16s_loop_continue

d16c_ret:   ;; Return from draw_16seg_char
        sp 0

d16c_argx:
        .word 0
d16c_argy:
        .word 0
d16c_lcl_seg_map:
        .word 0
d16c_lcl_loop_cnt:
        .word 0
;

;
;
;
; Character Table license
;
; /*
;  *  Project     Segmented LED Display - ASCII Library
;  *  @author     David Madison
;  *  @link       github.com/dmadison/Segmented-LED-Display-ASCII
;  *  @license    MIT - Copyright (c) 2017 David Madison
;  *
;  * Permission is hereby granted, free of charge, to any person obtaining a copy
;  * of this software and associated documentation files (the "Software"), to deal
;  * in the Software without restriction, including without limitation the rights
;  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
;  * copies of the Software, and to permit persons to whom the Software is
;  * furnished to do so, subject to the following conditions:
;  *
;  * The above copyright notice and this permission notice shall be included in
;  * all copies or substantial portions of the Software.
;  *
;  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
;  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
;  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
;  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
;  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
;  * THE SOFTWARE.
;  *
;  */
;
;
; /*********************************************************************************************************
;   END FILE
; *********************************************************************************************************/

